import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';
import { warnOnce } from '../logging.js';
var filterUsingOperator = function (itemValue, _a) {
    var tokenValue = _a.tokenValue, _b = _a.operator, operator = _b.operator, match = _b.match, tokenType = _b.tokenType;
    // For match="date" or match="datetime" we expect the value to be a Date object.
    // The token value is expected to be an ISO date- or datetime string, example:
    // match(operator="=", token="2020-01-01", value=new Date("2020-01-01")) == true
    if (match === 'date' || match === 'datetime') {
        return matchDateValue({ tokenValue: tokenValue, itemValue: itemValue, operator: operator, match: match });
    }
    // For custom match functions there is no expectation to value or token type: the function is supposed
    // to handle everything. It is recommended to treat both the token and the value as unknowns.
    else if (typeof match === 'function') {
        return match(itemValue, tokenValue);
    }
    else if (match) {
        throw new Error('Unsupported `operator.match` type given.');
    }
    // For default matching logic we expect the value to be a primitive type or an object that matches by reference.
    // The token can be an array (tokenType="enum") or a value (tokenType="value" or tokenType=undefined), examples:
    // match(operator="=", token="A", value="A") == true
    // match(operator="=", token=["A", "B"], value="A") == true
    return matchPrimitiveValue({ tokenValue: tokenValue, itemValue: itemValue, operator: operator, tokenType: tokenType });
};
function matchDateValue(_a) {
    var tokenValue = _a.tokenValue, itemValue = _a.itemValue, operator = _a.operator, match = _a.match;
    var comparator = match === 'date' ? compareDates : compareTimestamps;
    var comparisonResult = comparator(itemValue, tokenValue);
    switch (operator) {
        case '<':
            return comparisonResult < 0;
        case '<=':
            return comparisonResult <= 0;
        case '>':
            return comparisonResult > 0;
        case '>=':
            return comparisonResult >= 0;
        case '=':
            return comparisonResult === 0;
        case '!=':
            return comparisonResult !== 0;
        default:
            warnOnce("Unsupported operator \"".concat(operator, "\" given for match=\"").concat(match, "\"."));
            return false;
    }
}
function matchPrimitiveValue(_a) {
    var tokenValue = _a.tokenValue, itemValue = _a.itemValue, operator = _a.operator, tokenType = _a.tokenType;
    if (tokenType === 'enum') {
        if (!tokenValue || !Array.isArray(tokenValue)) {
            warnOnce('The token value must be an array when tokenType=="enum".');
            return false;
        }
        switch (operator) {
            case '=':
                return tokenValue && tokenValue.includes(itemValue);
            case '!=':
                return !tokenValue || !tokenValue.includes(itemValue);
            default:
                warnOnce("Unsupported operator \"".concat(operator, "\" given for tokenType==\"enum\"."));
                return false;
        }
    }
    switch (operator) {
        case '<':
            return itemValue < tokenValue;
        case '<=':
            return itemValue <= tokenValue;
        case '>':
            return itemValue > tokenValue;
        case '>=':
            return itemValue >= tokenValue;
        case '=':
            // eslint-disable-next-line eqeqeq
            return itemValue == tokenValue;
        case '!=':
            // eslint-disable-next-line eqeqeq
            return itemValue != tokenValue;
        case ':':
            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;
        case '!:':
            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;
        case '^':
            return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());
        case '!^':
            return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());
        // The unsupported operators result in an exception being thrown.
        // The exception can be avoided if using the match function.
        default:
            throw new Error('Unsupported operator given.');
    }
}
function freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {
    // If the operator is not a negation, we just need one property of the object to match.
    // If the operator is a negation, we want none of the properties of the object to match.
    var isNegation = operator.startsWith('!');
    return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](function (propertyKey) {
        var operators = filteringPropertiesMap[propertyKey].operators;
        var propertyOperator = operators[operator];
        if (!propertyOperator) {
            return isNegation;
        }
        return filterUsingOperator(item[propertyKey], { tokenValue: tokenValue, operator: propertyOperator });
    });
}
function filterByToken(token, item, filteringPropertiesMap) {
    if (token.propertyKey) {
        // token refers to a unknown property or uses an unsupported operator
        if (!(token.propertyKey in filteringPropertiesMap) ||
            !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {
            return false;
        }
        var property = filteringPropertiesMap[token.propertyKey];
        var operator = property.operators[token.operator];
        var itemValue = (operator === null || operator === void 0 ? void 0 : operator.match)
            ? item[token.propertyKey]
            : fixupFalsyValues(item[token.propertyKey]);
        return filterUsingOperator(itemValue, {
            tokenValue: token.value,
            operator: operator !== null && operator !== void 0 ? operator : { operator: token.operator },
        });
    }
    return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);
}
function defaultFilteringFunction(filteringPropertiesMap) {
    return function (item, query) {
        var _a;
        function evaluate(tokenOrGroup) {
            if ('operation' in tokenOrGroup) {
                var result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;
                for (var _i = 0, _a = tokenOrGroup.tokens; _i < _a.length; _i++) {
                    var group = _a[_i];
                    result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);
                }
                return result;
            }
            else {
                return filterByToken(tokenOrGroup, item, filteringPropertiesMap);
            }
        }
        return evaluate({
            operation: query.operation,
            tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens,
        });
    };
}
export function createPropertyFilterPredicate(propertyFiltering, query) {
    if (query === void 0) { query = { tokens: [], operation: 'and' }; }
    if (!propertyFiltering) {
        return null;
    }
    var filteringPropertiesMap = propertyFiltering.filteringProperties.reduce(function (acc, _a) {
        var _b;
        var key = _a.key, operators = _a.operators, defaultOperator = _a.defaultOperator;
        var operatorMap = (_b = {}, _b[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=' }, _b);
        operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {
            if (typeof op === 'string') {
                operatorMap[op] = { operator: op };
            }
            else {
                operatorMap[op.operator] = { operator: op.operator, match: op.match, tokenType: op.tokenType };
            }
        });
        acc[key] = { operators: operatorMap };
        return acc;
    }, {});
    var filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);
    return function (item) { return filteringFunction(item, query); };
}
export var fixupFalsyValues = function (value) {
    if (typeof value === 'boolean') {
        return value + '';
    }
    if (value || value === 0) {
        return value;
    }
    return '';
};
