{"version":3,"file":"single-tab-stop-navigation-context.js","sourceRoot":"","sources":["../../../../src/internal/context/single-tab-stop-navigation-context.tsx"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAEtC,OAAO,KAAK,EAAE,EACZ,aAAa,EACb,UAAU,EACV,UAAU,EACV,mBAAmB,EACnB,eAAe,EACf,MAAM,EACN,QAAQ,GACT,MAAM,OAAO,CAAC;AAEf,OAAO,EAAE,WAAW,EAAE,MAAM,uBAAuB,CAAC;AAQpD,MAAM,CAAC,MAAM,YAAY,GAGrB;IACF,gBAAgB,EAAE,KAAK;IACvB,iBAAiB,EAAE,GAAG,EAAE,CAAC,GAAG,EAAE,GAAE,CAAC;CAClC,CAAC;AAEF;;;GAGG;AACH,MAAM,CAAC,MAAM,8BAA8B,GAAG,aAAa,CAAC,YAAY,CAAC,CAAC;AAE1E,MAAM,UAAU,0BAA0B,CACxC,SAA8C,EAC9C,OAA+B;;IAE/B,MAAM,EAAE,gBAAgB,EAAE,uBAAuB,EAAE,iBAAiB,EAAE,GAAG,UAAU,CAAC,8BAA8B,CAAC,CAAC;IACpH,MAAM,CAAC,iBAAiB,EAAE,oBAAoB,CAAC,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC;IAClE,MAAM,kBAAkB,GAAG,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,KAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,IAAG,CAAC,CAAC;IACtE,MAAM,gBAAgB,GAAG,uBAAuB,IAAI,CAAC,kBAAkB,CAAC;IAExE,eAAe,CAAC,GAAG,EAAE;QACnB,IAAI,gBAAgB,IAAI,SAAS,IAAI,SAAS,CAAC,OAAO,EAAE;YACtD,MAAM,UAAU,GAAG,iBAAiB,CAAC,SAAS,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE,CAAC,oBAAoB,CAAC,WAAW,CAAC,CAAC,CAAC;YAC1G,OAAO,GAAG,EAAE,CAAC,UAAU,EAAE,CAAC;SAC3B;IACH,CAAC,CAAC,CAAC;IAEH,IAAI,QAAQ,GAAG,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,CAAC;IACjC,IAAI,gBAAgB,EAAE;QACpB,QAAQ,GAAG,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,QAAQ,mCAAI,CAAC,CAAC;KAC7D;IAED,OAAO,EAAE,gBAAgB,EAAE,QAAQ,EAAE,CAAC;AACxC,CAAC;AAiBD,MAAM,CAAC,MAAM,+BAA+B,GAAG,UAAU,CACvD,CACE,EACE,gBAAgB,EAChB,QAAQ,EACR,kBAAkB,EAClB,mBAAmB,EACnB,mBAAmB,EACnB,kBAAkB,GACmB,EACvC,GAA0C,EAC1C,EAAE;IACF,2EAA2E;IAC3E,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,GAAG,EAAW,CAAC,CAAC;IAC9C,uFAAuF;IACvF,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,GAAG,EAAmC,CAAC,CAAC;IACzE,iGAAiG;IACjG,MAAM,eAAe,GAAG,MAAM,CAAC,IAAI,OAAO,EAAoB,CAAC,CAAC;IAChE,gDAAgD;IAChD,MAAM,WAAW,GAAG,MAAM,CAAqB,IAAI,CAAC,CAAC;IAErD,SAAS,qBAAqB,CAAC,gBAAyB;QACtD,MAAM,0BAA0B,GAAG,WAAW,CAAC,gBAAgB,EAAE,QAAQ,CAAC,aAAa,CAAC,CAAC;QACzF,IAAI,0BAA0B,EAAE;YAC9B,uDAAuD;YACvD,UAAU,CAAC,GAAG,EAAE,CAAC,kBAAkB,aAAlB,kBAAkB,uBAAlB,kBAAkB,CAAG,gBAAgB,CAAC,EAAE,CAAC,CAAC,CAAC;SAC7D;IACH,CAAC;IAED,4DAA4D;IAC5D,2FAA2F;IAC3F,SAAS,iBAAiB,CAAC,gBAAyB,EAAE,aAAqC;QACzF,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;QACzC,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,aAAa,CAAC,CAAC;QAC3D,MAAM,WAAW,GAAG,CAAC,CAAC,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC;QACpE,MAAM,cAAc,GAAG,WAAW,CAAC,OAAO,KAAK,gBAAgB,IAAI,CAAC,CAAC,CAAA,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAG,gBAAgB,CAAC,CAAA,CAAC;QAC7G,IAAI,cAAc,KAAK,WAAW,EAAE;YAClC,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC;YAC9D,aAAa,CAAC,cAAc,CAAC,CAAC;SAC/B;QACD,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAG,gBAAgB,CAAC,CAAC;QACxC,OAAO,GAAG,EAAE,CAAC,mBAAmB,CAAC,gBAAgB,CAAC,CAAC;IACrD,CAAC;IACD,SAAS,mBAAmB,CAAC,gBAAyB;QACpD,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAC5C,aAAa,CAAC,OAAO,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC;QAC/C,qBAAqB,aAArB,qBAAqB,uBAArB,qBAAqB,CAAG,gBAAgB,CAAC,CAAC;IAC5C,CAAC;IAED,2GAA2G;IAC3G,SAAS,iBAAiB;;QACxB,WAAW,CAAC,OAAO,GAAG,kBAAkB,EAAE,CAAC;QAC3C,KAAK,MAAM,gBAAgB,IAAI,UAAU,CAAC,OAAO,EAAE;YACjD,MAAM,WAAW,GAAG,MAAA,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,mCAAI,KAAK,CAAC;YAC3E,MAAM,cAAc,GAAG,WAAW,CAAC,OAAO,KAAK,gBAAgB,IAAI,CAAC,CAAC,CAAA,mBAAmB,aAAnB,mBAAmB,uBAAnB,mBAAmB,CAAG,gBAAgB,CAAC,CAAA,CAAC;YAC7G,IAAI,cAAc,KAAK,WAAW,EAAE;gBAClC,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,EAAE,cAAc,CAAC,CAAC;gBAC9D,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAE,CAAC,cAAc,CAAC,CAAC;aAC9D;SACF;IACH,CAAC;IAED,SAAS,cAAc;QACrB,OAAO,WAAW,CAAC,OAAO,CAAC;IAC7B,CAAC;IAED,SAAS,YAAY,CAAC,OAAgB;QACpC,OAAO,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACzC,CAAC;IAED,mBAAmB,CAAC,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,iBAAiB,EAAE,cAAc,EAAE,YAAY,EAAE,CAAC,CAAC,CAAC;IAEtF,OAAO,CACL,oBAAC,8BAA8B,CAAC,QAAQ,IAAC,KAAK,EAAE,EAAE,gBAAgB,EAAE,iBAAiB,EAAE,IACpF,QAAQ,CAC+B,CAC3C,CAAC;AACJ,CAAC,CACF,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, {\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { nodeBelongs } from '../utils/node-belongs';\n\nexport type FocusableChangeHandler = (isFocusable: boolean) => void;\n\nexport interface SingleTabStopNavigationOptions {\n  tabIndex?: number;\n}\n\nexport const defaultValue: {\n  navigationActive: boolean;\n  registerFocusable(focusable: HTMLElement, handler: FocusableChangeHandler): () => void;\n} = {\n  navigationActive: false,\n  registerFocusable: () => () => {},\n};\n\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\n\nexport function useSingleTabStopNavigation(\n  focusable: null | React.RefObject<HTMLElement>,\n  options?: { tabIndex?: number }\n) {\n  const { navigationActive: contextNavigationActive, registerFocusable } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = options?.tabIndex && options?.tabIndex < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n\n  let tabIndex = options?.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : options?.tabIndex ?? 0;\n  }\n\n  return { navigationActive, tabIndex };\n}\n\nexport interface SingleTabStopNavigationProviderProps {\n  navigationActive: boolean;\n  children: React.ReactNode;\n  getNextFocusTarget: () => null | HTMLElement;\n  isElementSuppressed?(focusableElement: Element): boolean;\n  onRegisterFocusable?(focusableElement: Element): void;\n  onUnregisterActive?(focusableElement: Element): void;\n}\n\nexport interface SingleTabStopNavigationAPI {\n  updateFocusTarget(): void;\n  getFocusTarget(): null | HTMLElement;\n  isRegistered(element: Element): boolean;\n}\n\nexport const SingleTabStopNavigationProvider = forwardRef(\n  (\n    {\n      navigationActive,\n      children,\n      getNextFocusTarget,\n      isElementSuppressed,\n      onRegisterFocusable,\n      onUnregisterActive,\n    }: SingleTabStopNavigationProviderProps,\n    ref: React.Ref<SingleTabStopNavigationAPI>\n  ) => {\n    // A set of registered focusable elements that can use keyboard navigation.\n    const focusables = useRef(new Set<Element>());\n    // A map of registered focusable element handlers to update the respective tab indices.\n    const focusHandlers = useRef(new Map<Element, FocusableChangeHandler>());\n    // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n    const focusablesState = useRef(new WeakMap<Element, boolean>());\n    // A reference to the currently focused element.\n    const focusTarget = useRef<null | HTMLElement>(null);\n\n    function onUnregisterFocusable(focusableElement: Element) {\n      const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n      if (isUnregisteringFocusedNode) {\n        // Wait for unmounted node to get removed from the DOM.\n        setTimeout(() => onUnregisterActive?.(focusableElement), 0);\n      }\n    }\n\n    // Register a focusable element to allow navigating into it.\n    // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n    function registerFocusable(focusableElement: Element, changeHandler: FocusableChangeHandler) {\n      focusables.current.add(focusableElement);\n      focusHandlers.current.set(focusableElement, changeHandler);\n      const isFocusable = !!focusablesState.current.get(focusableElement);\n      const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        changeHandler(newIsFocusable);\n      }\n      onRegisterFocusable?.(focusableElement);\n      return () => unregisterFocusable(focusableElement);\n    }\n    function unregisterFocusable(focusableElement: Element) {\n      focusables.current.delete(focusableElement);\n      focusHandlers.current.delete(focusableElement);\n      onUnregisterFocusable?.(focusableElement);\n    }\n\n    // Update focus target with next single focusable element and notify all registered focusables of a change.\n    function updateFocusTarget() {\n      focusTarget.current = getNextFocusTarget();\n      for (const focusableElement of focusables.current) {\n        const isFocusable = focusablesState.current.get(focusableElement) ?? false;\n        const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n        if (newIsFocusable !== isFocusable) {\n          focusablesState.current.set(focusableElement, newIsFocusable);\n          focusHandlers.current.get(focusableElement)!(newIsFocusable);\n        }\n      }\n    }\n\n    function getFocusTarget() {\n      return focusTarget.current;\n    }\n\n    function isRegistered(element: Element) {\n      return focusables.current.has(element);\n    }\n\n    useImperativeHandle(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));\n\n    return (\n      <SingleTabStopNavigationContext.Provider value={{ navigationActive, registerFocusable }}>\n        {children}\n      </SingleTabStopNavigationContext.Provider>\n    );\n  }\n);\n"]}