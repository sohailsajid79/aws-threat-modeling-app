{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/property-filter/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ComparisonOperator,\n  InternalFilteringOption,\n  InternalFilteringProperty,\n  InternalToken,\n  Token,\n} from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringText: string\n): null | InternalFilteringProperty {\n  let maxLength = 0;\n  let matchedProperty: null | InternalFilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (\n      (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel)) ||\n      (property.propertyLabel.length > maxLength &&\n        startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase()))\n    ) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function matchTokenValue(\n  { property, operator, value }: InternalToken,\n  filteringOptions: readonly InternalFilteringOption[]\n): Token {\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch: Token = { propertyKey: property?.propertyKey, operator, value };\n  for (const option of propertyOptions) {\n    if ((option.label && option.label === value) || (!option.label && option.value === value)) {\n      // exact match found: return it\n      return { propertyKey: property?.propertyKey, operator, value: option.value };\n    }\n\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === (option.label ?? option.value ?? '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nexport function removeOperator(source: string, operator: string) {\n  const operatorLastIndex = source.indexOf(operator) + operator.length;\n  const textWithoutOperator = source.slice(operatorLastIndex);\n  // We need to remove the first leading space in case the user presses space\n  // after the operator, for example: Owner: admin, will result in value of ` admin`\n  // and we need to remove the first space, if the user added any more spaces only the\n  // first one will be removed.\n  return trimFirstSpace(textWithoutOperator);\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n\ninterface AbstractToken {\n  operator: any;\n}\n\ninterface AbstractTokenGroup<T extends AbstractToken> {\n  operation: any;\n  tokens: readonly (T | AbstractTokenGroup<T>)[];\n}\n\n/**\n * Transforms query token groups to tokens (only taking 1 level of nesting).\n */\nexport function tokenGroupToTokens<T extends AbstractToken>(tokenGroups: readonly (T | AbstractTokenGroup<T>)[]): T[] {\n  const tokens: T[] = [];\n  for (const tokenOrGroup of tokenGroups) {\n    if ('operator' in tokenOrGroup) {\n      tokens.push(tokenOrGroup);\n    } else {\n      for (const nestedTokenOrGroup of tokenOrGroup.tokens) {\n        if ('operator' in nestedTokenOrGroup) {\n          tokens.push(nestedTokenOrGroup);\n        } else {\n          // Ignore deeply nested tokens\n        }\n      }\n    }\n  }\n  return tokens;\n}\n"]}