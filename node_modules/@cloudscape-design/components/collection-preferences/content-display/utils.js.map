{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../src/collection-preferences/content-display/utils.ts"],"names":[],"mappings":"AAQA,MAAM,UAAU,gBAAgB,CAAC,EAC/B,OAAO,EACP,cAAc,GAIf;IACC,qFAAqF;IACrF,MAAM,WAAW,GAAG,IAAI,GAAG,EAAgC,CAAC;IAC5D,4EAA4E;IAC5E,KAAK,MAAM,EAAE,EAAE,EAAE,OAAO,EAAE,IAAI,cAAc,EAAE;QAC5C,6FAA6F;QAC7F,WAAW,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,KAAK,EAAE,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;KACjD;IACD,uFAAuF;IACvF,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;QAC5B,MAAM,QAAQ,GAAG,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;QAC5C,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE,kCAAO,MAAM,KAAE,OAAO,EAAE,CAAC,CAAC,CAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,OAAO,CAAA,IAAG,CAAC;KACzE;IACD,OAAO,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC;AAC1C,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,OAA4C,EAAE,UAAkB;IACjG,UAAU,GAAG,UAAU,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,CAAC;IAE7C,IAAI,CAAC,UAAU,EAAE;QACf,OAAO,OAAO,CAAC;KAChB;IAED,OAAO,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC,IAAI,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,CAAC;AAC1F,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { CollectionPreferencesProps } from '../interfaces';\n\nexport interface OptionWithVisibility extends CollectionPreferencesProps.ContentDisplayOption {\n  visible: boolean;\n}\n\nexport function getSortedOptions({\n  options,\n  contentDisplay,\n}: {\n  options: ReadonlyArray<CollectionPreferencesProps.ContentDisplayOption>;\n  contentDisplay: ReadonlyArray<CollectionPreferencesProps.ContentDisplayItem>;\n}): ReadonlyArray<OptionWithVisibility> {\n  // By using a Map, we are guaranteed to preserve insertion order on future iteration.\n  const optionsById = new Map<string, OptionWithVisibility>();\n  // We insert contentDisplay first so we respect the currently selected order\n  for (const { id, visible } of contentDisplay) {\n    // If an option is provided in contentDisplay and not options, we default the label to the id\n    optionsById.set(id, { id, label: id, visible });\n  }\n  // We merge options data, and insert any that were not in contentDisplay as non-visible\n  for (const option of options) {\n    const existing = optionsById.get(option.id);\n    optionsById.set(option.id, { ...option, visible: !!existing?.visible });\n  }\n  return Array.from(optionsById.values());\n}\n\nexport function getFilteredOptions(options: ReadonlyArray<OptionWithVisibility>, filterText: string) {\n  filterText = filterText.trim().toLowerCase();\n\n  if (!filterText) {\n    return options;\n  }\n\n  return options.filter(option => option.label.toLowerCase().trim().includes(filterText));\n}\n"]}