// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { getMinColumnSpan, getMinRowSpan } from "../../internal/utils/layout";
/**
 * Creates an announcement object describing the last user move.
 */
export function createOperationAnnouncement(transition, direction) {
    var _a, _b;
    const { operation, layoutShift, itemsLayout } = transition;
    const targetItem = (_a = itemsLayout.items.find((it) => it.id === transition.draggableItem.id)) !== null && _a !== void 0 ? _a : null;
    if (!layoutShift) {
        return null;
    }
    const firstMove = layoutShift.moves[0];
    const targetId = (_b = firstMove === null || firstMove === void 0 ? void 0 : firstMove.itemId) !== null && _b !== void 0 ? _b : targetItem === null || targetItem === void 0 ? void 0 : targetItem.id;
    if (!targetId) {
        return null;
    }
    const itemMoves = layoutShift.moves.filter((m) => m.itemId === targetId);
    const lastItemMove = itemMoves[itemMoves.length - 1];
    const placement = lastItemMove !== null && lastItemMove !== void 0 ? lastItemMove : targetItem;
    const conflicts = new Set(layoutShift.conflicts);
    const disturbed = new Set(layoutShift.moves.map((move) => move.itemId));
    disturbed.delete(targetId);
    return {
        type: "dnd-action",
        item: transition.draggableItem,
        operation,
        placement: {
            x: placement.x,
            y: placement.y,
            width: placement.width,
            height: placement.height,
        },
        direction,
        conflicts,
        disturbed,
    };
}
/**
 * Applies i18nStrings to the announcement object to produce a string for the live region.
 */
export function announcementToString(announcement, items, i18nStrings, columns) {
    if (!announcement) {
        return "";
    }
    const item = announcement.item;
    const toItem = (id) => items.find((it) => (it === null || it === void 0 ? void 0 : it.id) === id);
    const formatDirection = (direction) => {
        if (!direction) {
            return null;
        }
        return direction === "left" || direction === "right" ? "horizontal" : "vertical";
    };
    function createDndActionAnnouncement(announcement) {
        const placement = announcement.placement;
        const direction = formatDirection(announcement.direction);
        const conflicts = [...announcement.conflicts].map(toItem);
        const disturbed = [...announcement.disturbed].map(toItem);
        switch (announcement.operation) {
            case "reorder":
                return i18nStrings.liveAnnouncementDndItemReordered({
                    item,
                    placement,
                    direction: direction,
                    conflicts,
                    disturbed,
                });
            case "resize":
                return i18nStrings.liveAnnouncementDndItemResized({
                    item,
                    placement,
                    direction: direction,
                    isMinimalColumnsReached: placement.width === getMinColumnSpan(item, columns),
                    isMinimalRowsReached: placement.height === getMinRowSpan(item),
                    conflicts,
                    disturbed,
                });
            case "insert":
                return i18nStrings.liveAnnouncementDndItemInserted({ item, placement, conflicts, disturbed });
        }
    }
    function createItemRemovedAnnouncement(announcement) {
        return i18nStrings.liveAnnouncementItemRemoved({ item, disturbed: [...announcement.disturbed].map(toItem) });
    }
    switch (announcement.type) {
        case "dnd-started":
            return i18nStrings.liveAnnouncementDndStarted(announcement.operation);
        case "dnd-action":
            return createDndActionAnnouncement(announcement);
        case "dnd-committed":
            return i18nStrings.liveAnnouncementDndCommitted(announcement.operation);
        case "dnd-discarded":
            return i18nStrings.liveAnnouncementDndDiscarded(announcement.operation);
        case "item-removed":
            return createItemRemovedAnnouncement(announcement);
    }
}
//# sourceMappingURL=announcements.js.map