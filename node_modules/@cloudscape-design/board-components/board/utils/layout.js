// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { createPlaceholdersLayout, getDefaultColumnSpan, getDefaultRowSpan } from "../../internal/utils/layout";
import { normalizeInsertionPath } from "./path";
export function getLayoutColumns(transition) {
    return transition.itemsLayout.columns;
}
// The rows can be overridden during transition to create more drop targets at the bottom.
export function getLayoutRows(transition) {
    var _a, _b, _c;
    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;
    const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);
    const itemHeight = (_c = layoutItem === null || layoutItem === void 0 ? void 0 : layoutItem.height) !== null && _c !== void 0 ? _c : getDefaultRowSpan(transition.draggableItem);
    // Add extra row for resize when already at the bottom.
    if (transition.operation === "resize") {
        return Math.max(layout.rows, layoutItem ? layoutItem.y + layoutItem.height + 1 : 0);
    }
    // Add extra row(s) for reorder/insert based on item's height.
    else {
        return Math.max(layout.rows, transition.itemsLayout.rows + itemHeight);
    }
}
export function getLayoutPlaceholders(transition) {
    const rows = getLayoutRows(transition);
    const columns = getLayoutColumns(transition);
    return createPlaceholdersLayout(rows, columns);
}
/**
 * Retrieves direction from where the inserting item comes.
 */
export function getInsertionDirection(cursorOffset) {
    if (cursorOffset.x < 0) {
        return "right";
    }
    if (cursorOffset.x > 0) {
        return "left";
    }
    if (cursorOffset.y < 0) {
        return "down";
    }
    if (cursorOffset.y > 0) {
        return "up";
    }
    return "right";
}
/**
 * Applies transition operation (reorder/move/insert) and retrieves an object that describes the updated
 * layout and the moves to be made including and not including items float to top.
 *
 * The layout shift w/o refloat is used for rendering and w/ refloat is used for live announcements.
 */
export function getLayoutShift(transition, path, insertionDirection) {
    if (path.length === 0) {
        return null;
    }
    const width = getDefaultColumnSpan(transition.draggableItem, getLayoutColumns(transition));
    const height = getDefaultRowSpan(transition.draggableItem);
    const rows = getLayoutRows(transition);
    const columns = getLayoutColumns(transition);
    switch (transition.operation) {
        case "resize":
            return transition.layoutEngine.resize({ itemId: transition.draggableItem.id, path });
        case "reorder":
            return transition.layoutEngine.move({ itemId: transition.draggableItem.id, path });
        case "insert":
            return transition.layoutEngine.insert({
                itemId: transition.draggableItem.id,
                width,
                height,
                path: normalizeInsertionPath(path, insertionDirection !== null && insertionDirection !== void 0 ? insertionDirection : "right", columns, rows),
            });
    }
}
//# sourceMappingURL=layout.js.map