{"version":3,"file":"path.js","sourceRoot":"","sources":["../../../../src/board/utils/path.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Direction } from \"../../internal/interfaces\";\nimport { Rect } from \"../../internal/interfaces\";\nimport { Position } from \"../../internal/utils/position\";\n\n/**\n * The insertion operation is similar to reorder yet the first path entry is treated differently.\n * The normalization removes leading path entries if on the same edge to optimize UX.\n */\nexport function normalizeInsertionPath(\n  path: readonly Position[],\n  insertionDirection: Direction,\n  columns: number,\n  rows: number,\n): Position[] {\n  let edgeIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    switch (insertionDirection) {\n      case \"left\": {\n        if (path[i].x === 0) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"right\": {\n        if (path[i].x === columns - 1) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"up\": {\n        if (path[i].y === 0) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"down\": {\n        if (path[i].y === rows - 1) {\n          edgeIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  return path.slice(edgeIndex);\n}\n\nexport function appendMovePath(prevPath: readonly Position[], collisionRect: Rect): Position[] {\n  return appendPath(prevPath, new Position({ x: collisionRect.left, y: collisionRect.top }));\n}\n\nexport function appendResizePath(prevPath: readonly Position[], collisionRect: Rect): Position[] {\n  return appendPath(prevPath, new Position({ x: collisionRect.right, y: collisionRect.bottom }));\n}\n\n/**\n * The operation path must be strictly incremental (each dx + dy == 1). However, the actual collisions\n * data can have gaps due to pointer events throttling or other factors.\n *\n * The function produces next path from previous path and the target position by incrementally adding steps.\n */\nfunction appendPath(prevPath: readonly Position[], nextPosition: Position): Position[] {\n  const path: Array<Position> = [...prevPath];\n  const lastPosition = prevPath[prevPath.length - 1];\n\n  if (!lastPosition) {\n    return [nextPosition];\n  }\n\n  const vx = Math.sign(nextPosition.x - lastPosition.x);\n  const vy = Math.sign(nextPosition.y - lastPosition.y);\n\n  let { x, y } = lastPosition;\n  let safetyCounter = 0;\n\n  while (x !== nextPosition.x || y !== nextPosition.y) {\n    if (++safetyCounter === 100) {\n      throw new Error(\"Infinite loop in appendPath.\");\n    }\n    if (x !== nextPosition.x) {\n      x += vx;\n    } else {\n      y += vy;\n    }\n    path.push(new Position({ x, y }));\n  }\n\n  return path;\n}\n"]}