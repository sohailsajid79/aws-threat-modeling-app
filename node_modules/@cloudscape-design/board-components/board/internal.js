import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect, useRef } from "react";
import { usePrevious } from "@dnd-kit/utilities";
import clsx from "clsx";
import { getIsRtl } from "@cloudscape-design/component-toolkit/internal";
import { getDataAttributes } from "../internal/base-component/get-data-attributes";
import { useContainerColumns } from "../internal/breakpoints";
import { TRANSITION_DURATION_MS } from "../internal/constants";
import { useDragSubscription } from "../internal/dnd-controller/controller";
import { useGlobalDragStateStyles } from "../internal/global-drag-state-styles";
import Grid from "../internal/grid";
import { ItemContainer } from "../internal/item-container";
import LiveRegion from "../internal/live-region";
import { createPlaceholdersLayout, getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan, interpretItems, } from "../internal/utils/layout";
import { Position } from "../internal/utils/position";
import { useAutoScroll } from "../internal/utils/use-auto-scroll";
import { useMergeRefs } from "../internal/utils/use-merge-refs";
import Placeholder from "./placeholder";
import { selectTransitionRows, useTransition } from "./transition";
import { announcementToString } from "./utils/announcements";
import { createTransforms } from "./utils/create-transforms";
import { createItemsChangeEvent } from "./utils/events";
import styles from "./styles.css.js";
export function InternalBoard({ items, renderItem, onItemsChange, empty, i18nStrings, __internalRootRef, ...rest }) {
    var _a, _b;
    const containerAccessRef = useRef(null);
    const [currentColumns, containerQueryRef] = useContainerColumns();
    const containerRef = useMergeRefs(containerAccessRef, containerQueryRef);
    const itemContainerRef = useRef({});
    const isRtl = () => getIsRtl(containerAccessRef.current);
    useGlobalDragStateStyles();
    const autoScrollHandlers = useAutoScroll();
    const [transitionState, dispatch] = useTransition({ isRtl });
    const transition = transitionState.transition;
    const removeTransition = transitionState.removeTransition;
    const transitionAnnouncement = transitionState.announcement;
    const acquiredItem = (_a = transition === null || transition === void 0 ? void 0 : transition.acquiredItem) !== null && _a !== void 0 ? _a : null;
    const acquiredItemElement = transition === null || transition === void 0 ? void 0 : transition.acquiredItemElement;
    // Using cached columns from transition to ensure no unexpected changes in the process.
    const columns = transition ? transition.itemsLayout.columns : currentColumns;
    // Use previous items while remove transition is in progress.
    items = (_b = removeTransition === null || removeTransition === void 0 ? void 0 : removeTransition.items) !== null && _b !== void 0 ? _b : items;
    // The acquired item is the one being inserting at the moment but not submitted yet.
    // It needs to be included to the layout to be a part of layout shifts and rendering.
    items = acquiredItem ? [...items, acquiredItem] : items;
    const itemsLayout = interpretItems(items, columns);
    const layoutItemById = new Map(itemsLayout.items.map((item) => [item.id, item]));
    const layoutItemIndexById = new Map(itemsLayout.items.map((item, index) => [item.id, index]));
    // Items and layout items must maintain the same order visually, in the DOM and in the data
    // to ensure on-change events and tab order work as expected.
    items = [...items].sort((a, b) => { var _a, _b; return ((_a = layoutItemIndexById.get(a.id)) !== null && _a !== void 0 ? _a : -1) - ((_b = layoutItemIndexById.get(b.id)) !== null && _b !== void 0 ? _b : -1); });
    // When an item gets acquired or removed the focus needs to be dispatched on the next render.
    const focusNextRenderIdRef = useRef(null);
    useEffect(() => {
        const focusTarget = focusNextRenderIdRef.current;
        if (focusTarget) {
            itemContainerRef.current[focusTarget].focusDragHandle();
        }
        focusNextRenderIdRef.current = null;
    });
    // Submit scheduled removal after a delay to let animations play.
    useEffect(() => {
        if (!removeTransition) {
            return;
        }
        const timeoutId = setTimeout(() => {
            var _a;
            dispatch({ type: "submit" });
            const removedItemIndex = items.findIndex((it) => it.id === removeTransition.removedItem.id);
            const nextIndexToFocus = removedItemIndex !== items.length - 1 ? removedItemIndex : items.length - 2;
            const newItems = createItemsChangeEvent(items, removeTransition.layoutShift);
            const itemIdToFocus = (_a = newItems.detail.items[nextIndexToFocus]) === null || _a === void 0 ? void 0 : _a.id;
            if (itemIdToFocus) {
                itemContainerRef.current[itemIdToFocus].focusDragHandle();
            }
            onItemsChange(newItems);
        }, TRANSITION_DURATION_MS);
        return () => clearTimeout(timeoutId);
    }, [removeTransition, items, onItemsChange]);
    // When item is inserting with the keyboard it keeps rendering by the palette and upon submission
    // it starts rendering by the board. This transitions might lead to the focus being lost from the item's drag handle.
    // The below code refocuses the drag handle when detecting the acquired item is no longer used.
    const acquiredItemId = usePrevious(acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id);
    const previousAcquiredItemElement = usePrevious(acquiredItemElement);
    useEffect(() => {
        var _a;
        if (acquiredItemId && previousAcquiredItemElement && !acquiredItemElement) {
            (_a = itemContainerRef.current[acquiredItemId]) === null || _a === void 0 ? void 0 : _a.focusDragHandle();
        }
    }, [acquiredItemId, previousAcquiredItemElement, acquiredItemElement]);
    const rows = selectTransitionRows(transitionState) || itemsLayout.rows;
    const placeholdersLayout = createPlaceholdersLayout(rows, itemsLayout.columns);
    function isElementOverBoard(rect) {
        const board = containerAccessRef.current;
        const boardContains = (target) => board === target || board.contains(target);
        const left = !isRtl() ? rect.left : document.documentElement.clientWidth - rect.left;
        const right = !isRtl() ? rect.right : document.documentElement.clientWidth - rect.right;
        const { top, bottom } = rect;
        return (boardContains(document.elementFromPoint(left, top)) ||
            boardContains(document.elementFromPoint(right, top)) ||
            boardContains(document.elementFromPoint(right, bottom)) ||
            boardContains(document.elementFromPoint(left, bottom)));
    }
    useDragSubscription("start", ({ operation, interactionType, draggableItem, collisionRect, collisionIds }) => {
        dispatch({
            type: "init",
            operation,
            interactionType,
            itemsLayout,
            // TODO: resolve any
            // The code only works assuming the board can take any draggable.
            // If draggables can be of different types a check of some sort is required here.
            draggableItem: draggableItem,
            draggableRect: collisionRect,
            collisionIds: interactionType === "pointer" && isElementOverBoard(collisionRect) ? collisionIds : [],
        });
        autoScrollHandlers.addPointerEventHandlers();
    });
    useDragSubscription("update", ({ interactionType, collisionIds, positionOffset, collisionRect }) => {
        dispatch({
            type: "update-with-pointer",
            collisionIds: interactionType === "pointer" && isElementOverBoard(collisionRect) ? collisionIds : [],
            positionOffset,
            draggableRect: collisionRect,
        });
    });
    useDragSubscription("submit", () => {
        dispatch({ type: "submit" });
        autoScrollHandlers.removePointerEventHandlers();
        if (!transition) {
            throw new Error("Invariant violation: no transition.");
        }
        if (!transition.layoutShift ||
            transition.layoutShift.conflicts.length > 0 ||
            transition.layoutShift.moves.length === 0) {
            return null;
        }
        // Commit new layout for insert case.
        if (transition.operation === "insert") {
            onItemsChange(createItemsChangeEvent([...items, transition.draggableItem], transition.layoutShift));
        }
        // Commit new layout for reorder/resize case.
        else {
            onItemsChange(createItemsChangeEvent(items, transition.layoutShift));
        }
    });
    useDragSubscription("discard", () => {
        dispatch({ type: "discard" });
        autoScrollHandlers.removePointerEventHandlers();
    });
    useDragSubscription("acquire", ({ droppableId, draggableItem, renderAcquiredItem }) => {
        const placeholder = placeholdersLayout.items.find((it) => it.id === droppableId);
        // If missing then it does not belong to this board.
        if (!placeholder) {
            return;
        }
        dispatch({
            type: "acquire-item",
            position: new Position({ x: placeholder.x, y: placeholder.y }),
            layoutElement: containerAccessRef.current,
            acquiredItemElement: renderAcquiredItem(),
        });
        focusNextRenderIdRef.current = draggableItem.id;
    });
    const removeItemAction = (removedItem) => {
        dispatch({ type: "init-remove", items, itemsLayout, removedItem });
    };
    function onItemMove(direction) {
        if (transition) {
            dispatch({ type: "update-with-keyboard", direction });
            autoScrollHandlers.scheduleActiveElementScrollIntoView(TRANSITION_DURATION_MS);
        }
    }
    const announcement = transitionAnnouncement
        ? announcementToString(transitionAnnouncement, items, i18nStrings, itemsLayout.columns)
        : "";
    return (_jsxs("div", { ref: __internalRootRef, ...getDataAttributes(rest), children: [_jsx("div", { ref: containerRef, className: clsx(styles.root, { [styles.empty]: rows === 0 }), children: rows > 0 ? (_jsx(Grid, { isRtl: isRtl, columns: itemsLayout.columns, layout: [...placeholdersLayout.items, ...itemsLayout.items], children: (gridContext) => {
                        var _a;
                        const layoutShift = (_a = transition === null || transition === void 0 ? void 0 : transition.layoutShift) !== null && _a !== void 0 ? _a : removeTransition === null || removeTransition === void 0 ? void 0 : removeTransition.layoutShift;
                        const transforms = layoutShift ? createTransforms(itemsLayout, layoutShift.moves, gridContext) : {};
                        // Exclude drag target from transforms.
                        if (transition && transition.interactionType === "pointer") {
                            delete transforms[transition.draggableItem.id];
                        }
                        const children = [];
                        /* Placeholders are rendered even when there is no transition to support the first collisions check. */
                        placeholdersLayout.items.forEach((placeholder) => {
                            var _a;
                            return children.push(_jsx(Placeholder, { id: placeholder.id, state: transition ? (((_a = transition.collisionIds) === null || _a === void 0 ? void 0 : _a.has(placeholder.id)) ? "hover" : "active") : "default", gridContext: gridContext, columns: itemsLayout.columns }, placeholder.id));
                        });
                        items.forEach((item) => {
                            const layoutItem = layoutItemById.get(item.id);
                            const isResizing = (transition === null || transition === void 0 ? void 0 : transition.operation) === "resize" && (transition === null || transition === void 0 ? void 0 : transition.draggableItem.id) === item.id;
                            const itemSize = layoutItem !== null && layoutItem !== void 0 ? layoutItem : {
                                width: getDefaultColumnSpan(item, itemsLayout.columns),
                                height: getDefaultRowSpan(item),
                            };
                            const itemMaxSize = isResizing && layoutItem ? { width: itemsLayout.columns - layoutItem.x, height: 999 } : itemSize;
                            children.push(_jsx(ItemContainer, { ref: (elem) => {
                                    if (elem) {
                                        itemContainerRef.current[item.id] = elem;
                                    }
                                    else {
                                        delete itemContainerRef.current[item.id];
                                    }
                                }, item: item, transform: transforms[item.id], inTransition: !!transition || !!removeTransition, placed: item.id !== (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id), acquired: item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id), getItemSize: () => ({
                                    width: gridContext.getWidth(itemSize.width),
                                    minWidth: gridContext.getWidth(getMinColumnSpan(item, itemsLayout.columns)),
                                    maxWidth: gridContext.getWidth(itemMaxSize.width),
                                    height: gridContext.getHeight(itemSize.height),
                                    minHeight: gridContext.getHeight(getMinRowSpan(item)),
                                    maxHeight: gridContext.getHeight(itemMaxSize.height),
                                }), onKeyMove: onItemMove, isRtl: isRtl, children: item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) && acquiredItemElement
                                    ? () => acquiredItemElement
                                    : () => renderItem(item, { removeItem: () => removeItemAction(item) }) }, item.id));
                        });
                        return children;
                    } })) : (empty) }), _jsx(LiveRegion, { children: announcement })] }));
}
//# sourceMappingURL=internal.js.map