// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useReducer } from "react";
import { getLogicalBoundingClientRect } from "@cloudscape-design/component-toolkit/internal";
import { LayoutEngine } from "../internal/layout-engine/engine";
import { Coordinates } from "../internal/utils/coordinates";
import { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from "../internal/utils/layout";
import { Position } from "../internal/utils/position";
import { createOperationAnnouncement } from "./utils/announcements";
import { getHoveredRect } from "./utils/get-hovered-rect";
import { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from "./utils/layout";
import { appendMovePath, appendResizePath } from "./utils/path";
export function useTransition({ isRtl }) {
    return useReducer(createTransitionReducer({ isRtl }), {
        transition: null,
        removeTransition: null,
        announcement: null,
    });
}
export function selectTransitionRows(state) {
    return state.transition ? getLayoutRows(state.transition) : 0;
}
function createTransitionReducer({ isRtl }) {
    return function transitionReducer(state, action) {
        switch (action.type) {
            case "init":
                return initTransition(action);
            case "init-remove":
                return initRemoveTransition(action);
            case "submit":
                return submitTransition(state);
            case "discard":
                return discardTransition(state);
            case "update-with-pointer":
                return updateTransitionWithPointerEvent(state, action);
            case "update-with-keyboard":
                return updateTransitionWithKeyboardEvent(state, action, { isRtl });
            case "acquire-item":
                return acquireTransitionItem(state, action);
        }
    };
}
function initTransition({ operation, interactionType, itemsLayout, draggableItem, draggableRect, collisionIds, }) {
    const transition = {
        operation,
        interactionType,
        itemsLayout,
        layoutEngine: new LayoutEngine(itemsLayout),
        insertionDirection: null,
        draggableItem,
        draggableRect,
        acquiredItem: null,
        collisionIds: new Set(),
        layoutShift: null,
        path: [],
    };
    const placeholdersLayout = getLayoutPlaceholders(transition);
    const layoutItem = itemsLayout.items.find((it) => it.id === draggableItem.id);
    let path = [];
    if (interactionType === "pointer" || operation === "insert") {
        const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);
        const appendPath = operation === "resize" ? appendResizePath : appendMovePath;
        path = layoutItem ? appendPath([], collisionRect) : [];
    }
    else if (layoutItem) {
        path =
            operation === "resize"
                ? [new Position({ x: layoutItem.x + layoutItem.width, y: layoutItem.y + layoutItem.height })]
                : [new Position({ x: layoutItem.x, y: layoutItem.y })];
    }
    return {
        transition: { ...transition, path },
        removeTransition: null,
        announcement: layoutItem ? { type: "dnd-started", item: draggableItem, operation } : null,
    };
}
function initRemoveTransition({ items, removedItem, itemsLayout }) {
    const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);
    const removeTransition = { items, removedItem, layoutShift };
    return { transition: null, removeTransition, announcement: null };
}
function submitTransition(state) {
    var _a;
    const { transition, removeTransition } = state;
    if (removeTransition) {
        const disturbed = new Set(removeTransition.layoutShift.moves.map((move) => move.itemId));
        disturbed.delete(removeTransition.removedItem.id);
        return {
            transition: null,
            removeTransition: null,
            announcement: { type: "item-removed", item: removeTransition.removedItem, disturbed },
        };
    }
    if (!transition) {
        throw new Error("Invariant violation: no transition.");
    }
    const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;
    const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some((it) => it.id === item.id);
    return ((_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.conflicts.length) === 0
        ? {
            transition: null,
            removeTransition: null,
            announcement: itemBelongsToBoard ? { type: "dnd-committed", item, operation } : null,
        }
        : {
            transition: null,
            removeTransition: null,
            announcement: itemBelongsToBoard ? { type: "dnd-discarded", item, operation } : null,
        };
}
function discardTransition(state) {
    const { transition, removeTransition } = state;
    if (removeTransition) {
        throw new Error("Can't discard remove transition.");
    }
    if (!transition) {
        throw new Error("Invariant violation: no transition.");
    }
    const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;
    const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some((it) => it.id === item.id);
    return {
        transition: null,
        removeTransition: null,
        announcement: itemBelongsToBoard ? { type: "dnd-discarded", item, operation } : null,
    };
}
function updateTransitionWithPointerEvent(state, { collisionIds, positionOffset, draggableRect }) {
    var _a, _b, _c;
    const { transition } = state;
    if (!transition) {
        throw new Error("Invariant violation: no transition.");
    }
    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;
    const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);
    const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);
    const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);
    const itemSize = itemWidth * itemHeight;
    const isOutOfBoundaries = transition.operation !== "resize" ? collisionIds.length < itemSize : collisionIds.length === 0;
    if (isOutOfBoundaries) {
        return {
            transition: {
                ...transition,
                draggableRect,
                collisionIds: new Set(),
                layoutShift: null,
                insertionDirection: null,
            },
            removeTransition: null,
            announcement: null,
        };
    }
    const placeholdersLayout = getLayoutPlaceholders(transition);
    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);
    const appendPath = transition.operation === "resize" ? appendResizePath : appendMovePath;
    const path = appendPath(transition.path, collisionRect);
    const insertionDirection = (_c = transition.insertionDirection) !== null && _c !== void 0 ? _c : getInsertionDirection(positionOffset);
    const layoutShift = getLayoutShift(transition, path, insertionDirection);
    return {
        transition: {
            ...transition,
            draggableRect,
            collisionIds: new Set(collisionIds),
            layoutShift,
            path,
            insertionDirection,
        },
        removeTransition: null,
        announcement: null,
    };
}
function updateTransitionWithKeyboardEvent(state, { direction }, { isRtl }) {
    const { transition } = state;
    if (!transition) {
        throw new Error("Invariant violation: no transition.");
    }
    const updateManualItemTransition = (transition, direction) => {
        var _a, _b;
        const xDelta = direction === "left" ? -1 : direction === "right" ? 1 : 0;
        const yDelta = direction === "up" ? -1 : direction === "down" ? 1 : 0;
        const lastPosition = transition.path[transition.path.length - 1];
        const nextPosition = new Position({ x: lastPosition.x + xDelta, y: lastPosition.y + yDelta });
        const nextPath = [...transition.path, nextPosition];
        // Check resizing below min size.
        const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;
        const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);
        const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);
        const minHeight = getMinRowSpan(transition.draggableItem);
        if (transition.operation === "resize" &&
            layoutItem &&
            (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)) {
            return state;
        }
        try {
            const layoutShift = getLayoutShift(transition, nextPath);
            const nextTransition = { ...transition, layoutShift, path: nextPath };
            return {
                transition: nextTransition,
                removeTransition: null,
                announcement: createOperationAnnouncement(nextTransition, direction),
            };
        }
        catch (e) {
            // Can't create next layout because the next path is out of bounds.
            return state;
        }
    };
    switch (direction) {
        case "left":
            return updateManualItemTransition(transition, !isRtl() ? "left" : "right");
        case "right":
            return updateManualItemTransition(transition, !isRtl() ? "right" : "left");
        case "up":
            return updateManualItemTransition(transition, "up");
        case "down":
            return updateManualItemTransition(transition, "down");
    }
}
function acquireTransitionItem(state, { position, layoutElement, acquiredItemElement }) {
    const { transition } = state;
    if (!transition) {
        throw new Error("Invariant violation: no transition.");
    }
    const { columns } = transition.itemsLayout;
    const layoutRect = getLogicalBoundingClientRect(layoutElement);
    const itemRect = transition.draggableRect;
    const coordinatesX = itemRect.left - layoutRect.insetInlineStart;
    const offset = new Coordinates({ x: coordinatesX, y: itemRect.top - layoutRect.insetBlockStart });
    const insertionDirection = getInsertionDirection(offset);
    // Update original insertion position if the item can't fit into the layout by width.
    const width = getDefaultColumnSpan(transition.draggableItem, columns);
    position = new Position({ x: Math.min(columns - width, position.x), y: position.y });
    const path = [...transition.path, position];
    const layoutShift = getLayoutShift(transition, path, insertionDirection);
    // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.
    const acquiredItem = { ...transition.draggableItem, columnOffset: 0, columnSpan: 1, rowSpan: 1 };
    const nextTransition = {
        ...transition,
        collisionIds: new Set(),
        layoutShift,
        path,
        acquiredItem,
        acquiredItemElement,
    };
    return {
        transition: nextTransition,
        removeTransition: null,
        announcement: createOperationAnnouncement(nextTransition, null),
    };
}
//# sourceMappingURL=transition.js.map