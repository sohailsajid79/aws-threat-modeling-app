// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect } from "react";
import { useStableCallback } from "@cloudscape-design/component-toolkit/internal";
import { Coordinates } from "../utils/coordinates";
import { EventEmitter } from "./event-emitter";
import { getHoveredDroppables } from "./get-hovered-droppables";
class DragAndDropController extends EventEmitter {
    constructor() {
        super(...arguments);
        this.droppables = new Map();
        this.transition = null;
    }
    /**
     * Inits a drag transition and issues a "start" event.
     *
     * The method overrides the previous transition if exists (w/o a cancellation event)!
     */
    start(transition) {
        this.transition = { ...transition };
        this.emit("start", this.getDragAndDropData(transition.startCoordinates));
    }
    /**
     * Updates current transition with given coordinates and issues an "update" event.
     */
    update(coordinates) {
        this.emit("update", this.getDragAndDropData(coordinates));
    }
    /**
     * Removes transition and issues a "submit" event.
     */
    submit() {
        this.emit("submit");
        this.transition = null;
    }
    /**
     * Removes transition and issues a "discard" event.
     */
    discard() {
        this.emit("discard");
        this.transition = null;
    }
    /**
     * Issues an "acquire" event to notify the current transition draggable is acquired by the given droppable.
     */
    acquire(droppableId, renderAcquiredItem) {
        if (!this.transition) {
            throw new Error("Invariant violation: no transition present for acquire.");
        }
        this.emit("acquire", { droppableId, draggableItem: this.transition.draggableItem, renderAcquiredItem });
    }
    /**
     * Registers a droppable used for collisions check, acquire, and dropTarget provision.
     */
    addDroppable(id, context, element) {
        this.droppables.set(id, { element, context });
    }
    /**
     * Un-registers the droppable - use it when component unmounts.
     */
    removeDroppable(id) {
        this.droppables.delete(id);
    }
    /**
     * Retrieves all registered droppables to run a manual match against.
     */
    getDroppables() {
        return [...this.droppables.entries()];
    }
    getDragAndDropData(coordinates) {
        if (!this.transition) {
            throw new Error("Invariant violation: no transition present for interaction.");
        }
        const positionOffset = Coordinates.cursorOffset(coordinates, this.transition.startCoordinates);
        const collisionRect = this.getCollisionRect(this.transition, coordinates);
        const { collisionIds, dropTarget } = this.getCollisions(collisionRect);
        return { ...this.transition, positionOffset, coordinates, collisionRect, collisionIds, dropTarget };
    }
    getCollisionRect(transition, coordinates) {
        const originalCollisionRect = transition.getCollisionRect(transition.operation, coordinates, null);
        const { dropTarget } = this.getCollisions(originalCollisionRect);
        return transition.getCollisionRect(transition.operation, coordinates, dropTarget);
    }
    getCollisions(collisionRect) {
        const droppableEntries = [...this.droppables.entries()];
        const droppableElements = droppableEntries.map(([id, entry]) => [id, entry.element]);
        const collisionIds = getHoveredDroppables(collisionRect, droppableElements);
        if (collisionIds.length === 0) {
            return { collisionIds, dropTarget: null };
        }
        const matchedDroppable = droppableEntries.find(([id]) => id === collisionIds[0]);
        if (!matchedDroppable) {
            throw new Error("Invariant violation: no droppable matches collision.");
        }
        return { collisionIds, dropTarget: matchedDroppable[1].context };
    }
}
// Controller is a singleton and is shared between all d&d elements.
const controller = new DragAndDropController();
export function useDragSubscription(event, handler) {
    const stableHandler = useStableCallback(handler);
    useEffect(() => controller.on(event, stableHandler), [event, stableHandler]);
}
export function useDraggable({ draggableItem, getCollisionRect, }) {
    return {
        start(operation, interactionType, startCoordinates) {
            controller.start({ operation, interactionType, draggableItem, getCollisionRect, startCoordinates });
        },
        updateTransition(coordinates) {
            controller.update(coordinates);
        },
        submitTransition() {
            controller.submit();
        },
        discardTransition() {
            controller.discard();
        },
        acquire(droppableId, renderAcquiredItem) {
            controller.acquire(droppableId, renderAcquiredItem);
        },
        getDroppables() {
            return controller.getDroppables();
        },
    };
}
export function useDroppable({ itemId, context, getElement, }) {
    useEffect(() => {
        controller.addDroppable(itemId, context, getElement());
        return () => controller.removeDroppable(itemId);
    }, [itemId, context, getElement]);
}
//# sourceMappingURL=controller.js.map