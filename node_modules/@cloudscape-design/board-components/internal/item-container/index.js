import { jsx as _jsx } from "react/jsx-runtime";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { createContext, forwardRef, useContext, useEffect, useImperativeHandle, useRef, useState, } from "react";
import { createPortal } from "react-dom";
import { CSS as CSSUtil } from "@dnd-kit/utilities";
import clsx from "clsx";
import { getLogicalBoundingClientRect, getLogicalClientX } from "@cloudscape-design/component-toolkit/internal";
import { useDraggable, useDragSubscription, } from "../dnd-controller/controller";
import { Coordinates } from "../utils/coordinates";
import { getNormalizedElementRect } from "../utils/screen";
import { throttle } from "../utils/throttle";
import { getCollisionRect } from "./get-collision-rect";
import { getNextDroppable } from "./get-next-droppable";
import styles from "./styles.css.js";
export const ItemContext = createContext(null);
export function useItemContext() {
    const ctx = useContext(ItemContext);
    if (!ctx) {
        throw new Error("Unable to find BoardItem context.");
    }
    return ctx;
}
export const ItemContainer = forwardRef(ItemContainerComponent);
function ItemContainerComponent({ item, placed, acquired, inTransition, transform, getItemSize, onKeyMove, children, isRtl }, ref) {
    var _a, _b, _c, _d, _e, _f;
    const originalSizeRef = useRef({ width: 0, height: 0 });
    const pointerOffsetRef = useRef(new Coordinates({ x: 0, y: 0 }));
    const pointerBoundariesRef = useRef(null);
    const [transition, setTransition] = useState(null);
    const [isHidden, setIsHidden] = useState(false);
    const muteEventsRef = useRef(false);
    const itemRef = useRef(null);
    const draggableApi = useDraggable({
        draggableItem: item,
        getCollisionRect: (operation, coordinates, dropTarget) => {
            const sizeOverride = operation === "insert" && dropTarget ? getItemSize(dropTarget) : null;
            return getCollisionRect(operation, itemRef.current, coordinates, sizeOverride);
        },
    });
    function updateTransition({ operation, interactionType, draggableItem, collisionRect, coordinates, dropTarget, }) {
        if (item.id === draggableItem.id) {
            const [width, height] = [collisionRect.right - collisionRect.left, collisionRect.bottom - collisionRect.top];
            const pointerOffset = pointerOffsetRef.current;
            if (operation === "resize") {
                setTransition({
                    operation,
                    interactionType,
                    itemId: draggableItem.id,
                    sizeTransform: {
                        width: Math.max(getItemSize(null).minWidth, Math.min(getItemSize(null).maxWidth, width - pointerOffset.x)),
                        height: Math.max(getItemSize(null).minHeight, height - pointerOffset.y),
                    },
                    positionTransform: null,
                });
            }
            else if (operation === "insert" || operation === "reorder") {
                setTransition({
                    operation,
                    interactionType,
                    itemId: draggableItem.id,
                    sizeTransform: dropTarget ? getItemSize(dropTarget) : originalSizeRef.current,
                    positionTransform: { x: coordinates.x - pointerOffset.x, y: coordinates.y - pointerOffset.y },
                    hasDropTarget: !!dropTarget,
                });
            }
        }
    }
    useDragSubscription("start", (detail) => updateTransition(detail));
    useDragSubscription("update", (detail) => updateTransition(detail));
    useDragSubscription("submit", () => {
        setTransition(null);
        setIsHidden(false);
        muteEventsRef.current = false;
    });
    useDragSubscription("discard", () => {
        setTransition(null);
        setIsHidden(false);
        muteEventsRef.current = false;
    });
    // During the transition listen to pointer move and pointer up events to update/submit transition.
    const transitionInteractionType = (_a = transition === null || transition === void 0 ? void 0 : transition.interactionType) !== null && _a !== void 0 ? _a : null;
    const transitionItemId = (_b = transition === null || transition === void 0 ? void 0 : transition.itemId) !== null && _b !== void 0 ? _b : null;
    useEffect(() => {
        const onPointerMove = throttle((event) => {
            var _a, _b, _c, _d;
            const coordinates = Coordinates.fromEvent(event, { isRtl: isRtl() });
            draggableApi.updateTransition(new Coordinates({
                x: Math.max(coordinates.x, (_b = (_a = pointerBoundariesRef.current) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : Number.NEGATIVE_INFINITY),
                y: Math.max(coordinates.y, (_d = (_c = pointerBoundariesRef.current) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : Number.NEGATIVE_INFINITY),
            }));
        }, 10);
        const onPointerUp = () => {
            onPointerMove.cancel();
            draggableApi.submitTransition();
        };
        if (transitionInteractionType === "pointer" && transitionItemId === item.id) {
            window.addEventListener("pointermove", onPointerMove);
            window.addEventListener("pointerup", onPointerUp);
        }
        return () => {
            window.removeEventListener("pointermove", onPointerMove);
            window.removeEventListener("pointerup", onPointerUp);
        };
        // draggableApi is not expected to change
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [item.id, transitionInteractionType, transitionItemId]);
    useEffect(() => {
        if (transitionInteractionType === "keyboard" && transitionItemId === item.id) {
            const onPointerDown = () => draggableApi.submitTransition();
            window.addEventListener("pointerdown", onPointerDown, true);
            return () => {
                window.removeEventListener("pointerdown", onPointerDown, true);
            };
        }
        // draggableApi is not expected to change
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [item.id, transitionInteractionType, transitionItemId]);
    function onKeyboardTransitionToggle(operation) {
        // The acquired item is a copy and does not have the transition state.
        // However, pressing "Space" or "Enter" on the acquired item must submit the active transition.
        if (acquired) {
            return draggableApi.submitTransition();
        }
        // Create new transition if missing.
        if (!transition) {
            const rect = getNormalizedElementRect(itemRef.current);
            const coordinates = new Coordinates({
                x: operation === "drag" ? rect.left : rect.right,
                y: operation === "drag" ? rect.top : rect.bottom,
            });
            if (operation === "drag" && !placed) {
                draggableApi.start("insert", "keyboard", coordinates);
            }
            else if (operation === "drag") {
                draggableApi.start("reorder", "keyboard", coordinates);
            }
            else {
                draggableApi.start("resize", "keyboard", coordinates);
            }
        }
        // Submit a transition if existing.
        else {
            draggableApi.submitTransition();
        }
    }
    function handleInsert(direction) {
        // Find the closest droppable (in the direction) to the item.
        const droppables = draggableApi.getDroppables();
        const nextDroppable = getNextDroppable({
            draggableElement: itemRef.current,
            droppables,
            direction,
            isRtl: isRtl(),
        });
        if (!nextDroppable) {
            // TODO: add announcement
            // Context: the keyboard insertion only works when there is some droppable area in the specified direction.
            // That means that only some arrow keys might work which is confusing for a screen-reader user.
            // Alternatively, we can consider a multi-step insertion where the user would first explicitly select the desired board.
            return;
        }
        // Notify the respective droppable of the intention to insert the item in it.
        draggableApi.acquire(nextDroppable, () => children(true));
        setIsHidden(true);
        muteEventsRef.current = true;
    }
    function onHandleKeyDown(operation, event) {
        const canInsert = transition && operation === "drag" && !placed;
        const canNavigate = transition || operation === "drag";
        // The insert is handled by the item and the navigation is delegated to the containing layout.
        const move = (direction) => {
            if (canInsert) {
                handleInsert(direction);
            }
            else if (canNavigate) {
                onKeyMove === null || onKeyMove === void 0 ? void 0 : onKeyMove(direction);
            }
        };
        const discard = () => {
            if (transition || acquired) {
                draggableApi.discardTransition();
            }
        };
        switch (event.key) {
            case "ArrowUp":
                return move("up");
            case "ArrowDown":
                return move("down");
            case "ArrowLeft":
                return move("left");
            case "ArrowRight":
                return move("right");
            case " ":
            case "Enter":
                return onKeyboardTransitionToggle(operation);
            case "Escape":
                return discard();
        }
    }
    function onBlur() {
        // When drag- or resize handle on palette or board item loses focus the transition must be submitted with two exceptions:
        // 1. If the last interaction is not "keyboard" (the user clicked on another handle issuing a new transition);
        // 2. If the item is acquired by the board (in that case the focus moves to the board item which is expected, palette item is hidden and all events handlers must be muted).
        if (transition && transition.interactionType === "keyboard" && !muteEventsRef.current) {
            draggableApi.submitTransition();
        }
    }
    function onDragHandlePointerDown(event) {
        // Calculate the offset between item's top-left corner and the pointer landing position.
        const rect = getLogicalBoundingClientRect(itemRef.current);
        const clientX = getLogicalClientX(event, isRtl());
        const clientY = event.clientY;
        pointerOffsetRef.current = new Coordinates({
            x: clientX - rect.insetInlineStart,
            y: clientY - rect.insetBlockStart,
        });
        originalSizeRef.current = { width: rect.inlineSize, height: rect.blockSize };
        pointerBoundariesRef.current = null;
        draggableApi.start(!placed ? "insert" : "reorder", "pointer", Coordinates.fromEvent(event, { isRtl: isRtl() }));
    }
    function onDragHandleKeyDown(event) {
        onHandleKeyDown("drag", event);
    }
    function onResizeHandlePointerDown(event) {
        // Calculate the offset between item's bottom-right corner and the pointer landing position.
        const rect = getLogicalBoundingClientRect(itemRef.current);
        const clientX = getLogicalClientX(event, isRtl());
        const clientY = event.clientY;
        pointerOffsetRef.current = new Coordinates({ x: clientX - rect.insetInlineEnd, y: clientY - rect.insetBlockEnd });
        originalSizeRef.current = { width: rect.inlineSize, height: rect.blockSize };
        // Calculate boundaries below which the cursor cannot move.
        const minWidth = getItemSize(null).minWidth;
        const minHeight = getItemSize(null).minHeight;
        pointerBoundariesRef.current = new Coordinates({
            x: clientX - rect.inlineSize + minWidth,
            y: clientY - rect.blockSize + minHeight,
        });
        draggableApi.start("resize", "pointer", Coordinates.fromEvent(event, { isRtl: isRtl() }));
    }
    function onResizeHandleKeyDown(event) {
        onHandleKeyDown("resize", event);
    }
    const itemTransitionStyle = {};
    const itemTransitionClassNames = [];
    if (inTransition) {
        itemTransitionClassNames.push(styles.inTransition);
    }
    if (transition && transition.interactionType === "pointer") {
        // Adjust the dragged/resized item to the pointer's location.
        itemTransitionClassNames.push(transition.operation === "resize" ? styles.resized : styles.dragged);
        itemTransitionStyle.insetInlineStart = (_c = transition.positionTransform) === null || _c === void 0 ? void 0 : _c.x;
        itemTransitionStyle.insetBlockStart = (_d = transition.positionTransform) === null || _d === void 0 ? void 0 : _d.y;
        itemTransitionStyle.inlineSize = (_e = transition.sizeTransform) === null || _e === void 0 ? void 0 : _e.width;
        itemTransitionStyle.blockSize = (_f = transition.sizeTransform) === null || _f === void 0 ? void 0 : _f.height;
        itemTransitionStyle.pointerEvents = "none";
    }
    if (isHidden) {
        itemTransitionClassNames.push(styles.hidden);
    }
    if (transform) {
        // The moved items positions are altered with CSS transform.
        if (transform.type === "move") {
            itemTransitionClassNames.push(styles.transformed);
            itemTransitionStyle.transform = CSSUtil.Transform.toString({
                x: transform.x,
                y: transform.y,
                scaleX: 1,
                scaleY: 1,
            });
            itemTransitionStyle.width = transform.width + "px";
            itemTransitionStyle.height = transform.height + "px";
        }
        // The item is removed from the DOM after animations play.
        // During the animations the removed item is hidden with styles.
        if (transform.type === "remove") {
            itemTransitionClassNames.push(styles.removed);
        }
    }
    const dragHandleRef = useRef(null);
    useImperativeHandle(ref, () => ({
        focusDragHandle: () => { var _a; return (_a = dragHandleRef.current) === null || _a === void 0 ? void 0 : _a.focus(); },
    }));
    const isActive = (!!transition && !isHidden) || !!acquired;
    const shouldUsePortal = (transition === null || transition === void 0 ? void 0 : transition.operation) === "insert" && (transition === null || transition === void 0 ? void 0 : transition.interactionType) === "pointer";
    const childrenRef = useRef(null);
    if (!inTransition || isActive) {
        childrenRef.current = children(!!(transition === null || transition === void 0 ? void 0 : transition.hasDropTarget));
    }
    const content = (_jsx("div", { ref: itemRef, className: clsx(styles.root, ...itemTransitionClassNames), style: itemTransitionStyle, "data-item-id": item.id, onBlur: onBlur, children: _jsx(ItemContext.Provider, { value: {
                isActive,
                dragHandle: {
                    ref: dragHandleRef,
                    onPointerDown: onDragHandlePointerDown,
                    onKeyDown: onDragHandleKeyDown,
                    isActive: isActive && (transition === null || transition === void 0 ? void 0 : transition.operation) === "reorder",
                },
                resizeHandle: placed
                    ? {
                        onPointerDown: onResizeHandlePointerDown,
                        onKeyDown: onResizeHandleKeyDown,
                        isActive: isActive && (transition === null || transition === void 0 ? void 0 : transition.operation) === "resize",
                    }
                    : null,
            }, children: childrenRef.current }) }));
    return shouldUsePortal ? _jsx("div", { children: createPortal(content, document.body) }) : content;
}
//# sourceMappingURL=index.js.map