{"version":3,"file":"engine-cache.js","sourceRoot":"","sources":["../../../../src/internal/layout-engine/engine-cache.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAKtC;;;;;GAKG;AACH,MAAM,OAAO,qBAAqB;IAKhC,YAAY,KAAwB;QAJ7B,aAAQ,GAAoB,IAAI,CAAC;QAEhC,SAAI,GAAG,IAAI,KAAK,EAAyB,CAAC;QAGhD,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACrB,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACH,OAAO,CAAC,QAAkB,EAAE,OAAgC;QAC1D,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE;YAChC,IAAI,QAAQ,CAAC,QAAS,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,IAAI,QAAQ,CAAC,QAAS,CAAC,CAAC,KAAK,QAAQ,CAAC,CAAC,EAAE;gBAC9E,OAAO,QAAQ,CAAC;aACjB;SACF;QAED,MAAM,QAAQ,GAAG,IAAI,qBAAqB,CAAC,OAAO,EAAE,CAAC,CAAC;QACtD,QAAQ,CAAC,QAAQ,GAAG,QAAQ,CAAC;QAC7B,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEzB,OAAO,QAAQ,CAAC;IAClB,CAAC;CACF","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineState } from \"./engine-state\";\n\n/**\n * The cache is used to avoid duplicate computations for the same initial state and path.\n * The cache must be invalidated once the items layout has changed e.g. as result of the operation commit.\n * The cache is a tree of nodes with the root node representing the initial state and empty path. The\n * rest of the tree store all previous state computations per path.\n */\nexport class LayoutEngineCacheNode {\n  public position: null | Position = null;\n  public state: LayoutEngineState;\n  private next = new Array<LayoutEngineCacheNode>();\n\n  constructor(state: LayoutEngineState) {\n    this.state = state;\n  }\n\n  /**\n   * The function takes path position and the callback to compute the corresponding state if not yet cached.\n   * It returns the next cache node to take the next path position if available:\n   *\n   * const root = new LayoutEngineCacheNode(state)\n   *\n   * const x1y0 = root\n   *    .matches({ x: 0, y: 0 }, () => compute({ x: 0, y: 0 })) // computes\n   *    .matches({ x: 1, y: 0 }, () => compute({ x: 1, y: 0 })) // computes\n   *    .state;\n   *\n   * const x2y0 = root\n   *    .matches({ x: 0, y: 0 }, () => compute({ x: 0, y: 0 }))\n   *    .matches({ x: 1, y: 0 }, () => compute({ x: 1, y: 0 }))\n   *    .matches({ x: 2, y: 0 }, () => compute({ x: 2, y: 0 })) // computes\n   *    .state;\n   */\n  matches(position: Position, compute: () => LayoutEngineState): LayoutEngineCacheNode {\n    for (const nextNode of this.next) {\n      if (nextNode.position!.x === position.x && nextNode.position!.y === position.y) {\n        return nextNode;\n      }\n    }\n\n    const nextNode = new LayoutEngineCacheNode(compute());\n    nextNode.position = position;\n    this.next.push(nextNode);\n\n    return nextNode;\n  }\n}\n"]}