{"version":3,"file":"engine-step.js","sourceRoot":"","sources":["../../../../src/internal/layout-engine/engine-step.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Position } from \"../utils/position\";\nimport { findNextSolutions, MoveSolution, MoveSolutionState } from \"./engine-solution\";\nimport { Conflicts, LayoutEngineState } from \"./engine-state\";\nimport { ReadonlyLayoutEngineGrid } from \"./grid\";\nimport { CommittedMove } from \"./interfaces\";\nimport { checkItemsIntersection, sortGridItems } from \"./utils\";\nimport { createMove } from \"./utils\";\n\n// The solutions can't be searched for infinitely in case the algorithm can't converge.\n// The safety counter ensures there is going to be user feedback within reasonable time.\nconst MAX_SOLUTION_DEPTH = 100;\n\n// At any given step only a few best solutions are taken to ensure faster convergence.\n// The larger the number the better chance the most optimal solution is found for the given priorities\n// at a cost of more computations made.\nconst NUM_BEST_SOLUTIONS = 5;\n\n/**\n * The function takes the current layout state (item placements from the previous steps and all moves done so far)\n * and a user command increment that describes an item transition by one cell in some direction.\n * The function finds overlapping elements and resolves all overlaps if possible (always possible when no conflicts).\n * The result in an updated state (new item placements, additional moves, and item conflicts if any).\n */\nexport function resolveOverlaps(layoutState: LayoutEngineState, userMove: CommittedMove): LayoutEngineState {\n  // For better UX the layout engine is optimized for item swaps.\n  // The swapping is only preferred for the user-controlled item and it can only happen when the item overlaps another\n  // item past its midpoint. When the overlap is not enough, the underlying item is considered a conflict and it is not\n  // allowed to move anywhere. The user command cannot be committed at this step.\n  const conflicts = findConflicts(layoutState.grid, layoutState.conflicts, userMove);\n\n  // The user moves are always applied as is. When the user-controlled item overlaps with other items and there is\n  // no conflict, the type=\"OVERLAP\" moves are performed to settle the grid so that no items overlap with one another.\n  // For this type of move multiple solutions are often available. To ensure the best result all solutions are tried\n  // and a score is given to each. The solution with the minimal score wins.\n  // The process stars from the initial state and the user move. The initial score and the user move score are 0.\n  const initialState = new MoveSolutionState(layoutState.grid, layoutState.moves, conflicts);\n  const initialSolution: MoveSolution = [initialState, userMove];\n\n  // All solutions are guaranteed to have unique move sequences but different move sequences can produce the same result.\n  // As it is never expected for one item to be moved over to the same location twice the combination of the item ID,\n  // item position, and solution score can uniquely represent the solution.\n  // For earlier moves taking a solution from the cache can prevent hundreds of subsequent computations.\n  const solutionsCache = new Map<string, MoveSolution>();\n  const createCacheKey = ([state, move]: MoveSolution) =>\n    `${move.itemId} ${move.x}:${move.y}:${state.score + move.score}`;\n\n  let moveSolutions: MoveSolution[] = [initialSolution];\n  let bestSolution: null | MoveSolutionState = null;\n  let convergenceCounter = MAX_SOLUTION_DEPTH;\n\n  // The resolution process continues until there is at least one reasonable solution left.\n  // The repetitive, dead-end, and expensive (compared to the best so far) solutions are excluded\n  // so that eventually no more variants to try remain.\n  // The convergence safety counter ensures the logical errors to not cause an infinite loop.\n  while (moveSolutions.length > 0) {\n    let nextSolutions: MoveSolution[] = [];\n\n    for (let solutionIndex = 0; solutionIndex < Math.min(NUM_BEST_SOLUTIONS, moveSolutions.length); solutionIndex++) {\n      const [solutionState, solutionMove] = moveSolutions[solutionIndex];\n\n      // Discard the solution before performing the move if its next score is already above the best score found so far.\n      if (bestSolution && solutionState.score + solutionMove.score >= bestSolution.score) {\n        continue;\n      }\n\n      // Perform the move by mutating the solution's state: grid, moves, score, etc.\n      makeMove(solutionState, solutionMove);\n\n      // If no overlaps are left the solution is considered valid and the best so far.\n      // The next solutions having the same or higher score will be discarded.\n      if (solutionState.overlaps.size === 0) {\n        bestSolution = solutionState;\n      }\n      // Otherwise, the next set of solutions will be considered. There can be up to four solutions per overlap\n      // (by the number of possible directions to move).\n      else {\n        for (const nextSolution of findNextSolutions(solutionState)) {\n          const solutionKey = createCacheKey(nextSolution);\n          const cachedSolution = solutionsCache.get(solutionKey);\n          if (!cachedSolution) {\n            nextSolutions.push(nextSolution);\n            solutionsCache.set(solutionKey, nextSolution);\n          }\n        }\n      }\n    }\n\n    // The solutions are ordered by the total score so that the best (so far) solutions are considered first.\n    moveSolutions = nextSolutions.sort((s1, s2) => s1[0].score + s1[1].score - (s2[0].score + s2[1].score));\n    nextSolutions = [];\n\n    // Reaching the convergence counter might indicate an issue with the algorithm as ideally it should converge faster.\n    // However, that does not necessarily mean the logical problem and no exception should be thrown.\n    // Instead, the current best solution if available applies or a simple solution is offered instead.\n    convergenceCounter--;\n    if (convergenceCounter <= 0) {\n      break;\n    }\n  }\n\n  // If there are conflicts it might not be possible to find a solution as the items are not allowed to\n  // overlap with the conflicts. In that case the initial state (with the user move applied) is returned.\n  // The user can move the item further to resolve the conflicts which will also unblock the overlaps resolution.\n  // Also, the solution might not be found due to the engine constraints. For example, the convergence number might\n  // be reached before any solution is found or the number of best solutions constraint can filter the only possible\n  // solutions away. In that case the simple solution is returned with all overlapping items pushed to the bottom.\n  if (!bestSolution) {\n    bestSolution = initialState.conflicts ? initialState : resolveOverlapsDown(initialState);\n  }\n\n  // After each step unless there are conflicts the type=\"FLOAT\" moves are performed on all items\n  // but the user controlled one that can be moved to the top without overlapping with other items.\n  return bestSolution.conflicts ? bestSolution : refloatGrid(bestSolution, userMove);\n}\n\n// Resolves overlaps the simple way by pushing all overlapping items to the bottom until none is left.\nfunction resolveOverlapsDown(state: MoveSolutionState): MoveSolutionState {\n  // Move overlapping items to the bottom until resolved. Repeat until no overlaps left.\n  // This solution always converges because there is always free space at the bottom by design.\n  while (state.overlaps.size > 0) {\n    const overlaps = sortGridItems([...state.overlaps].map(([overlapId]) => state.grid.getItem(overlapId)));\n    for (const overlap of overlaps) {\n      let y = overlap.y + 1;\n      while (state.grid.getOverlaps({ ...overlap, y }).length > 0) {\n        y++;\n      }\n      makeMove(state, createMove(\"OVERLAP\", overlap, new Position({ x: overlap.x, y })));\n    }\n  }\n  return state;\n}\n\n// Find items that can \"float\" to the top and apply the necessary moves.\nfunction refloatGrid(layoutState: LayoutEngineState, userMove?: CommittedMove): LayoutEngineState {\n  const state = new MoveSolutionState(layoutState.grid, layoutState.moves, layoutState.conflicts);\n\n  function makeRefloat() {\n    let needAnotherRefloat = false;\n\n    for (const item of state.grid.items) {\n      // The active item is skipped until the operation is committed.\n      if (item.id === userMove?.itemId) {\n        continue;\n      }\n\n      let y = item.y - 1;\n      let move: null | CommittedMove = null;\n      while (y >= 0) {\n        const moveAttempt = createMove(\"FLOAT\", item, new Position({ x: item.x, y }));\n        if (state.grid.getOverlaps({ id: item.id, ...moveAttempt }).length > 0) {\n          break;\n        }\n        y--;\n        move = moveAttempt;\n      }\n      if (move) {\n        makeMove(state, move);\n        needAnotherRefloat = true;\n      }\n    }\n\n    if (needAnotherRefloat) {\n      makeRefloat();\n    }\n  }\n\n  makeRefloat();\n\n  return state;\n}\n\n// Finds items that cannot be resolved at the current step as of being partially overlapped by the user-move item.\nfunction findConflicts(\n  grid: ReadonlyLayoutEngineGrid,\n  previousConflicts: null | Conflicts,\n  userMove: CommittedMove,\n): null | Conflicts {\n  // The conflicts are only defined for MOVE command type to make swaps possible.\n  if (userMove.type !== \"MOVE\") {\n    return null;\n  }\n  // Using existing conflict direction if available so that conflicting items would swap consistently.\n  // If only the current direction is considered the multi-item conflicts become difficult to comprehend.\n  const direction = previousConflicts?.direction ?? userMove.direction;\n  // Conflicts are partial overlaps. When the item is overlapped fully (considering the direction) it is\n  // no longer treated as conflict.\n  const overlaps = grid.getOverlaps({ ...userMove, id: userMove.itemId });\n  const conflicts = overlaps.filter((overlap) => {\n    switch (direction) {\n      case \"left\":\n        return overlap.x < userMove.x;\n      case \"right\":\n        return overlap.x + overlap.width - 1 > userMove.x + userMove.width - 1;\n      case \"up\":\n        return overlap.y < userMove.y;\n      case \"down\":\n        return overlap.y + overlap.height - 1 > userMove.y + userMove.height - 1;\n    }\n  });\n  if (conflicts.length > 0) {\n    return { direction, items: new Set(conflicts.map((item) => item.id)) };\n  }\n  return null;\n}\n\n// Applies given move to the solution state by updating the grid, moves, overlaps, and score.\nfunction makeMove(state: MoveSolutionState, nextMove: CommittedMove): void {\n  updateGridWithMove(state, nextMove);\n  updateOverlaps(state, nextMove);\n  state.moves.push(nextMove);\n  state.score += nextMove.score;\n}\n\nfunction updateGridWithMove({ grid }: MoveSolutionState, move: CommittedMove): void {\n  switch (move.type) {\n    case \"MOVE\":\n    case \"OVERLAP\":\n    case \"FLOAT\":\n      return grid.move(move.itemId, move.x, move.y);\n    case \"INSERT\":\n      return grid.insert({ id: move.itemId, ...move });\n    case \"REMOVE\":\n      return grid.remove(move.itemId);\n    case \"RESIZE\":\n      return grid.resize(move.itemId, move.width, move.height);\n  }\n}\n\nfunction updateOverlaps(state: MoveSolutionState, move: CommittedMove) {\n  // Find and assign items that will overlap with the moved item after the move is performed\n  // unless the overlapping items are considered as conflicts.\n  for (const newOverlap of state.grid.getOverlaps({ ...move, id: move.itemId })) {\n    if (!state.conflicts?.items.has(newOverlap.id)) {\n      state.overlaps.set(newOverlap.id, move.itemId);\n    }\n  }\n  // Remove no longer valid overlaps after the move is performed.\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    if (!checkItemsIntersection(state.grid.getItem(overlapId), state.grid.getItem(overlapIssuerId))) {\n      state.overlaps.delete(overlapId);\n    }\n  }\n}\n"]}