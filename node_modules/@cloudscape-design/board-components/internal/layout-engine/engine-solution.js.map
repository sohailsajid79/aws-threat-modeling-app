{"version":3,"file":"engine-solution.js","sourceRoot":"","sources":["../../../../src/internal/layout-engine/engine-solution.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Direction, GridLayoutItem, ItemId } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { Conflicts } from \"./engine-state\";\nimport { LayoutEngineGrid, ReadonlyLayoutEngineGrid } from \"./grid\";\nimport { CommittedMove } from \"./interfaces\";\nimport { checkOppositeDirections, createMove, getMoveOriginalRect, getMoveRect } from \"./utils\";\n\n// All directions in which overlaps can be incrementally resolved.\nconst PRIORITY_DIRECTIONS: readonly Direction[] = [\"down\", \"right\", \"left\", \"up\"];\n\n// A valid but not yet attempted solution is a pair of the layout state so far and the next move to attempt.\n// The minimal solution score (in case the next move will resolve all overlaps) is state.score + nextMove.score.\nexport type MoveSolution = [state: MoveSolutionState, nextMove: CommittedMove];\n\n// The class represents an intermediate layout state used to find the next set of solutions for.\n// The solution is terminal when no overlaps are left and it can become the next layout state if its\n// score is smaller than that of the alternative solutions.\nexport class MoveSolutionState {\n  public grid: LayoutEngineGrid;\n  public moves: CommittedMove[];\n  public moveIndex = 0;\n  public conflicts: null | Conflicts;\n  public overlaps = new Map<ItemId, ItemId>();\n  public score = 0;\n\n  constructor(grid: ReadonlyLayoutEngineGrid, moves: readonly CommittedMove[], conflicts: null | Conflicts) {\n    this.grid = LayoutEngineGrid.clone(grid);\n    this.moves = [...moves];\n    this.moveIndex = moves.length;\n    this.conflicts = conflicts;\n  }\n\n  // The solution state needs to be cloned after the move is performed in case there are overlaps left\n  // so that the next solutions won't have the shared state to corrupt.\n  // The conflicts never change and can be carried over w/o cloning.\n  static clone({ grid, moves, moveIndex, conflicts, overlaps, score }: MoveSolutionState) {\n    return {\n      grid: LayoutEngineGrid.clone(grid),\n      moves: [...moves],\n      moveIndex,\n      conflicts,\n      overlaps: new Map([...overlaps]),\n      score,\n    };\n  }\n}\n\n/**\n * Given a solution state finds a set of all possible moves each resolving a particular overlap.\n */\nexport function findNextSolutions(state: MoveSolutionState): MoveSolution[] {\n  // For every overlap and direction found a move if exists that resolves the overlap.\n  // A pair of the given state and the overlap resolution move is a new solution to try.\n  const nextMoveSolutions: MoveSolution[] = [];\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    for (const moveDirection of PRIORITY_DIRECTIONS) {\n      const move = getOverlapMove(state, overlapId, overlapIssuerId, moveDirection);\n      if (move !== null) {\n        nextMoveSolutions.push([MoveSolutionState.clone(state), move]);\n      }\n    }\n  }\n  return nextMoveSolutions;\n}\n\n// Returns an evaluated move to resolve the given overlap in the given direction or null if such move is not possible.\nfunction getOverlapMove(\n  state: MoveSolutionState,\n  overlapId: ItemId,\n  overlapIssuerId: ItemId,\n  moveDirection: Direction,\n): null | CommittedMove {\n  const userItem = state.grid.getItem(state.moves[0].itemId);\n  const overlapItem = state.grid.getItem(overlapId);\n  const overlapIssuerItem = state.grid.getItem(overlapIssuerId);\n  const overlapMove = getMoveForDirection(overlapItem, overlapIssuerItem, moveDirection);\n\n  // The move position is outside the grid boundaries.\n  if (overlapMove.x < 0 || overlapMove.y < 0 || overlapMove.x + overlapMove.width > state.grid.width) {\n    return null;\n  }\n\n  // Subsequent item overlap moves in the opposite directions do not contribute to solution.\n  const prevOverlapMove = getLastSolutionMove(state, overlapItem.id);\n  if (prevOverlapMove && checkOppositeDirections(prevOverlapMove.direction, moveDirection)) {\n    return null;\n  }\n\n  const pathOverlaps = getPathOverlaps(state, overlapMove, overlapIssuerItem);\n  for (const overlap of pathOverlaps) {\n    // Not allowed to intersect with the user-controlled item.\n    if (overlap.id === userItem.id) {\n      return null;\n    }\n    // Not allowed to intersect with conflicting items.\n    if (state.conflicts?.items.has(overlap.id)) {\n      return null;\n    }\n    // Intersecting with items having unresolved overlaps does not contribute to solution.\n    if (state.overlaps.has(overlap.id)) {\n      return null;\n    }\n  }\n\n  const lastIssuerMove = getLastSolutionMove(state, overlapIssuerItem.id);\n  if (!lastIssuerMove) {\n    throw new Error(\"Invariant violation: overlap issuer has no associated moves.\");\n  }\n  const issuerDirection = lastIssuerMove.direction;\n\n  const isSwap = checkIfSwap(overlapMove, lastIssuerMove);\n  const isDifferentIssuerDirection = moveDirection !== issuerDirection;\n  const isOppositeIssuerDirection = checkOppositeDirections(moveDirection, issuerDirection);\n  const userMoveBoundaries = getUserMoveBoundaries(state);\n  const moveVector = getSolutionMovesVector(state);\n\n  // Swap score penalizes non-swap overlap resolutions in case the direction does not match that of the issuer.\n  const swapPenalty = isSwap ? 0 : 20;\n  const differentDirectionPenalty = !isSwap && isDifferentIssuerDirection ? 10 : 0;\n  const oppositeDirectionPenalty = !isSwap && isOppositeIssuerDirection ? 500 : 0;\n  const swapScore = swapPenalty + differentDirectionPenalty + oppositeDirectionPenalty;\n\n  // Overlaps score penalizes moves that cause additional overlaps.\n  const overlapsScore = pathOverlaps.size * 50;\n\n  // Boundaries score penalize movements of items that are outside the area covered by the user move.\n  const moveOutsideUserTopPenalty = overlapItem.y + overlapItem.height - 1 < userMoveBoundaries.top ? 500 : 0;\n  const moveOutsideUserLeftPenalty = overlapItem.x + overlapItem.width - 1 < userMoveBoundaries.left ? 50 : 0;\n  const moveOutsideUserRightPenalty = overlapItem.x > userMoveBoundaries.right ? 50 : 0;\n  const boundariesScore = moveOutsideUserTopPenalty + moveOutsideUserLeftPenalty + moveOutsideUserRightPenalty;\n\n  // Move vector score penalize movements that are against the common move direction of other items.\n  const vectorXPenalty = overlapMove.distanceX * moveVector.x < 0 ? moveVector.x * 2 : 0;\n  const vectorYPenalty = overlapMove.distanceY * moveVector.y < 0 ? moveVector.y * 2 : 0;\n  const moveVectorScore = vectorXPenalty + vectorYPenalty;\n\n  // Score starts from 1 to avoid overlap moves having 0 score which breaks the solutions cache.\n  const score = 1 + swapScore + overlapsScore + moveVectorScore + boundariesScore;\n\n  return { ...overlapMove, score };\n}\n\n// Retrieves the first possible move for the given direction to resolve the overlap.\nfunction getMoveForDirection(moveTarget: GridLayoutItem, overlap: GridLayoutItem, direction: Direction): CommittedMove {\n  switch (direction) {\n    case \"up\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y - moveTarget.height }));\n    case \"down\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y + overlap.height }));\n    case \"left\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x - moveTarget.width, y: moveTarget.y }));\n    case \"right\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x + overlap.width, y: moveTarget.y }));\n  }\n}\n\n// Retrieves the last move if exists within the given solution.\nfunction getLastSolutionMove(state: MoveSolutionState, itemId: ItemId): null | CommittedMove {\n  let lastMove: null | CommittedMove = null;\n  for (let i = state.moves.length - 1; i >= state.moveIndex; i--) {\n    if (state.moves[i].itemId === itemId) {\n      lastMove = state.moves[i];\n      break;\n    }\n  }\n  return lastMove;\n}\n\n// Calculates vector as the amount of cell movements to either direction.\n// All moves in one direction are summarized, the opposite moves cancel each other.\n// The vector show in which direction (left / right, up / down) the most overlaps were resolved.\nfunction getSolutionMovesVector(state: MoveSolutionState): { x: number; y: number } {\n  const vector = { x: 0, y: 0 };\n  for (let i = state.moveIndex; i < state.moves.length; i++) {\n    const move = state.moves[i];\n    if (move.type === \"OVERLAP\") {\n      vector.x += move.distanceX * move.height;\n      vector.y += move.distanceY * move.width;\n    }\n  }\n  return vector;\n}\n\n// Finds a rectangle within which the user-controlled item was moved (previous and current positions only).\n// The layout items outside the boundaries are not expected to be disturbed.\nfunction getUserMoveBoundaries(state: MoveSolutionState): { top: number; right: number; bottom: number; left: number } {\n  const firstUserMove = state.moves[0];\n  const lastUserMove = state.moves[state.moveIndex];\n  if (!firstUserMove || !lastUserMove || firstUserMove.itemId !== lastUserMove.itemId) {\n    throw new Error(\"Invariant violation: unexpected user move.\");\n  }\n  const original = getMoveOriginalRect(lastUserMove);\n  const current = getMoveRect(lastUserMove);\n  return {\n    top: Math.min(original.top, current.top),\n    right: Math.max(original.right, current.right),\n    bottom: Math.max(original.bottom, current.bottom),\n    left: Math.min(original.left, current.left),\n  };\n}\n\n// Finds all overlaps that the move will cause along its path not considering the original location and original overlap.\nfunction getPathOverlaps(\n  state: MoveSolutionState,\n  move: CommittedMove,\n  overlapIssuerItem: GridLayoutItem,\n): Set<GridLayoutItem> {\n  const { left, right, top, bottom } = getMoveOriginalRect(move);\n  const startX = move.distanceX <= 0 ? move.x : right + 1;\n  const endX = move.distanceX < 0 ? left - 1 : right + move.distanceX;\n  const startY = move.distanceY <= 0 ? move.y : bottom + 1;\n  const endY = move.distanceY < 0 ? top - 1 : bottom + move.distanceY;\n\n  const pathOverlaps = new Set(\n    state.grid.getOverlaps({\n      id: move.itemId,\n      x: startX,\n      width: 1 + endX - startX,\n      y: startY,\n      height: 1 + endY - startY,\n    }),\n  );\n  pathOverlaps.delete(overlapIssuerItem);\n\n  return pathOverlaps;\n}\n\n// Checks if the overlap move is a swap with the user-moved item.\nfunction checkIfSwap(overlapMove: CommittedMove, lastIssuerMove: CommittedMove): boolean {\n  if (lastIssuerMove.type !== \"MOVE\") {\n    return false;\n  }\n  if (!checkOppositeDirections(overlapMove.direction, lastIssuerMove.direction)) {\n    return false;\n  }\n  const overlapRect = getMoveOriginalRect(overlapMove);\n  const issuerRect = getMoveRect(lastIssuerMove);\n  switch (lastIssuerMove.direction) {\n    case \"up\":\n      return overlapRect.top === issuerRect.top;\n    case \"right\":\n      return overlapRect.right === issuerRect.right;\n    case \"down\":\n      return overlapRect.bottom === issuerRect.bottom;\n    case \"left\":\n      return overlapRect.left === issuerRect.left;\n  }\n}\n"]}