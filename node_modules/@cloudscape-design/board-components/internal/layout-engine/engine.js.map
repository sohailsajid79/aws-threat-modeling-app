{"version":3,"file":"engine.js","sourceRoot":"","sources":["../../../../src/internal/layout-engine/engine.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { GridLayout, ItemId } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { InsertCommand, LayoutShift, MoveCommand, ResizeCommand } from \"./interfaces\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  private layout: GridLayout;\n  private cache: LayoutEngineCacheNode;\n\n  constructor(layout: GridLayout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n\n  move(moveCommand: MoveCommand, cache = this.cache): LayoutShift {\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({ ...moveCommand }, cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  resize(resizeCommand: ResizeCommand): LayoutShift {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({ x: width, y: height }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  insert({ itemId, width, height, path: [position, ...movePath] }: InsertCommand): LayoutShift {\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", { id: itemId, x: position.x, y: position.y, width, height }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n\n    return this.move({ itemId, path: movePath }, cache);\n  }\n\n  remove(itemId: ItemId): LayoutShift {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const { x, y, width, height } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", { id: itemId, x, y, width, height }, new Position({ x, y }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n\n  private getLayoutShift(state: LayoutEngineState): LayoutShift {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height,\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : [],\n    };\n  }\n\n  private validateMovePath({ itemId, path }: MoveCommand, state: LayoutEngineState): readonly Position[] {\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({ x: moveTarget.x, y: moveTarget.y }), path);\n  }\n\n  private validateResizePath({ itemId, path }: ResizeCommand, state: LayoutEngineState): readonly Position[] {\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({ x, y }), path);\n  }\n}\n"]}