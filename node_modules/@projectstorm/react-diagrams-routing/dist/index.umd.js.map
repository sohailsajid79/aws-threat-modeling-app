{"version":3,"file":"index.umd.js","mappings":"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","sources":["webpack://projectstorm/react-diagrams-routing/webpack/universalModuleDefinition","webpack://projectstorm/react-diagrams-routing/webpack/bootstrap","webpack://projectstorm/react-diagrams-routing/webpack/runtime/compat get default export","webpack://projectstorm/react-diagrams-routing/webpack/runtime/define property getters","webpack://projectstorm/react-diagrams-routing/webpack/runtime/hasOwnProperty shorthand","webpack://projectstorm/react-diagrams-routing/webpack/runtime/make namespace object","webpack://projectstorm/react-diagrams-routing/external commonjs \"react\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-defaults\"","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkModel.ts","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/first\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/last\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"pathfinding\"","webpack://projectstorm/react-diagrams-routing/./src/engine/PathFinding.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/cloneDeep\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/concat\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/defer\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/flatMap\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/get\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/minBy\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/maxBy\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/range\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/reduce\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/values\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"paths-js/path\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-canvas-core\"","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-core\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/geometry\"","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/external commonjs \"dagre\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/every\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/findIndex\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/forEach\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/map\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash/sortBy\"","webpack://projectstorm/react-diagrams-routing/./src/dagre/DagreEngine.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-diagrams-routing\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-diagrams-routing\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"react\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@projectstorm/react-diagrams-defaults\");","import { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\n\nexport class PathFindingLinkModel extends DefaultLinkModel {\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: PathFindingLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t}\n\n\tperformanceTune() {\n\t\treturn false;\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/first\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/last\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"pathfinding\");","import * as PF from 'pathfinding';\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport class PathFinding {\n\tinstance: any;\n\tfactory: PathFindingLinkFactory;\n\n\tconstructor(factory: PathFindingLinkFactory) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\n\t\tconst matrix = this.factory.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex((point) => {\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\telse return false;\n\t\t});\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex((point) => {\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\t\t\telse return false;\n\t\t\t\t});\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map((coords) => [\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n","import * as React from 'react';\nimport _first from 'lodash/first';\nimport _last from 'lodash/last';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFinding } from '../engine/PathFinding';\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\n\nexport interface PathFindingLinkWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: PathFindingLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: PathFindingLinkFactory;\n}\n\nexport interface PathFindingLinkWidgetState {\n\tselected: boolean;\n}\n\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\n\trefPaths: React.RefObject<SVGPathElement>[];\n\tpathFinding: PathFinding;\n\n\tconstructor(props: PathFindingLinkWidgetProps) {\n\t\tsuper(props);\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={{}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tthis.refPaths = [];\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.getPoints();\n\t\tvar paths = [];\n\n\t\t// first step: calculate a direct path between the points being linked\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_first(points), _last(points));\n\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t// so they can be used as origin and destination of the link to be created\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\t\tif (smartLink) {\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n\n\t\t\tpaths.push(\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\n\t\t\t);\n\t\t}\n\t\treturn <>{paths}</>;\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/cloneDeep\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/concat\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/defer\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/flatMap\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/get\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/minBy\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/maxBy\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/range\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/reduce\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/values\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"paths-js/path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@projectstorm/react-canvas-core\");","import * as React from 'react';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport _cloneDeep from 'lodash/cloneDeep';\nimport _concat from 'lodash/concat';\nimport _defer from 'lodash/defer';\nimport _flatMap from 'lodash/flatMap';\nimport _get from 'lodash/get';\nimport _minBy from 'lodash/minBy';\nimport _maxBy from 'lodash/maxBy';\nimport _range from 'lodash/range';\nimport _reduce from 'lodash/reduce';\nimport _values from 'lodash/values';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport {\n\tAbstractDisplacementState,\n\tAbstractFactory,\n\tAction,\n\tFactoryBank,\n\tInputType,\n\tListenerHandle\n} from '@projectstorm/react-canvas-core';\n\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\n\tROUTING_SCALING_FACTOR: number = 5;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tstatic NAME = 'pathfinding';\n\tlistener: ListenerHandle;\n\n\tconstructor() {\n\t\tsuper(PathFindingLinkFactory.NAME);\n\t}\n\n\tsetDiagramEngine(engine: DiagramEngine): void {\n\t\tsuper.setDiagramEngine(engine);\n\n\t\t// listen for drag changes\n\t\tengine.getStateMachine().registerListener({\n\t\t\tstateChanged: (event) => {\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\n\t\t\t\t\t\tnew Action<DiagramEngine>({\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\t\t\t\tfire: () => {\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t\t\t\t\tdeRegister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.listener = engine.registerListener({\n\t\t\tcanvasReady: () => {\n\t\t\t\t_defer(() => {\n\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\n\t\tsuper.setFactoryBank(bank);\n\t\tif (!bank && this.listener) {\n\t\t\tthis.listener.deregister();\n\t\t}\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n\n\tgenerateModel(event): PathFindingLinkModel {\n\t\treturn new PathFindingLinkModel();\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _values(this.engine.getModel().getNodes()).map((item) => ({\n\t\t\tx: item.getX(),\n\t\t\twidth: item.width,\n\t\t\ty: item.getY(),\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _values(this.engine.getModel().getLinks());\n\t\tconst allPortsCoords = _flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n\t\t\t.filter((port) => port !== null)\n\t\t\t.map((item) => ({\n\t\t\t\tx: item.getX(),\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.getY(),\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.getX(),\n\t\t\twidth: 0,\n\t\t\ty: item.getY(),\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst sumProps = (object, props) => _reduce(props, (acc, prop) => acc + _get(object, prop, 0), 0);\n\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\n\t\tconst concatedCoords = _concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\t\tconst minX =\n\t\t\tMath.floor(Math.min(_get(_minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n\t\t\tthis.ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\t\tconst minYCoords = _minBy(concatedCoords, 'y');\n\t\tconst minY =\n\t\t\tMath.floor(Math.min(_get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_values(this.engine.getModel().getNodes()).forEach((node) => {\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _flatMap(\n\t\t\t_values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\n\t\t);\n\t\tallElements\n\t\t\t.filter((port) => port !== null)\n\t\t\t.forEach((port) => {\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tgenerateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach((coords) => {\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@projectstorm/react-diagrams-core\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"@projectstorm/geometry\");","import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\nexport interface RightAngleLinkProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: RightAngleLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: RightAngleLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n\tselected: boolean;\n\tcanDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\n\tpublic static defaultProps: RightAngleLinkProps = {\n\t\tcolor: 'red',\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null,\n\t\tfactory: null\n\t};\n\n\trefPaths: React.RefObject<SVGPathElement>[];\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\tdragging_index: number;\n\n\tconstructor(props: RightAngleLinkProps) {\n\t\tsuper(props);\n\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false,\n\t\t\tcanDrag: false\n\t\t};\n\n\t\tthis.dragging_index = 0;\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={extraProps}\n\t\t\t/>\n\t\t);\n\t}\n\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n\t\t// If path is first or last add another point to keep node port on its position\n\t\tif (index === 0) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.dragging_index++;\n\t\t\treturn;\n\t\t} else if (index === points.length - 2) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Merge two points if it is not close to node port and close to each other\n\t\tif (index - 2 > 0) {\n\t\t\tlet _points = {\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tthis.dragging_index--;\n\t\t\t\tthis.dragging_index--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge two points if it is not close to node port\n\t\tif (index + 2 < points.length - 2) {\n\t\t\tlet _points = {\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index]: points[index].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index].setPosition(_points[index]);\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If no condition above handled then just update path points position\n\t\tlet _points = {\n\t\t\t[index]: points[index].getPosition(),\n\t\t\t[index + 1]: points[index + 1].getPosition()\n\t\t};\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\tpoints[index].setPosition(_points[index]);\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t}\n\n\tdraggingEvent(event: MouseEvent, index: number) {\n\t\tlet points = this.props.link.getPoints();\n\t\t// get moving difference. Index + 1 will work because links indexes has\n\t\t// length = points.lenght - 1\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n\t\t// moving with y direction\n\t\tif (dx === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'x');\n\t\t} else if (dy === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'y');\n\t\t}\n\t\tthis.props.link.setFirstAndLastPathsDirection();\n\t}\n\n\thandleMove = function (event: MouseEvent) {\n\t\tthis.draggingEvent(event, this.dragging_index);\n\t}.bind(this);\n\n\thandleUp = function (event: MouseEvent) {\n\t\t// Unregister handlers to avoid multiple event handlers for other links\n\t\tthis.setState({ canDrag: false, selected: false });\n\t\twindow.removeEventListener('mousemove', this.handleMove);\n\t\twindow.removeEventListener('mouseup', this.handleUp);\n\t}.bind(this);\n\n\trender() {\n\t\t//ensure id is present for all points on the path\n\t\tlet points = this.props.link.getPoints();\n\t\tlet paths = [];\n\n\t\t// Get points based on link orientation\n\t\tlet pointLeft = points[0];\n\t\tlet pointRight = points[points.length - 1];\n\t\tlet hadToSwitch = false;\n\t\tif (pointLeft.getX() > pointRight.getX()) {\n\t\t\tpointLeft = points[points.length - 1];\n\t\t\tpointRight = points[0];\n\t\t\thadToSwitch = true;\n\t\t}\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n\t\t// When new link add one middle point to get everywhere 90° angle\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\n\t\t\t[...Array(2)].forEach((item) => {\n\t\t\t\tthis.props.link.addPoint(\n\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t\t}),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t});\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n\t\t}\n\t\t// When new link is moving and not connected to target port move with middle point\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n\t\t\tpoints[1].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\n\t\t\t);\n\t\t\tpoints[2].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\n\t\t\t);\n\t\t}\n\t\t// Render was called but link is not moved but user.\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\n\t\t// For loop just for first and last path\n\t\telse if (!this.state.canDrag && points.length > 2) {\n\t\t\t// Those points and its position only will be moved\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\t\tif (i - 1 === 0) {\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If there is existing link which has two points add one\n\t\t// NOTE: It doesn't matter if check is for dy or dx\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n\t\t\tthis.props.link.addPoint(\n\t\t\t\tnew PointModel({\n\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tpaths.push(\n\t\t\t\tthis.generateLink(\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t{\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\n\t\t\t\t\t\t'data-point': j,\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\tif (event.button === 0) {\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\n\t\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tj\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n\t}\n}\n","import { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\nimport { DeserializeEvent } from '@projectstorm/react-canvas-core';\n\nexport class RightAngleLinkModel extends DefaultLinkModel {\n\tlastHoverIndexOfPath: number;\n\tprivate _lastPathXdirection: boolean;\n\tprivate _firstPathXdirection: boolean;\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: RightAngleLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t\tthis.lastHoverIndexOfPath = 0;\n\t\tthis._lastPathXdirection = false;\n\t\tthis._firstPathXdirection = false;\n\t}\n\n\tsetFirstAndLastPathsDirection() {\n\t\tlet points = this.getPoints();\n\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\tlet dx = Math.abs(points[i].getX() - points[i - 1].getX());\n\t\t\tlet dy = Math.abs(points[i].getY() - points[i - 1].getY());\n\t\t\tif (i - 1 === 0) {\n\t\t\t\tthis._firstPathXdirection = dx > dy;\n\t\t\t} else {\n\t\t\t\tthis._lastPathXdirection = dx > dy;\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-ignore\n\taddPoint<P extends PointModel>(pointModel: P, index: number = 1): P {\n\t\t// @ts-ignore\n\t\tsuper.addPoint(pointModel, index);\n\t\tthis.setFirstAndLastPathsDirection();\n\t\treturn pointModel;\n\t}\n\n\tdeserialize(event: DeserializeEvent<this>) {\n\t\tsuper.deserialize(event);\n\t\tthis.setFirstAndLastPathsDirection();\n\t}\n\n\tsetManuallyFirstAndLastPathsDirection(first, last) {\n\t\tthis._firstPathXdirection = first;\n\t\tthis._lastPathXdirection = last;\n\t}\n\n\tgetLastPathXdirection(): boolean {\n\t\treturn this._lastPathXdirection;\n\t}\n\tgetFirstPathXdirection(): boolean {\n\t\treturn this._firstPathXdirection;\n\t}\n\n\tsetWidth(width: number) {\n\t\tthis.options.width = width;\n\t\tthis.fireEvent({ width }, 'widthChanged');\n\t}\n\n\tsetColor(color: string) {\n\t\tthis.options.color = color;\n\t\tthis.fireEvent({ color }, 'colorChanged');\n\t}\n}\n","import * as React from 'react';\nimport { RightAngleLinkWidget } from './RightAngleLinkWidget';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\n/**\n * @author Daniel Lazar\n */\nexport class RightAngleLinkFactory extends DefaultLinkFactory<RightAngleLinkModel> {\n\tstatic NAME = 'rightAngle';\n\n\tconstructor() {\n\t\tsuper(RightAngleLinkFactory.NAME);\n\t}\n\n\tgenerateModel(event): RightAngleLinkModel {\n\t\treturn new RightAngleLinkModel();\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <RightAngleLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"dagre\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/every\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/findIndex\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/forEach\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/map\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"lodash/sortBy\");","import { DiagramModel, PointModel } from '@projectstorm/react-diagrams-core';\nimport * as dagre from 'dagre';\nimport { GraphLabel } from 'dagre';\nimport _every from 'lodash/every';\nimport _findIndex from 'lodash/findIndex';\nimport _forEach from 'lodash/forEach';\nimport _map from 'lodash/map';\nimport _range from 'lodash/range';\nimport _sortBy from 'lodash/sortBy';\nimport { Point } from '@projectstorm/geometry';\n\nexport interface DagreEngineOptions {\n\tgraph?: GraphLabel;\n\t/**\n\t * Will also re-layout links\n\t */\n\tincludeLinks?: boolean;\n\tnodeMargin?: number;\n}\n\nexport class DagreEngine {\n\toptions: DagreEngineOptions;\n\n\tconstructor(options: DagreEngineOptions = {}) {\n\t\tthis.options = options;\n\t}\n\n\tredistribute(model: DiagramModel) {\n\t\t// Create a new directed graph\n\t\tvar g = new dagre.graphlib.Graph({\n\t\t\tmultigraph: true,\n\t\t\tcompound: true\n\t\t});\n\t\tg.setGraph(this.options.graph || {});\n\t\tg.setDefaultEdgeLabel(function () {\n\t\t\treturn {};\n\t\t});\n\n\t\t// set nodes\n\t\t_forEach(model.getNodes(), (node) => {\n\t\t\tg.setNode(node.getID(), { width: node.width, height: node.height });\n\t\t});\n\n\t\t_forEach(model.getLinks(), (link) => {\n\t\t\t// set edges\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tg.setEdge({\n\t\t\t\t\tv: link.getSourcePort().getNode().getID(),\n\t\t\t\t\tw: link.getTargetPort().getNode().getID(),\n\t\t\t\t\tname: link.getID()\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// layout the graph\n\t\tdagre.layout(g);\n\n\t\tg.nodes().forEach((v) => {\n\t\t\tconst node = g.node(v);\n\t\t\tmodel.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n\t\t});\n\n\t\t// also include links?\n\t\tif (this.options.includeLinks) {\n\t\t\tg.edges().forEach((e) => {\n\t\t\t\tconst edge = g.edge(e);\n\t\t\t\tconst link = model.getLink(e.name);\n\n\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\tfor (let i = 1; i < edge.points.length - 1; i++) {\n\t\t\t\t\tpoints.push(new PointModel({ link: link, position: new Point(edge.points[i].x, edge.points[i].y) }));\n\t\t\t\t}\n\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * TODO cleanup this method into smaller methods\n\t */\n\tpublic refreshLinks(diagram: DiagramModel) {\n\t\tconst { nodeMargin } = this.options;\n\t\tconst nodes = diagram.getNodes();\n\t\tconst links = diagram.getLinks();\n\t\tlet maxChunkRowIndex = -1;\n\t\t// build the chunk matrix\n\t\tconst chunks: { [id: number]: { [id: number]: boolean } } = {}; // true: occupied, false: blank\n\t\tconst NodeXColumnIndexDictionary: { [id: number]: number } = {};\n\t\tlet verticalLines: number[] = [];\n\t\t_forEach(nodes, (node) => {\n\t\t\t// find vertical lines. vertical lines go through maximum number of nodes located under each other.\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\n\t\t\tif (\n\t\t\t\t_every(verticalLines, (vLine) => {\n\t\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) > nodeMargin;\n\t\t\t\t})\n\t\t\t) {\n\t\t\t\tverticalLines.push(nodeColumnCenter);\n\t\t\t}\n\t\t});\n\n\t\t// sort chunk columns\n\t\tverticalLines = verticalLines.sort((a, b) => a - b);\n\t\t_forEach(verticalLines, (line, index) => {\n\t\t\tchunks[index] = {};\n\t\t\tchunks[index + 0.5] = {};\n\t\t});\n\n\t\t// set occupied chunks\n\t\t_forEach(nodes, (node) => {\n\t\t\tconst nodeColumnCenter = node.getX() + node.width / 2;\n\t\t\tconst startChunkIndex = Math.floor(node.getY() / nodeMargin);\n\t\t\tconst endChunkIndex = Math.floor((node.getY() + node.height) / nodeMargin);\n\t\t\t// find max ChunkRowIndex\n\t\t\tif (endChunkIndex > maxChunkRowIndex) maxChunkRowIndex = endChunkIndex;\n\t\t\tconst nodeColumnIndex = _findIndex(verticalLines, (vLine) => {\n\t\t\t\treturn Math.abs(nodeColumnCenter - vLine) <= nodeMargin;\n\t\t\t});\n\t\t\t_forEach(_range(startChunkIndex, endChunkIndex + 1), (chunkIndex) => {\n\t\t\t\tchunks[nodeColumnIndex][chunkIndex] = true;\n\t\t\t});\n\t\t\tNodeXColumnIndexDictionary[node.getX()] = nodeColumnIndex;\n\t\t});\n\n\t\t// sort links based on their distances\n\t\tconst edges = _map(links, (link) => {\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tconst source = link.getSourcePort().getNode();\n\t\t\t\tconst target = link.getTargetPort().getNode();\n\t\t\t\tconst sourceIndex = NodeXColumnIndexDictionary[source.getX()];\n\t\t\t\tconst targetIndex = NodeXColumnIndexDictionary[target.getX()];\n\n\t\t\t\treturn sourceIndex > targetIndex\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tlink,\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tsourceY: source.getY() + source.height / 2,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttargetIndex,\n\t\t\t\t\t\t\ttargetY: target.getY() + source.height / 2,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t  }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tlink,\n\t\t\t\t\t\t\tsourceIndex: targetIndex,\n\t\t\t\t\t\t\tsourceY: target.getY() + target.height / 2,\n\t\t\t\t\t\t\tsource: target,\n\t\t\t\t\t\t\ttargetIndex: sourceIndex,\n\t\t\t\t\t\t\ttargetY: source.getY() + source.height / 2,\n\t\t\t\t\t\t\ttarget: source\n\t\t\t\t\t  };\n\t\t\t}\n\t\t});\n\t\tconst sortedEdges = _sortBy(edges, (link) => {\n\t\t\treturn Math.abs(link.targetIndex - link.sourceIndex);\n\t\t});\n\n\t\t// set link points\n\t\tif (this.options.includeLinks) {\n\t\t\t_forEach(sortedEdges, (edge) => {\n\t\t\t\tconst link = diagram.getLink(edge.link.getID());\n\t\t\t\t// re-draw\n\t\t\t\tif (Math.abs(edge.sourceIndex - edge.targetIndex) > 1) {\n\t\t\t\t\t// get the length of link in column\n\t\t\t\t\tconst columns = _range(edge.sourceIndex - 1, edge.targetIndex);\n\n\t\t\t\t\tconst chunkIndex = Math.floor(edge.sourceY / nodeMargin);\n\t\t\t\t\tconst targetChunkIndex = Math.floor(edge.targetY / nodeMargin);\n\n\t\t\t\t\t// check upper paths\n\t\t\t\t\tlet northCost = 1;\n\t\t\t\t\tlet aboveRowIndex = chunkIndex;\n\t\t\t\t\tfor (; aboveRowIndex >= 0; aboveRowIndex--, northCost++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t_every(columns, (columnIndex) => {\n\t\t\t\t\t\t\t\treturn !(\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][aboveRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][aboveRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][aboveRowIndex]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// check lower paths\n\t\t\t\t\tlet southCost = 0;\n\t\t\t\t\tlet belowRowIndex = chunkIndex;\n\t\t\t\t\tfor (; belowRowIndex <= maxChunkRowIndex; belowRowIndex++, southCost++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t_every(columns, (columnIndex) => {\n\t\t\t\t\t\t\t\treturn !(\n\t\t\t\t\t\t\t\t\tchunks[columnIndex][belowRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex + 0.5][belowRowIndex] ||\n\t\t\t\t\t\t\t\t\tchunks[columnIndex - 0.5][belowRowIndex]\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// pick the cheapest path\n\t\t\t\t\tconst pathRowIndex =\n\t\t\t\t\t\tsouthCost + (belowRowIndex - targetChunkIndex) < northCost + (targetChunkIndex - aboveRowIndex)\n\t\t\t\t\t\t\t? belowRowIndex + 1\n\t\t\t\t\t\t\t: aboveRowIndex - 1;\n\n\t\t\t\t\t// Finally update the link points\n\t\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\t\tpoints.push(\n\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\tposition: new Point(\n\t\t\t\t\t\t\t\t(verticalLines[columns[0]] + verticalLines[columns[0] + 1]) / 2,\n\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\n\t\t\t\t\t_forEach(columns, (column) => {\n\t\t\t\t\t\tpoints.push(\n\t\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\t\tposition: new Point(verticalLines[column], (pathRowIndex + 0.5) * nodeMargin)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tpoints.push(\n\t\t\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\t\t\tlink: link,\n\t\t\t\t\t\t\t\tposition: new Point(\n\t\t\t\t\t\t\t\t\t(verticalLines[column] + verticalLines[column - 1]) / 2,\n\t\t\t\t\t\t\t\t\t(pathRowIndex + 0.5) * nodeMargin\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunks[column][pathRowIndex] = true;\n\t\t\t\t\t\tchunks[column][pathRowIndex + 1] = true;\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex] = true;\n\t\t\t\t\t\tchunks[column + 0.5][pathRowIndex + 1] = true;\n\t\t\t\t\t});\n\t\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t\t} else {\n\t\t\t\t\t// refresh\n\t\t\t\t\tlink.setPoints([link.getFirstPoint(), link.getLastPoint()]);\n\t\t\t\t\tconst columnIndex = (edge.sourceIndex + edge.targetIndex) / 2;\n\t\t\t\t\tif (!chunks[columnIndex]) {\n\t\t\t\t\t\tchunks[columnIndex] = {};\n\t\t\t\t\t}\n\t\t\t\t\tconst rowIndex = Math.floor((edge.sourceY + edge.targetY) / 2 / nodeMargin);\n\t\t\t\t\tchunks[columnIndex][rowIndex] = true;\n\t\t\t\t\tchunks[columnIndex][rowIndex + 1] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","require","PathFindingLinkModel","DefaultLinkModel","constructor","options","super","type","PathFindingLinkFactory","NAME","performanceTune","pathFinderInstance","heuristic","manhattan","diagonalMovement","Never","PathFinding","this","instance","calculateDirectPath","from","to","matrix","getCanvasMatrix","grid","findPath","translateRoutingX","Math","floor","getX","ROUTING_SCALING_FACTOR","translateRoutingY","getY","calculateLinkStartEndCoords","path","startIndex","findIndex","point","endIndex","length","slice","reverse","pathToStart","pathToEnd","start","x","y","end","calculateDynamicPath","routingMatrix","dynamicPath","pathCoords","concat","map","coords","compressPath","PathFindingLinkWidget","props","refPaths","state","selected","pathFinding","componentDidUpdate","link","setRenderedPaths","ref","current","componentDidMount","componentWillUnmount","generateLink","id","push","DefaultLinkSegmentWidget","diagramEngine","getFactoryForLink","forwardRef","onSelection","setState","extras","render","points","getPoints","paths","directPathCoords","getRoutingMatrix","smartLink","simplifiedPath","generateDynamicPath","DefaultLinkFactory","canvasMatrix","hAdjustmentFactor","vAdjustmentFactor","calculateMatrixDimensions","allNodesCoords","engine","getModel","getNodes","item","width","height","allLinks","getLinks","allPortsCoords","getSourcePort","getTargetPort","filter","port","allPointsCoords","sumProps","object","acc","canvas","getCanvas","concatedCoords","minX","min","maxXElement","maxX","max","offsetWidth","minYCoords","minY","maxYElement","maxY","offsetHeight","ceil","abs","markNodes","forEach","node","startX","endX","startY","endY","markMatrixPoint","markPorts","undefined","setDiagramEngine","getStateMachine","registerListener","stateChanged","event","newState","AbstractDisplacementState","deRegister","getActionEventBus","registerAction","Action","InputType","MOUSE_UP","fire","calculateRoutingMatrix","repaintCanvas","listener","canvasReady","setFactoryBank","bank","deregister","generateReactWidget","model","generateModel","calculateCanvasMatrix","canvasWidth","canvasHeight","matrixWidth","matrixHeight","Array","fill","moveto","lineto","print","RightAngleLinkWidget","handleMove","draggingEvent","dragging_index","bind","handleUp","canDrag","window","removeEventListener","extraProps","calculatePositions","index","coordinate","PointModel","position","Point","addPoint","_points","getPosition","getRelativeMousePoint","setPosition","remove","dx","dy","setFirstAndLastPathsDirection","pointLeft","pointRight","hadToSwitch","setManuallyFirstAndLastPathsDirection","i","getFirstPathXdirection","getLastPathXdirection","j","LinkWidget","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","defaultProps","color","smooth","RightAngleLinkModel","RightAngleLinkFactory","_lastPathXdirection","_firstPathXdirection","pointModel","deserialize","first","last","setWidth","fireEvent","setColor","DagreEngine","redistribute","g","Graph","multigraph","compound","setGraph","graph","setDefaultEdgeLabel","setNode","setEdge","v","getNode","w","name","nodes","includeLinks","edges","e","edge","getLink","getFirstPoint","setPoints","getLastPoint","refreshLinks","diagram","nodeMargin","links","maxChunkRowIndex","chunks","NodeXColumnIndexDictionary","verticalLines","nodeColumnCenter","vLine","sort","b","line","startChunkIndex","endChunkIndex","nodeColumnIndex","chunkIndex","source","target","sourceIndex","targetIndex","sourceY","targetY","sortedEdges","columns","targetChunkIndex","northCost","aboveRowIndex","columnIndex","southCost","belowRowIndex","pathRowIndex","column","rowIndex"],"sourceRoot":""}