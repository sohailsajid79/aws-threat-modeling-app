"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackMappedCondition = exports.parseCondition = exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _toArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toArray"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _isEmpty = _interopRequireDefault(require("lodash/isEmpty"));

var _get = _interopRequireDefault(require("lodash/get"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

var isEmptyValue = function isEmptyValue(value) {
  if (value instanceof Date) {
    return isNaN(value.getTime());
  }

  return typeof value === 'number' || value === true ? false : (0, _isEmpty["default"])(value);
};

var fieldCondition = function fieldCondition(value, config) {
  if (config.isNotEmpty) {
    return !isEmptyValue(value);
  }

  if (config.isEmpty) {
    return isEmptyValue(value);
  }

  if (config.pattern) {
    var regExpPattern = RegExp(config.pattern, config.flags);
    return config.notMatch ? !regExpPattern.test(value) : regExpPattern.test(value);
  }

  if (typeof config.is === 'function') {
    return config.is(value, config);
  }

  if (Object.prototype.hasOwnProperty.call(config, 'greaterThan')) {
    return value > config.greaterThan;
  }

  if (Object.prototype.hasOwnProperty.call(config, 'greaterThanOrEqualTo')) {
    return value >= config.greaterThanOrEqualTo;
  }

  if (Object.prototype.hasOwnProperty.call(config, 'lessThan')) {
    return value < config.lessThan;
  }

  if (Object.prototype.hasOwnProperty.call(config, 'lessThanOrEqualTo')) {
    return value <= config.lessThanOrEqualTo;
  }

  var isMatched = Array.isArray(config.is) ? !!config.is.includes(value) : value === config.is;
  return config.notMatch ? !isMatched : isMatched;
};

var allowedMappedAttributes = ['when', 'is'];

var unpackMappedCondition = function unpackMappedCondition(condition, conditionMapper) {
  if ((0, _typeof2["default"])(condition.mappedAttributes) !== 'object') {
    return condition;
  }

  var mappedAttributes = condition.mappedAttributes;

  var internalCondition = _objectSpread(_objectSpread({}, condition), {}, {
    mappedAttributes: undefined
  });

  Object.entries(mappedAttributes).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray2["default"])(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (!allowedMappedAttributes.includes(key)) {
      console.error("Mapped condition attribute ".concat(key, " is not allowed! Allowed attributes are: ").concat(allowedMappedAttributes.join(', ')));
      return;
    }

    if (conditionMapper[value === null || value === void 0 ? void 0 : value[0]]) {
      var _value = (0, _toArray2["default"])(value),
          fnName = _value[0],
          args = _value.slice(1);

      var fn = conditionMapper[fnName];
      internalCondition[key] = fn.apply(void 0, (0, _toConsumableArray2["default"])(args));
    } else {
      console.error("Missing conditionMapper entry for ".concat(value, "!"));
    }
  });
  return internalCondition;
};

exports.unpackMappedCondition = unpackMappedCondition;

var parseCondition = function parseCondition(condition, values, field) {
  var conditionMapper = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  var positiveResult = _objectSpread(_objectSpread({
    visible: true
  }, condition.then), {}, {
    result: true
  });

  var negativeResult = _objectSpread(_objectSpread({
    visible: false
  }, condition["else"]), {}, {
    result: false
  });

  if (Array.isArray(condition)) {
    return !condition.map(function (condition) {
      return parseCondition(condition, values, field, conditionMapper);
    }).some(function (_ref3) {
      var result = _ref3.result;
      return result === false;
    }) ? positiveResult : negativeResult;
  }

  var conditionInternal = unpackMappedCondition(condition, conditionMapper);

  if (conditionInternal.and) {
    return !conditionInternal.and.map(function (condition) {
      return parseCondition(condition, values, field, conditionMapper);
    }).some(function (_ref4) {
      var result = _ref4.result;
      return result === false;
    }) ? positiveResult : negativeResult;
  }

  if (conditionInternal.sequence) {
    return conditionInternal.sequence.reduce(function (acc, curr) {
      var result = parseCondition(curr, values, field, conditionMapper);
      return {
        sets: [].concat((0, _toConsumableArray2["default"])(acc.sets), (0, _toConsumableArray2["default"])(result.set ? [result.set] : [])),
        visible: acc.visible || result.visible,
        result: acc.result || result.result
      };
    }, _objectSpread(_objectSpread({}, negativeResult), {}, {
      sets: []
    }));
  }

  if (conditionInternal.or) {
    return conditionInternal.or.map(function (condition) {
      return parseCondition(condition, values, field, conditionMapper);
    }).some(function (_ref5) {
      var result = _ref5.result;
      return result === true;
    }) ? positiveResult : negativeResult;
  }

  if (conditionInternal.not) {
    return !parseCondition(conditionInternal.not, values, field, conditionMapper).result ? positiveResult : negativeResult;
  }

  var finalWhen = typeof conditionInternal.when === 'function' ? conditionInternal.when(field) : conditionInternal.when;

  if (typeof finalWhen === 'string') {
    return fieldCondition((0, _get["default"])(values, finalWhen), conditionInternal) ? positiveResult : negativeResult;
  }

  if (Array.isArray(finalWhen)) {
    return finalWhen.map(function (fieldName) {
      return fieldCondition((0, _get["default"])(values, typeof fieldName === 'function' ? fieldName(field) : fieldName), conditionInternal);
    }).find(function (condition) {
      return !!condition;
    }) ? positiveResult : negativeResult;
  }

  return negativeResult;
};

exports.parseCondition = parseCondition;
var _default = parseCondition;
exports["default"] = _default;