{"version":3,"file":"index.umd.js","mappings":"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","sources":["webpack://projectstorm/react-diagrams-routing/webpack/universalModuleDefinition","webpack://projectstorm/react-diagrams-routing/./src/dagre/DagreEngine.ts","webpack://projectstorm/react-diagrams-routing/./src/engine/PathFinding.ts","webpack://projectstorm/react-diagrams-routing/./src/index.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/PathFindingLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkFactory.tsx","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkModel.ts","webpack://projectstorm/react-diagrams-routing/./src/link/RightAngleLinkWidget.tsx","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/geometry\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-canvas-core\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-core\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"@projectstorm/react-diagrams-defaults\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"dagre\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"lodash\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"pathfinding\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"paths-js/path\"","webpack://projectstorm/react-diagrams-routing/external commonjs \"react\"","webpack://projectstorm/react-diagrams-routing/webpack/bootstrap","webpack://projectstorm/react-diagrams-routing/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"projectstorm/react-diagrams-routing\"] = factory();\n\telse\n\t\troot[\"projectstorm/react-diagrams-routing\"] = factory();\n})(self, () => {\nreturn ","import { DiagramModel, PointModel } from '@projectstorm/react-diagrams-core';\nimport * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { GraphLabel } from 'dagre';\nimport { Point } from '@projectstorm/geometry';\n\nexport interface DagreEngineOptions {\n\tgraph?: GraphLabel;\n\t/**\n\t * Will also layout links\n\t */\n\tincludeLinks?: boolean;\n}\n\nexport class DagreEngine {\n\toptions: DagreEngineOptions;\n\n\tconstructor(options: DagreEngineOptions = {}) {\n\t\tthis.options = options;\n\t}\n\n\tredistribute(model: DiagramModel) {\n\t\t// Create a new directed graph\n\t\tvar g = new dagre.graphlib.Graph({\n\t\t\tmultigraph: true,\n\t\t\tcompound: true\n\t\t});\n\t\tg.setGraph(this.options.graph || {});\n\t\tg.setDefaultEdgeLabel(function () {\n\t\t\treturn {};\n\t\t});\n\n\t\t// set nodes\n\t\t_.forEach(model.getNodes(), (node) => {\n\t\t\tg.setNode(node.getID(), { width: node.width, height: node.height });\n\t\t});\n\n\t\t_.forEach(model.getLinks(), (link) => {\n\t\t\t// set edges\n\t\t\tif (link.getSourcePort() && link.getTargetPort()) {\n\t\t\t\tg.setEdge({\n\t\t\t\t\tv: link.getSourcePort().getNode().getID(),\n\t\t\t\t\tw: link.getTargetPort().getNode().getID(),\n\t\t\t\t\tname: link.getID()\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t// layout the graph\n\t\tdagre.layout(g);\n\n\t\tg.nodes().forEach((v) => {\n\t\t\tconst node = g.node(v);\n\t\t\tmodel.getNode(v).setPosition(node.x - node.width / 2, node.y - node.height / 2);\n\t\t});\n\n\t\t// also include links?\n\t\tif (this.options.includeLinks) {\n\t\t\tg.edges().forEach((e) => {\n\t\t\t\tconst edge = g.edge(e);\n\t\t\t\tconst link = model.getLink(e.name);\n\n\t\t\t\tconst points = [link.getFirstPoint()];\n\t\t\t\tfor (let i = 1; i < edge.points.length - 1; i++) {\n\t\t\t\t\tpoints.push(new PointModel({ link: link, position: new Point(edge.points[i].x, edge.points[i].y) }));\n\t\t\t\t}\n\t\t\t\tlink.setPoints(points.concat(link.getLastPoint()));\n\t\t\t});\n\t\t}\n\t}\n}\n","import * as PF from 'pathfinding';\nimport { PathFindingLinkFactory } from '../link/PathFindingLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\n\n/*\nit can be very expensive to calculate routes when every single pixel on the canvas\nis individually represented. Using the factor below, we combine values in order\nto achieve the best trade-off between accuracy and performance.\n*/\n\nconst pathFinderInstance = new PF.JumpPointFinder({\n\theuristic: PF.Heuristic.manhattan,\n\tdiagonalMovement: PF.DiagonalMovement.Never\n});\n\nexport class PathFinding {\n\tinstance: any;\n\tfactory: PathFindingLinkFactory;\n\n\tconstructor(factory: PathFindingLinkFactory) {\n\t\tthis.instance = pathFinderInstance;\n\t\tthis.factory = factory;\n\t}\n\n\t/**\n\t * Taking as argument a fully unblocked walking matrix, this method\n\t * finds a direct path from point A to B.\n\t */\n\tcalculateDirectPath(from: PointModel, to: PointModel): number[][] {\n\t\tconst matrix = this.factory.getCanvasMatrix();\n\t\tconst grid = new PF.Grid(matrix);\n\n\t\treturn pathFinderInstance.findPath(\n\t\t\tthis.factory.translateRoutingX(Math.floor(from.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(from.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingX(Math.floor(to.getX() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tthis.factory.translateRoutingY(Math.floor(to.getY() / this.factory.ROUTING_SCALING_FACTOR)),\n\t\t\tgrid\n\t\t);\n\t}\n\n\t/**\n\t * Using @link{#calculateDirectPath}'s result as input, we here\n\t * determine the first walkable point found in the matrix that includes\n\t * blocked paths.\n\t */\n\tcalculateLinkStartEndCoords(\n\t\tmatrix: number[][],\n\t\tpath: number[][]\n\t): {\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t};\n\t\tpathToStart: number[][];\n\t\tpathToEnd: number[][];\n\t} {\n\t\tconst startIndex = path.findIndex((point) => {\n\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\telse return false;\n\t\t});\n\t\tconst endIndex =\n\t\t\tpath.length -\n\t\t\t1 -\n\t\t\tpath\n\t\t\t\t.slice()\n\t\t\t\t.reverse()\n\t\t\t\t.findIndex((point) => {\n\t\t\t\t\tif (matrix[point[1]]) return matrix[point[1]][point[0]] === 0;\n\t\t\t\t\telse return false;\n\t\t\t\t});\n\n\t\t// are we trying to create a path exclusively through blocked areas?\n\t\t// if so, let's fallback to the linear routing\n\t\tif (startIndex === -1 || endIndex === -1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst pathToStart = path.slice(0, startIndex);\n\t\tconst pathToEnd = path.slice(endIndex);\n\n\t\treturn {\n\t\t\tstart: {\n\t\t\t\tx: path[startIndex][0],\n\t\t\t\ty: path[startIndex][1]\n\t\t\t},\n\t\t\tend: {\n\t\t\t\tx: path[endIndex][0],\n\t\t\t\ty: path[endIndex][1]\n\t\t\t},\n\t\t\tpathToStart,\n\t\t\tpathToEnd\n\t\t};\n\t}\n\n\t/**\n\t * Puts everything together: merges the paths from/to the centre of the ports,\n\t * with the path calculated around other elements.\n\t */\n\tcalculateDynamicPath(\n\t\troutingMatrix: number[][],\n\t\tstart: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tend: {\n\t\t\tx: number;\n\t\t\ty: number;\n\t\t},\n\t\tpathToStart: number[][],\n\t\tpathToEnd: number[][]\n\t) {\n\t\t// generate the path based on the matrix with obstacles\n\t\tconst grid = new PF.Grid(routingMatrix);\n\t\tconst dynamicPath = pathFinderInstance.findPath(start.x, start.y, end.x, end.y, grid);\n\n\t\t// aggregate everything to have the calculated path ready for rendering\n\t\tconst pathCoords = pathToStart\n\t\t\t.concat(dynamicPath, pathToEnd)\n\t\t\t.map((coords) => [\n\t\t\t\tthis.factory.translateRoutingX(coords[0], true),\n\t\t\t\tthis.factory.translateRoutingY(coords[1], true)\n\t\t\t]);\n\t\treturn PF.Util.compressPath(pathCoords);\n\t}\n}\n","export * from './link/PathFindingLinkFactory';\nexport * from './link/PathFindingLinkModel';\nexport * from './link/PathFindingLinkWidget';\nexport * from './link/RightAngleLinkWidget';\nexport * from './link/RightAngleLinkFactory';\nexport * from './link/RightAngleLinkModel';\n\nexport * from './engine/PathFinding';\nexport * from './dagre/DagreEngine';\n","import * as React from 'react';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { PathFindingLinkWidget } from './PathFindingLinkWidget';\nimport * as _ from 'lodash';\nimport * as Path from 'paths-js/path';\nimport { DefaultLinkFactory } from '@projectstorm/react-diagrams-defaults';\nimport {\n\tAbstractDisplacementState,\n\tAbstractFactory,\n\tAction,\n\tFactoryBank,\n\tInputType,\n\tListenerHandle\n} from '@projectstorm/react-canvas-core';\n\nexport class PathFindingLinkFactory extends DefaultLinkFactory<PathFindingLinkModel> {\n\tROUTING_SCALING_FACTOR: number = 5;\n\n\t// calculated only when smart routing is active\n\tcanvasMatrix: number[][] = [];\n\troutingMatrix: number[][] = [];\n\n\t// used when at least one element has negative coordinates\n\thAdjustmentFactor: number = 0;\n\tvAdjustmentFactor: number = 0;\n\n\tstatic NAME = 'pathfinding';\n\tlistener: ListenerHandle;\n\n\tconstructor() {\n\t\tsuper(PathFindingLinkFactory.NAME);\n\t}\n\n\tsetDiagramEngine(engine: DiagramEngine): void {\n\t\tsuper.setDiagramEngine(engine);\n\n\t\t// listen for drag changes\n\t\tengine.getStateMachine().registerListener({\n\t\t\tstateChanged: (event) => {\n\t\t\t\tif (event.newState instanceof AbstractDisplacementState) {\n\t\t\t\t\tconst deRegister = engine.getActionEventBus().registerAction(\n\t\t\t\t\t\tnew Action<DiagramEngine>({\n\t\t\t\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\t\t\t\tfire: () => {\n\t\t\t\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t\t\t\t\tdeRegister();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.listener = engine.registerListener({\n\t\t\tcanvasReady: () => {\n\t\t\t\t_.defer(() => {\n\t\t\t\t\tthis.calculateRoutingMatrix();\n\t\t\t\t\tengine.repaintCanvas();\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tsetFactoryBank(bank: FactoryBank<AbstractFactory>): void {\n\t\tsuper.setFactoryBank(bank);\n\t\tif (!bank && this.listener) {\n\t\t\tthis.listener.deregister();\n\t\t}\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <PathFindingLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n\n\tgenerateModel(event): PathFindingLinkModel {\n\t\treturn new PathFindingLinkModel();\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * | 0 0 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all walkable points are marked by zeros.\n\t * It uses @link{#ROUTING_SCALING_FACTOR} to reduce the matrix dimensions and improve performance.\n\t */\n\tgetCanvasMatrix(): number[][] {\n\t\tif (this.canvasMatrix.length === 0) {\n\t\t\tthis.calculateCanvasMatrix();\n\t\t}\n\n\t\treturn this.canvasMatrix;\n\t}\n\tcalculateCanvasMatrix() {\n\t\tconst {\n\t\t\twidth: canvasWidth,\n\t\t\thAdjustmentFactor,\n\t\t\theight: canvasHeight,\n\t\t\tvAdjustmentFactor\n\t\t} = this.calculateMatrixDimensions();\n\n\t\tthis.hAdjustmentFactor = hAdjustmentFactor;\n\t\tthis.vAdjustmentFactor = vAdjustmentFactor;\n\n\t\tconst matrixWidth = Math.ceil(canvasWidth / this.ROUTING_SCALING_FACTOR);\n\t\tconst matrixHeight = Math.ceil(canvasHeight / this.ROUTING_SCALING_FACTOR);\n\n\t\tthis.canvasMatrix = _.range(0, matrixHeight).map(() => {\n\t\t\treturn new Array(matrixWidth).fill(0);\n\t\t});\n\t}\n\n\t/**\n\t * A representation of the canvas in the following format:\n\t *\n\t * +-----------------+\n\t * | 0 0 1 1 0 0 0 0 |\n\t * | 0 0 1 1 0 0 1 1 |\n\t * | 0 0 0 0 0 0 1 1 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * | 1 1 0 0 0 0 0 0 |\n\t * +-----------------+\n\t *\n\t * In which all points blocked by a node (and its ports) are\n\t * marked as 1; points were there is nothing (ie, free) receive 0.\n\t */\n\tgetRoutingMatrix(): number[][] {\n\t\tif (this.routingMatrix.length === 0) {\n\t\t\tthis.calculateRoutingMatrix();\n\t\t}\n\n\t\treturn this.routingMatrix;\n\t}\n\tcalculateRoutingMatrix(): void {\n\t\tconst matrix = _.cloneDeep(this.getCanvasMatrix());\n\n\t\t// nodes need to be marked as blocked points\n\t\tthis.markNodes(matrix);\n\t\t// same thing for ports\n\t\tthis.markPorts(matrix);\n\n\t\tthis.routingMatrix = matrix;\n\t}\n\n\t/**\n\t * The routing matrix does not have negative indexes, but elements could be negatively positioned.\n\t * We use the functions below to translate back and forth between these coordinates, relying on the\n\t * calculated values of hAdjustmentFactor and vAdjustmentFactor.\n\t */\n\ttranslateRoutingX(x: number, reverse: boolean = false) {\n\t\treturn x + this.hAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\ttranslateRoutingY(y: number, reverse: boolean = false) {\n\t\treturn y + this.vAdjustmentFactor * (reverse ? -1 : 1);\n\t}\n\n\t/**\n\t * Despite being a long method, we simply iterate over all three collections (nodes, ports and points)\n\t * to find the highest X and Y dimensions, so we can build the matrix large enough to contain all elements.\n\t */\n\tcalculateMatrixDimensions = (): {\n\t\twidth: number;\n\t\thAdjustmentFactor: number;\n\t\theight: number;\n\t\tvAdjustmentFactor: number;\n\t} => {\n\t\tconst allNodesCoords = _.values(this.engine.getModel().getNodes()).map((item) => ({\n\t\t\tx: item.getX(),\n\t\t\twidth: item.width,\n\t\t\ty: item.getY(),\n\t\t\theight: item.height\n\t\t}));\n\n\t\tconst allLinks = _.values(this.engine.getModel().getLinks());\n\t\tconst allPortsCoords = _.flatMap(allLinks.map((link) => [link.getSourcePort(), link.getTargetPort()]))\n\t\t\t.filter((port) => port !== null)\n\t\t\t.map((item) => ({\n\t\t\t\tx: item.getX(),\n\t\t\t\twidth: item.width,\n\t\t\t\ty: item.getY(),\n\t\t\t\theight: item.height\n\t\t\t}));\n\t\tconst allPointsCoords = _.flatMap(allLinks.map((link) => link.getPoints())).map((item) => ({\n\t\t\t// points don't have width/height, so let's just use 0\n\t\t\tx: item.getX(),\n\t\t\twidth: 0,\n\t\t\ty: item.getY(),\n\t\t\theight: 0\n\t\t}));\n\n\t\tconst sumProps = (object, props) => _.reduce(props, (acc, prop) => acc + _.get(object, prop, 0), 0);\n\n\t\tconst canvas = this.engine.getCanvas() as HTMLDivElement;\n\t\tconst concatedCoords = _.concat(allNodesCoords, allPortsCoords, allPointsCoords);\n\t\tconst minX =\n\t\t\tMath.floor(Math.min(_.get(_.minBy(concatedCoords, 'x'), 'x', 0), 0) / this.ROUTING_SCALING_FACTOR) *\n\t\t\tthis.ROUTING_SCALING_FACTOR;\n\t\tconst maxXElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['x', 'width']));\n\t\tconst maxX = Math.max(sumProps(maxXElement, ['x', 'width']), canvas.offsetWidth);\n\t\tconst minYCoords = _.minBy(concatedCoords, 'y');\n\t\tconst minY =\n\t\t\tMath.floor(Math.min(_.get(minYCoords, 'y', 0), 0) / this.ROUTING_SCALING_FACTOR) * this.ROUTING_SCALING_FACTOR;\n\t\tconst maxYElement = _.maxBy(concatedCoords, (item) => sumProps(item, ['y', 'height']));\n\t\tconst maxY = Math.max(sumProps(maxYElement, ['y', 'height']), canvas.offsetHeight);\n\n\t\treturn {\n\t\t\twidth: Math.ceil(Math.abs(minX) + maxX),\n\t\t\thAdjustmentFactor: Math.abs(minX) / this.ROUTING_SCALING_FACTOR + 1,\n\t\t\theight: Math.ceil(Math.abs(minY) + maxY),\n\t\t\tvAdjustmentFactor: Math.abs(minY) / this.ROUTING_SCALING_FACTOR + 1\n\t\t};\n\t};\n\n\t/**\n\t * Updates (by reference) where nodes will be drawn on the matrix passed in.\n\t */\n\tmarkNodes = (matrix: number[][]): void => {\n\t\t_.values(this.engine.getModel().getNodes()).forEach((node) => {\n\t\t\tconst startX = Math.floor(node.getX() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endX = Math.ceil((node.getX() + node.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst startY = Math.floor(node.getY() / this.ROUTING_SCALING_FACTOR);\n\t\t\tconst endY = Math.ceil((node.getY() + node.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Updates (by reference) where ports will be drawn on the matrix passed in.\n\t */\n\tmarkPorts = (matrix: number[][]): void => {\n\t\tconst allElements = _.flatMap(\n\t\t\t_.values(this.engine.getModel().getLinks()).map((link) => [].concat(link.getSourcePort(), link.getTargetPort()))\n\t\t);\n\t\tallElements\n\t\t\t.filter((port) => port !== null)\n\t\t\t.forEach((port) => {\n\t\t\t\tconst startX = Math.floor(port.x / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endX = Math.ceil((port.x + port.width) / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst startY = Math.floor(port.y / this.ROUTING_SCALING_FACTOR);\n\t\t\t\tconst endY = Math.ceil((port.y + port.height) / this.ROUTING_SCALING_FACTOR);\n\n\t\t\t\tfor (let x = startX - 1; x <= endX + 1; x++) {\n\t\t\t\t\tfor (let y = startY - 1; y < endY + 1; y++) {\n\t\t\t\t\t\tthis.markMatrixPoint(matrix, this.translateRoutingX(x), this.translateRoutingY(y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\tmarkMatrixPoint = (matrix: number[][], x: number, y: number) => {\n\t\tif (matrix[y] !== undefined && matrix[y][x] !== undefined) {\n\t\t\tmatrix[y][x] = 1;\n\t\t}\n\t};\n\n\tgenerateDynamicPath(pathCoords: number[][]) {\n\t\tlet path = Path();\n\t\tpath = path.moveto(pathCoords[0][0] * this.ROUTING_SCALING_FACTOR, pathCoords[0][1] * this.ROUTING_SCALING_FACTOR);\n\t\tpathCoords.slice(1).forEach((coords) => {\n\t\t\tpath = path.lineto(coords[0] * this.ROUTING_SCALING_FACTOR, coords[1] * this.ROUTING_SCALING_FACTOR);\n\t\t});\n\t\treturn path.print();\n\t}\n}\n","import { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\n\nexport class PathFindingLinkModel extends DefaultLinkModel {\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: PathFindingLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t}\n\n\tperformanceTune() {\n\t\treturn false;\n\t}\n}\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { PathFinding } from '../engine/PathFinding';\nimport { PathFindingLinkFactory } from './PathFindingLinkFactory';\nimport { PathFindingLinkModel } from './PathFindingLinkModel';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\n\nexport interface PathFindingLinkWidgetProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: PathFindingLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: PathFindingLinkFactory;\n}\n\nexport interface PathFindingLinkWidgetState {\n\tselected: boolean;\n}\n\nexport class PathFindingLinkWidget extends React.Component<PathFindingLinkWidgetProps, PathFindingLinkWidgetState> {\n\trefPaths: React.RefObject<SVGPathElement>[];\n\tpathFinding: PathFinding;\n\n\tconstructor(props: PathFindingLinkWidgetProps) {\n\t\tsuper(props);\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false\n\t\t};\n\t\tthis.pathFinding = new PathFinding(this.props.factory);\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={{}}\n\t\t\t/>\n\t\t);\n\t}\n\n\trender() {\n\t\tthis.refPaths = [];\n\t\t//ensure id is present for all points on the path\n\t\tvar points = this.props.link.getPoints();\n\t\tvar paths = [];\n\n\t\t// first step: calculate a direct path between the points being linked\n\t\tconst directPathCoords = this.pathFinding.calculateDirectPath(_.first(points), _.last(points));\n\n\t\tconst routingMatrix = this.props.factory.getRoutingMatrix();\n\t\t// now we need to extract, from the routing matrix, the very first walkable points\n\t\t// so they can be used as origin and destination of the link to be created\n\t\tconst smartLink = this.pathFinding.calculateLinkStartEndCoords(routingMatrix, directPathCoords);\n\t\tif (smartLink) {\n\t\t\tconst { start, end, pathToStart, pathToEnd } = smartLink;\n\n\t\t\t// second step: calculate a path avoiding hitting other elements\n\t\t\tconst simplifiedPath = this.pathFinding.calculateDynamicPath(routingMatrix, start, end, pathToStart, pathToEnd);\n\n\t\t\tpaths.push(\n\t\t\t\t//smooth: boolean, extraProps: any, id: string | number, firstPoint: PointModel, lastPoint: PointModel\n\t\t\t\tthis.generateLink(this.props.factory.generateDynamicPath(simplifiedPath), '0')\n\t\t\t);\n\t\t}\n\t\treturn <>{paths}</>;\n\t}\n}\n","import * as React from 'react';\nimport { RightAngleLinkWidget } from './RightAngleLinkWidget';\nimport { DiagramEngine } from '@projectstorm/react-diagrams-core';\nimport { DefaultLinkFactory, DefaultLinkModel } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\n/**\n * @author Daniel Lazar\n */\nexport class RightAngleLinkFactory extends DefaultLinkFactory<RightAngleLinkModel> {\n\tstatic NAME = 'rightAngle';\n\n\tconstructor() {\n\t\tsuper(RightAngleLinkFactory.NAME);\n\t}\n\n\tgenerateModel(event): RightAngleLinkModel {\n\t\treturn new RightAngleLinkModel();\n\t}\n\n\tgenerateReactWidget(event): JSX.Element {\n\t\treturn <RightAngleLinkWidget diagramEngine={this.engine} link={event.model} factory={this} />;\n\t}\n}\n","import { DefaultLinkModel, DefaultLinkModelOptions } from '@projectstorm/react-diagrams-defaults';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { PointModel } from '@projectstorm/react-diagrams-core';\nimport { DeserializeEvent } from '@projectstorm/react-canvas-core';\n\nexport class RightAngleLinkModel extends DefaultLinkModel {\n\tlastHoverIndexOfPath: number;\n\tprivate _lastPathXdirection: boolean;\n\tprivate _firstPathXdirection: boolean;\n\tconstructor(options: DefaultLinkModelOptions = {}) {\n\t\tsuper({\n\t\t\ttype: RightAngleLinkFactory.NAME,\n\t\t\t...options\n\t\t});\n\t\tthis.lastHoverIndexOfPath = 0;\n\t\tthis._lastPathXdirection = false;\n\t\tthis._firstPathXdirection = false;\n\t}\n\n\tsetFirstAndLastPathsDirection() {\n\t\tlet points = this.getPoints();\n\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\tlet dx = Math.abs(points[i].getX() - points[i - 1].getX());\n\t\t\tlet dy = Math.abs(points[i].getY() - points[i - 1].getY());\n\t\t\tif (i - 1 === 0) {\n\t\t\t\tthis._firstPathXdirection = dx > dy;\n\t\t\t} else {\n\t\t\t\tthis._lastPathXdirection = dx > dy;\n\t\t\t}\n\t\t}\n\t}\n\n\t// @ts-ignore\n\taddPoint<P extends PointModel>(pointModel: P, index: number = 1): P {\n\t\t// @ts-ignore\n\t\tsuper.addPoint(pointModel, index);\n\t\tthis.setFirstAndLastPathsDirection();\n\t\treturn pointModel;\n\t}\n\n\tdeserialize(event: DeserializeEvent<this>) {\n\t\tsuper.deserialize(event);\n\t\tthis.setFirstAndLastPathsDirection();\n\t}\n\n\tsetManuallyFirstAndLastPathsDirection(first, last) {\n\t\tthis._firstPathXdirection = first;\n\t\tthis._lastPathXdirection = last;\n\t}\n\n\tgetLastPathXdirection(): boolean {\n\t\treturn this._lastPathXdirection;\n\t}\n\tgetFirstPathXdirection(): boolean {\n\t\treturn this._firstPathXdirection;\n\t}\n\n\tsetWidth(width: number) {\n\t\tthis.options.width = width;\n\t\tthis.fireEvent({ width }, 'widthChanged');\n\t}\n\n\tsetColor(color: string) {\n\t\tthis.options.color = color;\n\t\tthis.fireEvent({ color }, 'colorChanged');\n\t}\n}\n","import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { RightAngleLinkFactory } from './RightAngleLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { RightAngleLinkModel } from './RightAngleLinkModel';\n\nexport interface RightAngleLinkProps {\n\tcolor?: string;\n\twidth?: number;\n\tsmooth?: boolean;\n\tlink: RightAngleLinkModel;\n\tdiagramEngine: DiagramEngine;\n\tfactory: RightAngleLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n\tselected: boolean;\n\tcanDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<RightAngleLinkProps, RightAngleLinkState> {\n\tpublic static defaultProps: RightAngleLinkProps = {\n\t\tcolor: 'red',\n\t\twidth: 3,\n\t\tlink: null,\n\t\tsmooth: false,\n\t\tdiagramEngine: null,\n\t\tfactory: null\n\t};\n\n\trefPaths: React.RefObject<SVGPathElement>[];\n\n\t// DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n\trefLabels: { [id: string]: HTMLElement };\n\tdragging_index: number;\n\n\tconstructor(props: RightAngleLinkProps) {\n\t\tsuper(props);\n\n\t\tthis.refPaths = [];\n\t\tthis.state = {\n\t\t\tselected: false,\n\t\t\tcanDrag: false\n\t\t};\n\n\t\tthis.dragging_index = 0;\n\t}\n\n\tcomponentDidUpdate(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentDidMount(): void {\n\t\tthis.props.link.setRenderedPaths(\n\t\t\tthis.refPaths.map((ref) => {\n\t\t\t\treturn ref.current;\n\t\t\t})\n\t\t);\n\t}\n\n\tcomponentWillUnmount(): void {\n\t\tthis.props.link.setRenderedPaths([]);\n\t}\n\n\tgenerateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n\t\tconst ref = React.createRef<SVGPathElement>();\n\t\tthis.refPaths.push(ref);\n\t\treturn (\n\t\t\t<DefaultLinkSegmentWidget\n\t\t\t\tkey={`link-${id}`}\n\t\t\t\tpath={path}\n\t\t\t\tselected={this.state.selected}\n\t\t\t\tdiagramEngine={this.props.diagramEngine}\n\t\t\t\tfactory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n\t\t\t\tlink={this.props.link}\n\t\t\t\tforwardRef={ref}\n\t\t\t\tonSelection={(selected) => {\n\t\t\t\t\tthis.setState({ selected: selected });\n\t\t\t\t}}\n\t\t\t\textras={extraProps}\n\t\t\t/>\n\t\t);\n\t}\n\n\tcalculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n\t\t// If path is first or last add another point to keep node port on its position\n\t\tif (index === 0) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index].getX(), points[index].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index);\n\t\t\tthis.dragging_index++;\n\t\t\treturn;\n\t\t} else if (index === points.length - 2) {\n\t\t\tlet point = new PointModel({\n\t\t\t\tlink: this.props.link,\n\t\t\t\tposition: new Point(points[index + 1].getX(), points[index + 1].getY())\n\t\t\t});\n\t\t\tthis.props.link.addPoint(point, index + 1);\n\t\t\treturn;\n\t\t}\n\n\t\t// Merge two points if it is not close to node port and close to each other\n\t\tif (index - 2 > 0) {\n\t\t\tlet _points = {\n\t\t\t\t[index - 2]: points[index - 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index - 1]: points[index - 1].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n\t\t\t\t_points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index - 2].setPosition(_points[index - 2]);\n\t\t\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tpoints[index - 1].remove();\n\t\t\t\tthis.dragging_index--;\n\t\t\t\tthis.dragging_index--;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Merge two points if it is not close to node port\n\t\tif (index + 2 < points.length - 2) {\n\t\t\tlet _points = {\n\t\t\t\t[index + 3]: points[index + 3].getPosition(),\n\t\t\t\t[index + 2]: points[index + 2].getPosition(),\n\t\t\t\t[index + 1]: points[index + 1].getPosition(),\n\t\t\t\t[index]: points[index].getPosition()\n\t\t\t};\n\t\t\tif (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n\t\t\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\t_points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t\t\tpoints[index].setPosition(_points[index]);\n\t\t\t\tpoints[index + 3].setPosition(_points[index + 3]);\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\tpoints[index + 1].remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If no condition above handled then just update path points position\n\t\tlet _points = {\n\t\t\t[index]: points[index].getPosition(),\n\t\t\t[index + 1]: points[index + 1].getPosition()\n\t\t};\n\t\t_points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\t_points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n\t\tpoints[index].setPosition(_points[index]);\n\t\tpoints[index + 1].setPosition(_points[index + 1]);\n\t}\n\n\tdraggingEvent(event: MouseEvent, index: number) {\n\t\tlet points = this.props.link.getPoints();\n\t\t// get moving difference. Index + 1 will work because links indexes has\n\t\t// length = points.lenght - 1\n\t\tlet dx = Math.abs(points[index].getX() - points[index + 1].getX());\n\t\tlet dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n\t\t// moving with y direction\n\t\tif (dx === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'x');\n\t\t} else if (dy === 0) {\n\t\t\tthis.calculatePositions(points, event, index, 'y');\n\t\t}\n\t\tthis.props.link.setFirstAndLastPathsDirection();\n\t}\n\n\thandleMove = function (event: MouseEvent) {\n\t\tthis.draggingEvent(event, this.dragging_index);\n\t}.bind(this);\n\n\thandleUp = function (event: MouseEvent) {\n\t\t// Unregister handlers to avoid multiple event handlers for other links\n\t\tthis.setState({ canDrag: false, selected: false });\n\t\twindow.removeEventListener('mousemove', this.handleMove);\n\t\twindow.removeEventListener('mouseup', this.handleUp);\n\t}.bind(this);\n\n\trender() {\n\t\t//ensure id is present for all points on the path\n\t\tlet points = this.props.link.getPoints();\n\t\tlet paths = [];\n\n\t\t// Get points based on link orientation\n\t\tlet pointLeft = points[0];\n\t\tlet pointRight = points[points.length - 1];\n\t\tlet hadToSwitch = false;\n\t\tif (pointLeft.getX() > pointRight.getX()) {\n\t\t\tpointLeft = points[points.length - 1];\n\t\t\tpointRight = points[0];\n\t\t\thadToSwitch = true;\n\t\t}\n\t\tlet dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n\t\t// When new link add one middle point to get everywhere 90° angle\n\t\tif (this.props.link.getTargetPort() === null && points.length === 2) {\n\t\t\t[...Array(2)].forEach((item) => {\n\t\t\t\tthis.props.link.addPoint(\n\t\t\t\t\tnew PointModel({\n\t\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t\t}),\n\t\t\t\t\t1\n\t\t\t\t);\n\t\t\t});\n\t\t\tthis.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n\t\t}\n\t\t// When new link is moving and not connected to target port move with middle point\n\t\t// TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n\t\t//  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n\t\telse if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n\t\t\tpoints[1].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointLeft.getY() : pointRight.getY()\n\t\t\t);\n\t\t\tpoints[2].setPosition(\n\t\t\t\tpointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n\t\t\t\t!hadToSwitch ? pointRight.getY() : pointLeft.getY()\n\t\t\t);\n\t\t}\n\t\t// Render was called but link is not moved but user.\n\t\t// Node is moved and in this case fix coordinates to get 90° angle.\n\t\t// For loop just for first and last path\n\t\telse if (!this.state.canDrag && points.length > 2) {\n\t\t\t// Those points and its position only will be moved\n\t\t\tfor (let i = 1; i < points.length; i += points.length - 2) {\n\t\t\t\tif (i - 1 === 0) {\n\t\t\t\t\tif (this.props.link.getFirstPathXdirection()) {\n\t\t\t\t\t\tpoints[i].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (this.props.link.getLastPathXdirection()) {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpoints[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If there is existing link which has two points add one\n\t\t// NOTE: It doesn't matter if check is for dy or dx\n\t\tif (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n\t\t\tthis.props.link.addPoint(\n\t\t\t\tnew PointModel({\n\t\t\t\t\tlink: this.props.link,\n\t\t\t\t\tposition: new Point(pointLeft.getX(), pointRight.getY())\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\n\t\tfor (let j = 0; j < points.length - 1; j++) {\n\t\t\tpaths.push(\n\t\t\t\tthis.generateLink(\n\t\t\t\t\tLinkWidget.generateLinePath(points[j], points[j + 1]),\n\t\t\t\t\t{\n\t\t\t\t\t\t'data-linkid': this.props.link.getID(),\n\t\t\t\t\t\t'data-point': j,\n\t\t\t\t\t\tonMouseDown: (event: MouseEvent) => {\n\t\t\t\t\t\t\tif (event.button === 0) {\n\t\t\t\t\t\t\t\tthis.setState({ canDrag: true });\n\t\t\t\t\t\t\t\tthis.dragging_index = j;\n\t\t\t\t\t\t\t\t// Register mouse move event to track mouse position\n\t\t\t\t\t\t\t\t// On mouse up these events are unregistered check \"this.handleUp\"\n\t\t\t\t\t\t\t\twindow.addEventListener('mousemove', this.handleMove);\n\t\t\t\t\t\t\t\twindow.addEventListener('mouseup', this.handleUp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonMouseEnter: (event: MouseEvent) => {\n\t\t\t\t\t\t\tthis.setState({ selected: true });\n\t\t\t\t\t\t\tthis.props.link.lastHoverIndexOfPath = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tj\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tthis.refPaths = [];\n\t\treturn <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n\t}\n}\n","module.exports = require(\"@projectstorm/geometry\");","module.exports = require(\"@projectstorm/react-canvas-core\");","module.exports = require(\"@projectstorm/react-diagrams-core\");","module.exports = require(\"@projectstorm/react-diagrams-defaults\");","module.exports = require(\"dagre\");","module.exports = require(\"lodash\");","module.exports = require(\"pathfinding\");","module.exports = require(\"paths-js/path\");","module.exports = require(\"react\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(418);\n"],"names":["root","factory","exports","module","define","amd","self","constructor","options","this","redistribute","model","g","dagre","graphlib","Graph","multigraph","compound","setGraph","graph","setDefaultEdgeLabel","_","forEach","getNodes","node","setNode","getID","width","height","getLinks","link","getSourcePort","getTargetPort","setEdge","v","getNode","w","name","layout","nodes","setPosition","x","y","includeLinks","edges","e","edge","getLink","points","getFirstPoint","i","length","push","PointModel","position","Point","setPoints","concat","getLastPoint","pathFinderInstance","PF","JumpPointFinder","heuristic","Heuristic","manhattan","diagonalMovement","DiagonalMovement","Never","instance","calculateDirectPath","from","to","matrix","getCanvasMatrix","grid","Grid","findPath","translateRoutingX","Math","floor","getX","ROUTING_SCALING_FACTOR","translateRoutingY","getY","calculateLinkStartEndCoords","path","startIndex","findIndex","point","endIndex","slice","reverse","pathToStart","pathToEnd","start","end","calculateDynamicPath","routingMatrix","dynamicPath","pathCoords","map","coords","Util","compressPath","PathFindingLinkFactory","DefaultLinkFactory","super","NAME","canvasMatrix","hAdjustmentFactor","vAdjustmentFactor","calculateMatrixDimensions","allNodesCoords","values","engine","getModel","item","allLinks","allPortsCoords","flatMap","filter","port","allPointsCoords","getPoints","sumProps","object","props","reduce","acc","prop","get","canvas","getCanvas","concatedCoords","minX","min","minBy","maxXElement","maxBy","maxX","max","offsetWidth","minYCoords","minY","maxYElement","maxY","offsetHeight","ceil","abs","markNodes","startX","endX","startY","endY","markMatrixPoint","markPorts","undefined","setDiagramEngine","getStateMachine","registerListener","stateChanged","event","newState","AbstractDisplacementState","deRegister","getActionEventBus","registerAction","Action","type","InputType","MOUSE_UP","fire","calculateRoutingMatrix","repaintCanvas","listener","canvasReady","defer","setFactoryBank","bank","deregister","generateReactWidget","PathFindingLinkWidget","diagramEngine","generateModel","PathFindingLinkModel","calculateCanvasMatrix","canvasWidth","canvasHeight","matrixWidth","matrixHeight","range","Array","fill","getRoutingMatrix","cloneDeep","generateDynamicPath","Path","moveto","lineto","print","DefaultLinkModel","performanceTune","React","Component","refPaths","state","selected","pathFinding","PathFinding","componentDidUpdate","setRenderedPaths","ref","current","componentDidMount","componentWillUnmount","generateLink","id","createRef","DefaultLinkSegmentWidget","key","getFactoryForLink","forwardRef","onSelection","setState","extras","render","paths","directPathCoords","first","last","smartLink","simplifiedPath","RightAngleLinkFactory","RightAngleLinkModel","RightAngleLinkWidget","lastHoverIndexOfPath","_lastPathXdirection","_firstPathXdirection","setFirstAndLastPathsDirection","dx","dy","addPoint","pointModel","index","deserialize","setManuallyFirstAndLastPathsDirection","getLastPathXdirection","getFirstPathXdirection","setWidth","fireEvent","setColor","color","handleMove","draggingEvent","dragging_index","bind","handleUp","canDrag","window","removeEventListener","extraProps","calculatePositions","coordinate","_points","getPosition","getRelativeMousePoint","remove","pointLeft","pointRight","hadToSwitch","j","LinkWidget","generateLinePath","onMouseDown","button","addEventListener","onMouseEnter","getOptions","testName","defaultProps","smooth","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}