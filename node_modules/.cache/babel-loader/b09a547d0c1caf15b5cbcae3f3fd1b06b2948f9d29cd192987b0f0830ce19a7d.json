{"ast":null,"code":"import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nvar filterUsingOperator = function (itemValue, _a) {\n  var tokenValue = _a.tokenValue,\n    _b = _a.operator,\n    operator = _b.operator,\n    match = _b.match,\n    tokenType = _b.tokenType;\n  // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n  // The token value is expected to be an ISO date- or datetime string, example:\n  // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n  if (match === 'date' || match === 'datetime') {\n    return matchDateValue({\n      tokenValue: tokenValue,\n      itemValue: itemValue,\n      operator: operator,\n      match: match\n    });\n  }\n  // For custom match functions there is no expectation to value or token type: the function is supposed\n  // to handle everything. It is recommended to treat both the token and the value as unknowns.\n  else if (typeof match === 'function') {\n    return match(itemValue, tokenValue);\n  } else if (match) {\n    throw new Error('Unsupported `operator.match` type given.');\n  }\n  // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n  // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n  // match(operator=\"=\", token=\"A\", value=\"A\") == true\n  // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n  return matchPrimitiveValue({\n    tokenValue: tokenValue,\n    itemValue: itemValue,\n    operator: operator,\n    tokenType: tokenType\n  });\n};\nfunction matchDateValue(_a) {\n  var tokenValue = _a.tokenValue,\n    itemValue = _a.itemValue,\n    operator = _a.operator,\n    match = _a.match;\n  var comparator = match === 'date' ? compareDates : compareTimestamps;\n  var comparisonResult = comparator(itemValue, tokenValue);\n  switch (operator) {\n    case '<':\n      return comparisonResult < 0;\n    case '<=':\n      return comparisonResult <= 0;\n    case '>':\n      return comparisonResult > 0;\n    case '>=':\n      return comparisonResult >= 0;\n    case '=':\n      return comparisonResult === 0;\n    case '!=':\n      return comparisonResult !== 0;\n    default:\n      warnOnce(\"Unsupported operator \\\"\".concat(operator, \"\\\" given for match=\\\"\").concat(match, \"\\\".\"));\n      return false;\n  }\n}\nfunction matchPrimitiveValue(_a) {\n  var tokenValue = _a.tokenValue,\n    itemValue = _a.itemValue,\n    operator = _a.operator,\n    tokenType = _a.tokenType;\n  if (tokenType === 'enum') {\n    if (!tokenValue || !Array.isArray(tokenValue)) {\n      warnOnce('The token value must be an array when tokenType==\"enum\".');\n      return false;\n    }\n    switch (operator) {\n      case '=':\n        return tokenValue && tokenValue.includes(itemValue);\n      case '!=':\n        return !tokenValue || !tokenValue.includes(itemValue);\n      default:\n        warnOnce(\"Unsupported operator \\\"\".concat(operator, \"\\\" given for tokenType==\\\"enum\\\".\"));\n        return false;\n    }\n  }\n  switch (operator) {\n    case '<':\n      return itemValue < tokenValue;\n    case '<=':\n      return itemValue <= tokenValue;\n    case '>':\n      return itemValue > tokenValue;\n    case '>=':\n      return itemValue >= tokenValue;\n    case '=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue == tokenValue;\n    case '!=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue != tokenValue;\n    case ':':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n    case '!:':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n    case '^':\n      return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    case '!^':\n      return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    // The unsupported operators result in an exception being thrown.\n    // The exception can be avoided if using the match function.\n    default:\n      throw new Error('Unsupported operator given.');\n  }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n  // If the operator is not a negation, we just need one property of the object to match.\n  // If the operator is a negation, we want none of the properties of the object to match.\n  var isNegation = operator.startsWith('!');\n  return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](function (propertyKey) {\n    var operators = filteringPropertiesMap[propertyKey].operators;\n    var propertyOperator = operators[operator];\n    if (!propertyOperator) {\n      return isNegation;\n    }\n    return filterUsingOperator(item[propertyKey], {\n      tokenValue: tokenValue,\n      operator: propertyOperator\n    });\n  });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n  if (token.propertyKey) {\n    // token refers to a unknown property or uses an unsupported operator\n    if (!(token.propertyKey in filteringPropertiesMap) || !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n      return false;\n    }\n    var property = filteringPropertiesMap[token.propertyKey];\n    var operator = property.operators[token.operator];\n    var itemValue = (operator === null || operator === void 0 ? void 0 : operator.match) ? item[token.propertyKey] : fixupFalsyValues(item[token.propertyKey]);\n    return filterUsingOperator(itemValue, {\n      tokenValue: token.value,\n      operator: operator !== null && operator !== void 0 ? operator : {\n        operator: token.operator\n      }\n    });\n  }\n  return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n  return function (item, query) {\n    var _a;\n    function evaluate(tokenOrGroup) {\n      if ('operation' in tokenOrGroup) {\n        var result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n        for (var _i = 0, _a = tokenOrGroup.tokens; _i < _a.length; _i++) {\n          var group = _a[_i];\n          result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n        }\n        return result;\n      } else {\n        return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n      }\n    }\n    return evaluate({\n      operation: query.operation,\n      tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens\n    });\n  };\n}\nexport function createPropertyFilterPredicate(propertyFiltering, query) {\n  if (query === void 0) {\n    query = {\n      tokens: [],\n      operation: 'and'\n    };\n  }\n  if (!propertyFiltering) {\n    return null;\n  }\n  var filteringPropertiesMap = propertyFiltering.filteringProperties.reduce(function (acc, _a) {\n    var _b;\n    var key = _a.key,\n      operators = _a.operators,\n      defaultOperator = _a.defaultOperator;\n    var operatorMap = (_b = {}, _b[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = {\n      operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='\n    }, _b);\n    operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {\n      if (typeof op === 'string') {\n        operatorMap[op] = {\n          operator: op\n        };\n      } else {\n        operatorMap[op.operator] = {\n          operator: op.operator,\n          match: op.match,\n          tokenType: op.tokenType\n        };\n      }\n    });\n    acc[key] = {\n      operators: operatorMap\n    };\n    return acc;\n  }, {});\n  var filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n  return function (item) {\n    return filteringFunction(item, query);\n  };\n}\nexport var fixupFalsyValues = function (value) {\n  if (typeof value === 'boolean') {\n    return value + '';\n  }\n  if (value || value === 0) {\n    return value;\n  }\n  return '';\n};","map":{"version":3,"names":["compareDates","compareTimestamps","warnOnce","filterUsingOperator","itemValue","_a","tokenValue","_b","operator","match","tokenType","matchDateValue","Error","matchPrimitiveValue","comparator","comparisonResult","concat","Array","isArray","includes","toLowerCase","indexOf","startsWith","freeTextFilter","item","filteringPropertiesMap","isNegation","Object","keys","propertyKey","operators","propertyOperator","filterByToken","token","property","fixupFalsyValues","value","defaultFilteringFunction","query","evaluate","tokenOrGroup","result","operation","tokens","length","_i","group","tokenGroups","createPropertyFilterPredicate","propertyFiltering","filteringProperties","reduce","acc","key","defaultOperator","operatorMap","forEach","op","filteringFunction"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/@cloudscape-design/collection-hooks/mjs/operations/property-filter.js"],"sourcesContent":["import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nvar filterUsingOperator = function (itemValue, _a) {\n    var tokenValue = _a.tokenValue, _b = _a.operator, operator = _b.operator, match = _b.match, tokenType = _b.tokenType;\n    // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n    // The token value is expected to be an ISO date- or datetime string, example:\n    // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n    if (match === 'date' || match === 'datetime') {\n        return matchDateValue({ tokenValue: tokenValue, itemValue: itemValue, operator: operator, match: match });\n    }\n    // For custom match functions there is no expectation to value or token type: the function is supposed\n    // to handle everything. It is recommended to treat both the token and the value as unknowns.\n    else if (typeof match === 'function') {\n        return match(itemValue, tokenValue);\n    }\n    else if (match) {\n        throw new Error('Unsupported `operator.match` type given.');\n    }\n    // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n    // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n    // match(operator=\"=\", token=\"A\", value=\"A\") == true\n    // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n    return matchPrimitiveValue({ tokenValue: tokenValue, itemValue: itemValue, operator: operator, tokenType: tokenType });\n};\nfunction matchDateValue(_a) {\n    var tokenValue = _a.tokenValue, itemValue = _a.itemValue, operator = _a.operator, match = _a.match;\n    var comparator = match === 'date' ? compareDates : compareTimestamps;\n    var comparisonResult = comparator(itemValue, tokenValue);\n    switch (operator) {\n        case '<':\n            return comparisonResult < 0;\n        case '<=':\n            return comparisonResult <= 0;\n        case '>':\n            return comparisonResult > 0;\n        case '>=':\n            return comparisonResult >= 0;\n        case '=':\n            return comparisonResult === 0;\n        case '!=':\n            return comparisonResult !== 0;\n        default:\n            warnOnce(\"Unsupported operator \\\"\".concat(operator, \"\\\" given for match=\\\"\").concat(match, \"\\\".\"));\n            return false;\n    }\n}\nfunction matchPrimitiveValue(_a) {\n    var tokenValue = _a.tokenValue, itemValue = _a.itemValue, operator = _a.operator, tokenType = _a.tokenType;\n    if (tokenType === 'enum') {\n        if (!tokenValue || !Array.isArray(tokenValue)) {\n            warnOnce('The token value must be an array when tokenType==\"enum\".');\n            return false;\n        }\n        switch (operator) {\n            case '=':\n                return tokenValue && tokenValue.includes(itemValue);\n            case '!=':\n                return !tokenValue || !tokenValue.includes(itemValue);\n            default:\n                warnOnce(\"Unsupported operator \\\"\".concat(operator, \"\\\" given for tokenType==\\\"enum\\\".\"));\n                return false;\n        }\n    }\n    switch (operator) {\n        case '<':\n            return itemValue < tokenValue;\n        case '<=':\n            return itemValue <= tokenValue;\n        case '>':\n            return itemValue > tokenValue;\n        case '>=':\n            return itemValue >= tokenValue;\n        case '=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue == tokenValue;\n        case '!=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue != tokenValue;\n        case ':':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n        case '!:':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n        case '^':\n            return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        case '!^':\n            return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        // The unsupported operators result in an exception being thrown.\n        // The exception can be avoided if using the match function.\n        default:\n            throw new Error('Unsupported operator given.');\n    }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n    // If the operator is not a negation, we just need one property of the object to match.\n    // If the operator is a negation, we want none of the properties of the object to match.\n    var isNegation = operator.startsWith('!');\n    return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](function (propertyKey) {\n        var operators = filteringPropertiesMap[propertyKey].operators;\n        var propertyOperator = operators[operator];\n        if (!propertyOperator) {\n            return isNegation;\n        }\n        return filterUsingOperator(item[propertyKey], { tokenValue: tokenValue, operator: propertyOperator });\n    });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n    if (token.propertyKey) {\n        // token refers to a unknown property or uses an unsupported operator\n        if (!(token.propertyKey in filteringPropertiesMap) ||\n            !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n            return false;\n        }\n        var property = filteringPropertiesMap[token.propertyKey];\n        var operator = property.operators[token.operator];\n        var itemValue = (operator === null || operator === void 0 ? void 0 : operator.match)\n            ? item[token.propertyKey]\n            : fixupFalsyValues(item[token.propertyKey]);\n        return filterUsingOperator(itemValue, {\n            tokenValue: token.value,\n            operator: operator !== null && operator !== void 0 ? operator : { operator: token.operator },\n        });\n    }\n    return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n    return function (item, query) {\n        var _a;\n        function evaluate(tokenOrGroup) {\n            if ('operation' in tokenOrGroup) {\n                var result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n                for (var _i = 0, _a = tokenOrGroup.tokens; _i < _a.length; _i++) {\n                    var group = _a[_i];\n                    result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n                }\n                return result;\n            }\n            else {\n                return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n            }\n        }\n        return evaluate({\n            operation: query.operation,\n            tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens,\n        });\n    };\n}\nexport function createPropertyFilterPredicate(propertyFiltering, query) {\n    if (query === void 0) { query = { tokens: [], operation: 'and' }; }\n    if (!propertyFiltering) {\n        return null;\n    }\n    var filteringPropertiesMap = propertyFiltering.filteringProperties.reduce(function (acc, _a) {\n        var _b;\n        var key = _a.key, operators = _a.operators, defaultOperator = _a.defaultOperator;\n        var operatorMap = (_b = {}, _b[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=' }, _b);\n        operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {\n            if (typeof op === 'string') {\n                operatorMap[op] = { operator: op };\n            }\n            else {\n                operatorMap[op.operator] = { operator: op.operator, match: op.match, tokenType: op.tokenType };\n            }\n        });\n        acc[key] = { operators: operatorMap };\n        return acc;\n    }, {});\n    var filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n    return function (item) { return filteringFunction(item, query); };\n}\nexport var fixupFalsyValues = function (value) {\n    if (typeof value === 'boolean') {\n        return value + '';\n    }\n    if (value || value === 0) {\n        return value;\n    }\n    return '';\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}