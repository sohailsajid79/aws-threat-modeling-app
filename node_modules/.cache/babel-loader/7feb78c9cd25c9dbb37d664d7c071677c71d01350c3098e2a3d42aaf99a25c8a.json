{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  constructor(layout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n  move(moveCommand) {\n    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.cache;\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({\n      ...moveCommand\n    }, cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  resize(resizeCommand) {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({\n        x: width,\n        y: height\n      }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  insert(_ref) {\n    let {\n      itemId,\n      width,\n      height,\n      path: [position, ...movePath]\n    } = _ref;\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", {\n      id: itemId,\n      x: position.x,\n      y: position.y,\n      width,\n      height\n    }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n    return this.move({\n      itemId,\n      path: movePath\n    }, cache);\n  }\n  remove(itemId) {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", {\n      id: itemId,\n      x,\n      y,\n      width,\n      height\n    }, new Position({\n      x,\n      y\n    }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n  getLayoutShift(state) {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : []\n    };\n  }\n  validateMovePath(_ref2, state) {\n    let {\n      itemId,\n      path\n    } = _ref2;\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({\n      x: moveTarget.x,\n      y: moveTarget.y\n    }), path);\n  }\n  validateResizePath(_ref3, state) {\n    let {\n      itemId,\n      path\n    } = _ref3;\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({\n      x,\n      y\n    }), path);\n  }\n}","map":{"version":3,"names":["Position","LayoutEngineCacheNode","LayoutEngineState","resolveOverlaps","LayoutEngineGrid","createMove","normalizeMovePath","normalizeResizePath","sortGridItems","LayoutEngine","constructor","layout","cache","items","columns","move","moveCommand","arguments","length","undefined","path","validateMovePath","state","stepIndex","item","grid","getItem","itemId","matches","getLayoutShift","resize","resizeCommand","validateResizePath","resizeTarget","width","x","height","y","insert","_ref","position","movePath","insertMove","id","remove","current","next","rows","moves","conflicts","_ref2","moveTarget","step","Error","_ref3"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/layout-engine/engine.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { GridLayout, ItemId } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { InsertCommand, LayoutShift, MoveCommand, ResizeCommand } from \"./interfaces\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  private layout: GridLayout;\n  private cache: LayoutEngineCacheNode;\n\n  constructor(layout: GridLayout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n\n  move(moveCommand: MoveCommand, cache = this.cache): LayoutShift {\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({ ...moveCommand }, cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  resize(resizeCommand: ResizeCommand): LayoutShift {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({ x: width, y: height }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  insert({ itemId, width, height, path: [position, ...movePath] }: InsertCommand): LayoutShift {\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", { id: itemId, x: position.x, y: position.y, width, height }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n\n    return this.move({ itemId, path: movePath }, cache);\n  }\n\n  remove(itemId: ItemId): LayoutShift {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const { x, y, width, height } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", { id: itemId, x, y, width, height }, new Position({ x, y }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n\n  private getLayoutShift(state: LayoutEngineState): LayoutShift {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height,\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : [],\n    };\n  }\n\n  private validateMovePath({ itemId, path }: MoveCommand, state: LayoutEngineState): readonly Position[] {\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({ x: moveTarget.x, y: moveTarget.y }), path);\n  }\n\n  private validateResizePath({ itemId, path }: ResizeCommand, state: LayoutEngineState): readonly Position[] {\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({ x, y }), path);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}