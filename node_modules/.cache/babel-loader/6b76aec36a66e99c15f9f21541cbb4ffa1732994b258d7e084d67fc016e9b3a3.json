{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect } from \"react\";\nimport { useStableCallback } from \"@cloudscape-design/component-toolkit/internal\";\nimport { Coordinates } from \"../utils/coordinates\";\nimport { EventEmitter } from \"./event-emitter\";\nimport { getHoveredDroppables } from \"./get-hovered-droppables\";\nclass DragAndDropController extends EventEmitter {\n  constructor() {\n    super(...arguments);\n    this.droppables = new Map();\n    this.transition = null;\n  }\n  /**\n   * Inits a drag transition and issues a \"start\" event.\n   *\n   * The method overrides the previous transition if exists (w/o a cancellation event)!\n   */\n  start(transition) {\n    this.transition = {\n      ...transition\n    };\n    this.emit(\"start\", this.getDragAndDropData(transition.startCoordinates));\n  }\n  /**\n   * Updates current transition with given coordinates and issues an \"update\" event.\n   */\n  update(coordinates) {\n    this.emit(\"update\", this.getDragAndDropData(coordinates));\n  }\n  /**\n   * Removes transition and issues a \"submit\" event.\n   */\n  submit() {\n    this.emit(\"submit\");\n    this.transition = null;\n  }\n  /**\n   * Removes transition and issues a \"discard\" event.\n   */\n  discard() {\n    this.emit(\"discard\");\n    this.transition = null;\n  }\n  /**\n   * Issues an \"acquire\" event to notify the current transition draggable is acquired by the given droppable.\n   */\n  acquire(droppableId, renderAcquiredItem) {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for acquire.\");\n    }\n    this.emit(\"acquire\", {\n      droppableId,\n      draggableItem: this.transition.draggableItem,\n      renderAcquiredItem\n    });\n  }\n  /**\n   * Registers a droppable used for collisions check, acquire, and dropTarget provision.\n   */\n  addDroppable(id, context, element) {\n    this.droppables.set(id, {\n      element,\n      context\n    });\n  }\n  /**\n   * Un-registers the droppable - use it when component unmounts.\n   */\n  removeDroppable(id) {\n    this.droppables.delete(id);\n  }\n  /**\n   * Retrieves all registered droppables to run a manual match against.\n   */\n  getDroppables() {\n    return [...this.droppables.entries()];\n  }\n  getDragAndDropData(coordinates) {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for interaction.\");\n    }\n    const positionOffset = Coordinates.cursorOffset(coordinates, this.transition.startCoordinates);\n    const collisionRect = this.getCollisionRect(this.transition, coordinates);\n    const {\n      collisionIds,\n      dropTarget\n    } = this.getCollisions(collisionRect);\n    return {\n      ...this.transition,\n      positionOffset,\n      coordinates,\n      collisionRect,\n      collisionIds,\n      dropTarget\n    };\n  }\n  getCollisionRect(transition, coordinates) {\n    const originalCollisionRect = transition.getCollisionRect(transition.operation, coordinates, null);\n    const {\n      dropTarget\n    } = this.getCollisions(originalCollisionRect);\n    return transition.getCollisionRect(transition.operation, coordinates, dropTarget);\n  }\n  getCollisions(collisionRect) {\n    const droppableEntries = [...this.droppables.entries()];\n    const droppableElements = droppableEntries.map(([id, entry]) => [id, entry.element]);\n    const collisionIds = getHoveredDroppables(collisionRect, droppableElements);\n    if (collisionIds.length === 0) {\n      return {\n        collisionIds,\n        dropTarget: null\n      };\n    }\n    const matchedDroppable = droppableEntries.find(([id]) => id === collisionIds[0]);\n    if (!matchedDroppable) {\n      throw new Error(\"Invariant violation: no droppable matches collision.\");\n    }\n    return {\n      collisionIds,\n      dropTarget: matchedDroppable[1].context\n    };\n  }\n}\n// Controller is a singleton and is shared between all d&d elements.\nconst controller = new DragAndDropController();\nexport function useDragSubscription(event, handler) {\n  const stableHandler = useStableCallback(handler);\n  useEffect(() => controller.on(event, stableHandler), [event, stableHandler]);\n}\nexport function useDraggable({\n  draggableItem,\n  getCollisionRect\n}) {\n  return {\n    start(operation, interactionType, startCoordinates) {\n      controller.start({\n        operation,\n        interactionType,\n        draggableItem,\n        getCollisionRect,\n        startCoordinates\n      });\n    },\n    updateTransition(coordinates) {\n      controller.update(coordinates);\n    },\n    submitTransition() {\n      controller.submit();\n    },\n    discardTransition() {\n      controller.discard();\n    },\n    acquire(droppableId, renderAcquiredItem) {\n      controller.acquire(droppableId, renderAcquiredItem);\n    },\n    getDroppables() {\n      return controller.getDroppables();\n    }\n  };\n}\nexport function useDroppable({\n  itemId,\n  context,\n  getElement\n}) {\n  useEffect(() => {\n    controller.addDroppable(itemId, context, getElement());\n    return () => controller.removeDroppable(itemId);\n  }, [itemId, context, getElement]);\n}","map":{"version":3,"names":["useEffect","useStableCallback","Coordinates","EventEmitter","getHoveredDroppables","DragAndDropController","constructor","droppables","Map","transition","start","emit","getDragAndDropData","startCoordinates","update","coordinates","submit","discard","acquire","droppableId","renderAcquiredItem","Error","draggableItem","addDroppable","id","context","element","set","removeDroppable","delete","getDroppables","entries","positionOffset","cursorOffset","collisionRect","getCollisionRect","collisionIds","dropTarget","getCollisions","originalCollisionRect","operation","droppableEntries","droppableElements","map","entry","length","matchedDroppable","find","controller","useDragSubscription","event","handler","stableHandler","on","useDraggable","interactionType","updateTransition","submitTransition","discardTransition","useDroppable","itemId","getElement"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/dnd-controller/controller.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ReactNode, useEffect } from \"react\";\n\nimport { useStableCallback } from \"@cloudscape-design/component-toolkit/internal\";\n\nimport { BoardItemDefinitionBase, ItemId, Rect } from \"../interfaces\";\nimport { Coordinates } from \"../utils/coordinates\";\nimport { EventEmitter } from \"./event-emitter\";\nimport { getHoveredDroppables } from \"./get-hovered-droppables\";\n\ntype Item = BoardItemDefinitionBase<unknown>;\n\nexport type Operation = \"reorder\" | \"resize\" | \"insert\";\n\nexport type InteractionType = \"pointer\" | \"keyboard\";\n\n/**\n * Represents the relations between droppables and draggables.\n *\n * The `scale` function transforms draggable's width/height in relative units\n * to the absolute width/height in pixels the droppable expects.\n */\nexport interface DropTargetContext {\n  scale: (item: Item, size?: { width: number; height: number }) => { width: number; height: number };\n}\n\nexport interface DragAndDropData {\n  operation: Operation;\n  interactionType: InteractionType;\n  draggableItem: Item;\n  collisionRect: Rect;\n  positionOffset: Coordinates;\n  coordinates: Coordinates;\n  collisionIds: ItemId[];\n  dropTarget: null | DropTargetContext;\n}\n\nexport interface Droppable {\n  element: HTMLElement;\n  context: DropTargetContext;\n}\n\nexport interface AcquireData {\n  droppableId: ItemId;\n  draggableItem: Item;\n  renderAcquiredItem: () => ReactNode;\n}\n\nexport interface DragAndDropEvents {\n  start: (data: DragAndDropData) => void;\n  update: (data: DragAndDropData) => void;\n  submit: () => void;\n  discard: () => void;\n  acquire: (data: AcquireData) => void;\n}\n\ninterface Transition {\n  operation: Operation;\n  interactionType: InteractionType;\n  draggableItem: Item;\n  getCollisionRect: (operation: Operation, coordinates: Coordinates, dropTarget: null | DropTargetContext) => Rect;\n  startCoordinates: Coordinates;\n}\n\nclass DragAndDropController extends EventEmitter<DragAndDropEvents> {\n  private droppables = new Map<ItemId, Droppable>();\n  private transition: null | Transition = null;\n\n  /**\n   * Inits a drag transition and issues a \"start\" event.\n   *\n   * The method overrides the previous transition if exists (w/o a cancellation event)!\n   */\n  public start(transition: Transition) {\n    this.transition = { ...transition };\n    this.emit(\"start\", this.getDragAndDropData(transition.startCoordinates));\n  }\n\n  /**\n   * Updates current transition with given coordinates and issues an \"update\" event.\n   */\n  public update(coordinates: Coordinates) {\n    this.emit(\"update\", this.getDragAndDropData(coordinates));\n  }\n\n  /**\n   * Removes transition and issues a \"submit\" event.\n   */\n  public submit() {\n    this.emit(\"submit\");\n    this.transition = null;\n  }\n\n  /**\n   * Removes transition and issues a \"discard\" event.\n   */\n  public discard() {\n    this.emit(\"discard\");\n    this.transition = null;\n  }\n\n  /**\n   * Issues an \"acquire\" event to notify the current transition draggable is acquired by the given droppable.\n   */\n  public acquire(droppableId: ItemId, renderAcquiredItem: () => ReactNode) {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for acquire.\");\n    }\n    this.emit(\"acquire\", { droppableId, draggableItem: this.transition.draggableItem, renderAcquiredItem });\n  }\n\n  /**\n   * Registers a droppable used for collisions check, acquire, and dropTarget provision.\n   */\n  public addDroppable(id: ItemId, context: DropTargetContext, element: HTMLElement) {\n    this.droppables.set(id, { element, context });\n  }\n\n  /**\n   * Un-registers the droppable - use it when component unmounts.\n   */\n  public removeDroppable(id: ItemId) {\n    this.droppables.delete(id);\n  }\n\n  /**\n   * Retrieves all registered droppables to run a manual match against.\n   */\n  public getDroppables() {\n    return [...this.droppables.entries()];\n  }\n\n  private getDragAndDropData(coordinates: Coordinates): DragAndDropData {\n    if (!this.transition) {\n      throw new Error(\"Invariant violation: no transition present for interaction.\");\n    }\n    const positionOffset = Coordinates.cursorOffset(coordinates, this.transition.startCoordinates);\n    const collisionRect = this.getCollisionRect(this.transition, coordinates);\n    const { collisionIds, dropTarget } = this.getCollisions(collisionRect);\n    return { ...this.transition, positionOffset, coordinates, collisionRect, collisionIds, dropTarget };\n  }\n\n  private getCollisionRect(transition: Transition, coordinates: Coordinates) {\n    const originalCollisionRect = transition.getCollisionRect(transition.operation, coordinates, null);\n    const { dropTarget } = this.getCollisions(originalCollisionRect);\n    return transition.getCollisionRect(transition.operation, coordinates, dropTarget);\n  }\n\n  private getCollisions(collisionRect: Rect) {\n    const droppableEntries = [...this.droppables.entries()];\n    const droppableElements: [ItemId, HTMLElement][] = droppableEntries.map(([id, entry]) => [id, entry.element]);\n    const collisionIds = getHoveredDroppables(collisionRect, droppableElements);\n    if (collisionIds.length === 0) {\n      return { collisionIds, dropTarget: null };\n    }\n\n    const matchedDroppable = droppableEntries.find(([id]) => id === collisionIds[0]);\n    if (!matchedDroppable) {\n      throw new Error(\"Invariant violation: no droppable matches collision.\");\n    }\n    return { collisionIds, dropTarget: matchedDroppable[1].context };\n  }\n}\n\n// Controller is a singleton and is shared between all d&d elements.\nconst controller = new DragAndDropController();\n\nexport function useDragSubscription<K extends keyof DragAndDropEvents>(event: K, handler: DragAndDropEvents[K]) {\n  const stableHandler = useStableCallback(handler);\n  useEffect(() => controller.on(event, stableHandler), [event, stableHandler]);\n}\n\nexport function useDraggable({\n  draggableItem,\n  getCollisionRect,\n}: {\n  draggableItem: Item;\n  getCollisionRect: (operation: Operation, coordinates: Coordinates, dropTarget: null | DropTargetContext) => Rect;\n}) {\n  return {\n    start(operation: Operation, interactionType: InteractionType, startCoordinates: Coordinates) {\n      controller.start({ operation, interactionType, draggableItem, getCollisionRect, startCoordinates });\n    },\n    updateTransition(coordinates: Coordinates) {\n      controller.update(coordinates);\n    },\n    submitTransition() {\n      controller.submit();\n    },\n    discardTransition() {\n      controller.discard();\n    },\n    acquire(droppableId: ItemId, renderAcquiredItem: () => ReactNode) {\n      controller.acquire(droppableId, renderAcquiredItem);\n    },\n    getDroppables() {\n      return controller.getDroppables();\n    },\n  };\n}\n\nexport function useDroppable({\n  itemId,\n  context,\n  getElement,\n}: {\n  itemId: ItemId;\n  context: DropTargetContext;\n  getElement: () => HTMLElement;\n}) {\n  useEffect(() => {\n    controller.addDroppable(itemId, context, getElement());\n    return () => controller.removeDroppable(itemId);\n  }, [itemId, context, getElement]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}