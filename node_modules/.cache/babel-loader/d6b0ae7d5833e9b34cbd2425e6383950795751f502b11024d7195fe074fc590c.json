{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef } from 'react';\nimport { useEffect, useMemo } from 'react';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getAllFocusables } from '../../internal/components/focus-lock/utils';\nimport { SingleTabStopNavigationProvider } from '../../internal/context/single-tab-stop-navigation-context';\nimport { KeyCode } from '../../internal/keycode';\nimport handleKey, { isEventLike } from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { defaultIsSuppressed, findTableRowByAriaRowIndex, findTableRowCellByAriaColIndex, focusNextElement, getClosestCell, isElementDisabled, isTableCell } from './utils';\n/**\n * Makes table navigable with keyboard commands.\n * See grid-navigation.md\n */\nexport function GridNavigationProvider(_ref) {\n  let {\n    keyboardNavigation,\n    pageSize,\n    getTable,\n    children\n  } = _ref;\n  const navigationAPI = useRef(null);\n  const gridNavigation = useMemo(() => new GridNavigationProcessor(navigationAPI), []);\n  const getTableStable = useStableCallback(getTable);\n  // Initialize the processor with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      const table = getTableStable();\n      table && gridNavigation.init(table);\n    }\n    return () => gridNavigation.cleanup();\n  }, [keyboardNavigation, gridNavigation, getTableStable]);\n  // Notify the processor of the props change.\n  useEffect(() => {\n    gridNavigation.update({\n      pageSize\n    });\n  }, [gridNavigation, pageSize]);\n  // Notify the processor of the new render.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      gridNavigation.refresh();\n    }\n  });\n  return React.createElement(SingleTabStopNavigationProvider, {\n    ref: navigationAPI,\n    navigationActive: keyboardNavigation,\n    getNextFocusTarget: gridNavigation.getNextFocusTarget,\n    isElementSuppressed: gridNavigation.isElementSuppressed,\n    onRegisterFocusable: gridNavigation.onRegisterFocusable,\n    onUnregisterActive: gridNavigation.onUnregisterActive\n  }, children);\n}\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed explicitly.\n */\nclass GridNavigationProcessor {\n  constructor(navigationAPI) {\n    // Props\n    this._pageSize = 0;\n    this._table = null;\n    // State\n    this.focusedCell = null;\n    this.keepUserIndex = false;\n    this.onRegisterFocusable = focusableElement => {\n      var _a;\n      // When newly registered element belongs to the focused cell the focus must transition to it.\n      const focusedElement = (_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element;\n      if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {\n        // Scroll is unnecessary when moving focus from a cell to element within the cell.\n        focusableElement.focus({\n          preventScroll: true\n        });\n      }\n    };\n    this.onUnregisterActive = () => {\n      // If the focused cell appears to be no longer attached to the table we need to re-apply\n      // focus to a cell with the same or closest position.\n      if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {\n        this.moveFocusBy(this.focusedCell, {\n          x: 0,\n          y: 0\n        });\n      }\n    };\n    this.getNextFocusTarget = () => {\n      var _a;\n      const cell = this.focusedCell;\n      const firstTableCell = this.table.querySelector('td,th');\n      // A single element of the table is made user-focusable.\n      // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n      let focusTarget = (_a = firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) !== null && _a !== void 0 ? _a : firstTableCell;\n      // When a navigation-focused element is present in the table it is used for user-navigation instead.\n      if (cell) {\n        focusTarget = this.getNextFocusable(cell, {\n          x: 0,\n          y: 0\n        });\n      }\n      return focusTarget;\n    };\n    this.isElementSuppressed = element => {\n      // Omit calculation as irrelevant until the table receives focus.\n      if (!this.focusedCell) {\n        return false;\n      }\n      return !element || defaultIsSuppressed(element);\n    };\n    this.onFocusin = event => {\n      var _a;\n      if (!(event.target instanceof HTMLElement)) {\n        return;\n      }\n      this.updateFocusedCell(event.target);\n      if (!this.focusedCell) {\n        return;\n      }\n      (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.updateFocusTarget();\n      // Focusing on cell is not eligible when it contains focusable elements in the content.\n      // If content focusables are available - move the focus to the first one.\n      const focusedElement = this.focusedCell.element;\n      const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;\n      if (nextTarget) {\n        // Scroll is unnecessary when moving focus from a cell to element within the cell.\n        nextTarget.focus({\n          preventScroll: true\n        });\n      } else {\n        this.keepUserIndex = false;\n      }\n    };\n    this.onKeydown = event => {\n      if (!this.focusedCell) {\n        return;\n      }\n      const keys = [KeyCode.up, KeyCode.down, KeyCode.left, KeyCode.right, KeyCode.pageUp, KeyCode.pageDown, KeyCode.home, KeyCode.end];\n      const ctrlKey = event.ctrlKey ? 1 : 0;\n      const altKey = event.altKey ? 1 : 0;\n      const shiftKey = event.shiftKey ? 1 : 0;\n      const metaKey = event.metaKey ? 1 : 0;\n      const modifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n      const invalidModifierCombination = modifiersPressed && !event.ctrlKey || event.ctrlKey && event.keyCode !== KeyCode.home && event.keyCode !== KeyCode.end;\n      if (invalidModifierCombination || this.isElementSuppressed(document.activeElement) || !this.isRegistered(document.activeElement) || keys.indexOf(event.keyCode) === -1) {\n        return;\n      }\n      const from = this.focusedCell;\n      event.preventDefault();\n      isEventLike(event) && handleKey(event, {\n        onBlockStart: () => this.moveFocusBy(from, {\n          y: -1,\n          x: 0\n        }),\n        onBlockEnd: () => this.moveFocusBy(from, {\n          y: 1,\n          x: 0\n        }),\n        onInlineStart: () => this.moveFocusBy(from, {\n          y: 0,\n          x: -1\n        }),\n        onInlineEnd: () => this.moveFocusBy(from, {\n          y: 0,\n          x: 1\n        }),\n        onPageUp: () => this.moveFocusBy(from, {\n          y: -this.pageSize,\n          x: 0\n        }),\n        onPageDown: () => this.moveFocusBy(from, {\n          y: this.pageSize,\n          x: 0\n        }),\n        onHome: () => event.ctrlKey ? this.moveFocusBy(from, {\n          y: -Infinity,\n          x: -Infinity\n        }) : this.moveFocusBy(from, {\n          y: 0,\n          x: -Infinity\n        }),\n        onEnd: () => event.ctrlKey ? this.moveFocusBy(from, {\n          y: Infinity,\n          x: Infinity\n        }) : this.moveFocusBy(from, {\n          y: 0,\n          x: Infinity\n        })\n      });\n    };\n    this._navigationAPI = navigationAPI;\n  }\n  init(table) {\n    this._table = table;\n    this.table.addEventListener('focusin', this.onFocusin);\n    this.table.addEventListener('keydown', this.onKeydown);\n    this.cleanup = () => {\n      this.table.removeEventListener('focusin', this.onFocusin);\n      this.table.removeEventListener('keydown', this.onKeydown);\n    };\n  }\n  cleanup() {\n    // Do nothing before initialized.\n  }\n  update(_ref2) {\n    let {\n      pageSize\n    } = _ref2;\n    this._pageSize = pageSize;\n  }\n  refresh() {\n    // Timeout ensures the newly rendered content elements are registered.\n    setTimeout(() => {\n      var _a, _b;\n      if (this._table) {\n        // Update focused cell indices in case table rows, columns, or firstIndex change.\n        this.updateFocusedCell((_a = this.focusedCell) === null || _a === void 0 ? void 0 : _a.element);\n        (_b = this._navigationAPI.current) === null || _b === void 0 ? void 0 : _b.updateFocusTarget();\n      }\n    }, 0);\n  }\n  get pageSize() {\n    return this._pageSize;\n  }\n  get table() {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationProcessor is used before initialization.');\n    }\n    return this._table;\n  }\n  moveFocusBy(cell, delta) {\n    // For vertical moves preserve column- and element indices set by user.\n    // It allows keeping indices while moving over disabled actions or cells with colspan > 1.\n    if (delta.y !== 0 && delta.x === 0) {\n      this.keepUserIndex = true;\n    }\n    focusNextElement(this.getNextFocusable(cell, delta));\n  }\n  isRegistered(element) {\n    var _a, _b;\n    return !element || ((_b = (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element)) !== null && _b !== void 0 ? _b : false);\n  }\n  updateFocusedCell(focusedElement) {\n    var _a, _b, _c, _d, _e, _f;\n    if (!focusedElement) {\n      return;\n    }\n    const cellElement = getClosestCell(focusedElement);\n    const rowElement = cellElement === null || cellElement === void 0 ? void 0 : cellElement.closest('tr');\n    if (!cellElement || !rowElement) {\n      return;\n    }\n    const colIndex = parseInt((_a = cellElement.getAttribute('aria-colindex')) !== null && _a !== void 0 ? _a : '');\n    const rowIndex = parseInt((_b = rowElement.getAttribute('aria-rowindex')) !== null && _b !== void 0 ? _b : '');\n    if (isNaN(colIndex) || isNaN(rowIndex)) {\n      return;\n    }\n    const cellFocusables = this.getFocusablesFrom(cellElement);\n    const elementIndex = cellFocusables.indexOf(focusedElement);\n    const prevColIndex = (_d = (_c = this.focusedCell) === null || _c === void 0 ? void 0 : _c.colIndex) !== null && _d !== void 0 ? _d : -1;\n    const prevElementIndex = (_f = (_e = this.focusedCell) === null || _e === void 0 ? void 0 : _e.elementIndex) !== null && _f !== void 0 ? _f : -1;\n    this.focusedCell = {\n      rowIndex,\n      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,\n      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,\n      element: focusedElement\n    };\n  }\n  getNextFocusable(from, delta) {\n    var _a;\n    // Find next row to move focus into (can be null if the top/bottom is reached).\n    const targetAriaRowIndex = from.rowIndex + delta.y;\n    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);\n    if (!targetRow) {\n      return null;\n    }\n    // Return next interactive cell content element if available.\n    const cellElement = getClosestCell(from.element);\n    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];\n    const nextElementIndex = from.elementIndex + delta.x;\n    const isValidDirection = !!delta.x;\n    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;\n    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];\n    if (isValidDirection && isValidIndex && isTargetDifferent) {\n      return cellFocusables[nextElementIndex];\n    }\n    // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n    const targetAriaColIndex = from.colIndex + delta.x;\n    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n    if (!targetCell) {\n      return null;\n    }\n    // When target cell matches the current cell it means we reached the left or right boundary.\n    if (targetCell === cellElement && delta.x !== 0) {\n      return null;\n    }\n    const targetCellFocusables = this.getFocusablesFrom(targetCell);\n    // When delta.x = 0 keep element index if possible.\n    let focusIndex = from.elementIndex;\n    // Use first element index when moving to the right or to extreme left.\n    if (isFinite(delta.x) && delta.x > 0 || delta.x === -Infinity) {\n      focusIndex = 0;\n    }\n    // Use last element index when moving to the left or to extreme right.\n    if (isFinite(delta.x) && delta.x < 0 || delta.x === Infinity) {\n      focusIndex = targetCellFocusables.length - 1;\n    }\n    return (_a = targetCellFocusables[focusIndex]) !== null && _a !== void 0 ? _a : targetCell;\n  }\n  getFocusablesFrom(target) {\n    const isElementRegistered = element => {\n      var _a;\n      return (_a = this._navigationAPI.current) === null || _a === void 0 ? void 0 : _a.isRegistered(element);\n    };\n    return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));\n  }\n}","map":{"version":3,"names":["React","useRef","useEffect","useMemo","useStableCallback","getAllFocusables","SingleTabStopNavigationProvider","KeyCode","handleKey","isEventLike","nodeBelongs","defaultIsSuppressed","findTableRowByAriaRowIndex","findTableRowCellByAriaColIndex","focusNextElement","getClosestCell","isElementDisabled","isTableCell","GridNavigationProvider","_ref","keyboardNavigation","pageSize","getTable","children","navigationAPI","gridNavigation","GridNavigationProcessor","getTableStable","table","init","cleanup","update","refresh","createElement","ref","navigationActive","getNextFocusTarget","isElementSuppressed","onRegisterFocusable","onUnregisterActive","constructor","_pageSize","_table","focusedCell","keepUserIndex","focusableElement","focusedElement","_a","element","contains","focus","preventScroll","moveFocusBy","x","y","cell","firstTableCell","querySelector","focusTarget","getFocusablesFrom","getNextFocusable","onFocusin","event","target","HTMLElement","updateFocusedCell","_navigationAPI","current","updateFocusTarget","nextTarget","onKeydown","keys","up","down","left","right","pageUp","pageDown","home","end","ctrlKey","altKey","shiftKey","metaKey","modifiersPressed","invalidModifierCombination","keyCode","document","activeElement","isRegistered","indexOf","from","preventDefault","onBlockStart","onBlockEnd","onInlineStart","onInlineEnd","onPageUp","onPageDown","onHome","Infinity","onEnd","addEventListener","removeEventListener","_ref2","setTimeout","_b","Error","delta","cellElement","rowElement","closest","colIndex","parseInt","getAttribute","rowIndex","isNaN","cellFocusables","elementIndex","prevColIndex","_d","_c","prevElementIndex","_f","_e","targetAriaRowIndex","targetRow","nextElementIndex","isValidDirection","isValidIndex","length","isTargetDifferent","targetAriaColIndex","targetCell","targetCellFocusables","focusIndex","isFinite","isElementRegistered","filter","el"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/table/table-role/grid-navigation.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useRef } from 'react';\nimport { useEffect, useMemo } from 'react';\n\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getAllFocusables } from '../../internal/components/focus-lock/utils';\nimport {\n  SingleTabStopNavigationAPI,\n  SingleTabStopNavigationProvider,\n} from '../../internal/context/single-tab-stop-navigation-context';\nimport { KeyCode } from '../../internal/keycode';\nimport handleKey, { isEventLike } from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { FocusedCell, GridNavigationProps } from './interfaces';\nimport {\n  defaultIsSuppressed,\n  findTableRowByAriaRowIndex,\n  findTableRowCellByAriaColIndex,\n  focusNextElement,\n  getClosestCell,\n  isElementDisabled,\n  isTableCell,\n} from './utils';\n\n/**\n * Makes table navigable with keyboard commands.\n * See grid-navigation.md\n */\nexport function GridNavigationProvider({ keyboardNavigation, pageSize, getTable, children }: GridNavigationProps) {\n  const navigationAPI = useRef<SingleTabStopNavigationAPI>(null);\n  const gridNavigation = useMemo(() => new GridNavigationProcessor(navigationAPI), []);\n\n  const getTableStable = useStableCallback(getTable);\n\n  // Initialize the processor with the table container assuming it is mounted synchronously and only once.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      const table = getTableStable();\n      table && gridNavigation.init(table);\n    }\n    return () => gridNavigation.cleanup();\n  }, [keyboardNavigation, gridNavigation, getTableStable]);\n\n  // Notify the processor of the props change.\n  useEffect(() => {\n    gridNavigation.update({ pageSize });\n  }, [gridNavigation, pageSize]);\n\n  // Notify the processor of the new render.\n  useEffect(() => {\n    if (keyboardNavigation) {\n      gridNavigation.refresh();\n    }\n  });\n\n  return (\n    <SingleTabStopNavigationProvider\n      ref={navigationAPI}\n      navigationActive={keyboardNavigation}\n      getNextFocusTarget={gridNavigation.getNextFocusTarget}\n      isElementSuppressed={gridNavigation.isElementSuppressed}\n      onRegisterFocusable={gridNavigation.onRegisterFocusable}\n      onUnregisterActive={gridNavigation.onUnregisterActive}\n    >\n      {children}\n    </SingleTabStopNavigationProvider>\n  );\n}\n\n/**\n * This helper encapsulates the grid navigation behaviors which are:\n * 1. Responding to keyboard commands and moving the focus accordingly;\n * 2. Muting table interactive elements for only one to be user-focusable at a time;\n * 3. Suppressing the above behaviors when focusing an element inside a dialog or when instructed explicitly.\n */\nclass GridNavigationProcessor {\n  // Props\n  private _pageSize = 0;\n  private _table: null | HTMLTableElement = null;\n  private _navigationAPI: { current: null | SingleTabStopNavigationAPI };\n\n  // State\n  private focusedCell: null | FocusedCell = null;\n  private keepUserIndex = false;\n\n  constructor(navigationAPI: { current: null | SingleTabStopNavigationAPI }) {\n    this._navigationAPI = navigationAPI;\n  }\n\n  public init(table: HTMLTableElement) {\n    this._table = table;\n\n    this.table.addEventListener('focusin', this.onFocusin);\n    this.table.addEventListener('keydown', this.onKeydown);\n\n    this.cleanup = () => {\n      this.table.removeEventListener('focusin', this.onFocusin);\n      this.table.removeEventListener('keydown', this.onKeydown);\n    };\n  }\n\n  public cleanup() {\n    // Do nothing before initialized.\n  }\n\n  public update({ pageSize }: { pageSize: number }) {\n    this._pageSize = pageSize;\n  }\n\n  public refresh() {\n    // Timeout ensures the newly rendered content elements are registered.\n    setTimeout(() => {\n      if (this._table) {\n        // Update focused cell indices in case table rows, columns, or firstIndex change.\n        this.updateFocusedCell(this.focusedCell?.element);\n        this._navigationAPI.current?.updateFocusTarget();\n      }\n    }, 0);\n  }\n\n  public onRegisterFocusable = (focusableElement: HTMLElement) => {\n    // When newly registered element belongs to the focused cell the focus must transition to it.\n    const focusedElement = this.focusedCell?.element;\n    if (focusedElement && isTableCell(focusedElement) && focusedElement.contains(focusableElement)) {\n      // Scroll is unnecessary when moving focus from a cell to element within the cell.\n      focusableElement.focus({ preventScroll: true });\n    }\n  };\n\n  public onUnregisterActive = () => {\n    // If the focused cell appears to be no longer attached to the table we need to re-apply\n    // focus to a cell with the same or closest position.\n    if (this.focusedCell && !nodeBelongs(this.table, this.focusedCell.element)) {\n      this.moveFocusBy(this.focusedCell, { x: 0, y: 0 });\n    }\n  };\n\n  public getNextFocusTarget = () => {\n    const cell = this.focusedCell;\n    const firstTableCell = this.table.querySelector('td,th') as null | HTMLTableCellElement;\n\n    // A single element of the table is made user-focusable.\n    // It defaults to the first interactive element of the first cell or the first cell itself otherwise.\n    let focusTarget: null | HTMLElement =\n      (firstTableCell && this.getFocusablesFrom(firstTableCell)[0]) ?? firstTableCell;\n\n    // When a navigation-focused element is present in the table it is used for user-navigation instead.\n    if (cell) {\n      focusTarget = this.getNextFocusable(cell, { x: 0, y: 0 });\n    }\n\n    return focusTarget;\n  };\n\n  public isElementSuppressed = (element: null | Element) => {\n    // Omit calculation as irrelevant until the table receives focus.\n    if (!this.focusedCell) {\n      return false;\n    }\n    return !element || defaultIsSuppressed(element);\n  };\n\n  private get pageSize() {\n    return this._pageSize;\n  }\n\n  private get table(): HTMLTableElement {\n    if (!this._table) {\n      throw new Error('Invariant violation: GridNavigationProcessor is used before initialization.');\n    }\n    return this._table;\n  }\n\n  private onFocusin = (event: FocusEvent) => {\n    if (!(event.target instanceof HTMLElement)) {\n      return;\n    }\n\n    this.updateFocusedCell(event.target);\n    if (!this.focusedCell) {\n      return;\n    }\n\n    this._navigationAPI.current?.updateFocusTarget();\n\n    // Focusing on cell is not eligible when it contains focusable elements in the content.\n    // If content focusables are available - move the focus to the first one.\n    const focusedElement = this.focusedCell.element;\n    const nextTarget = isTableCell(focusedElement) ? this.getFocusablesFrom(focusedElement)[0] : null;\n    if (nextTarget) {\n      // Scroll is unnecessary when moving focus from a cell to element within the cell.\n      nextTarget.focus({ preventScroll: true });\n    } else {\n      this.keepUserIndex = false;\n    }\n  };\n\n  private onKeydown = (event: KeyboardEvent) => {\n    if (!this.focusedCell) {\n      return;\n    }\n\n    const keys = [\n      KeyCode.up,\n      KeyCode.down,\n      KeyCode.left,\n      KeyCode.right,\n      KeyCode.pageUp,\n      KeyCode.pageDown,\n      KeyCode.home,\n      KeyCode.end,\n    ];\n    const ctrlKey = event.ctrlKey ? 1 : 0;\n    const altKey = event.altKey ? 1 : 0;\n    const shiftKey = event.shiftKey ? 1 : 0;\n    const metaKey = event.metaKey ? 1 : 0;\n    const modifiersPressed = ctrlKey + altKey + shiftKey + metaKey;\n    const invalidModifierCombination =\n      (modifiersPressed && !event.ctrlKey) ||\n      (event.ctrlKey && event.keyCode !== KeyCode.home && event.keyCode !== KeyCode.end);\n\n    if (\n      invalidModifierCombination ||\n      this.isElementSuppressed(document.activeElement) ||\n      !this.isRegistered(document.activeElement) ||\n      keys.indexOf(event.keyCode) === -1\n    ) {\n      return;\n    }\n\n    const from = this.focusedCell;\n    event.preventDefault();\n\n    isEventLike(event) &&\n      handleKey(event, {\n        onBlockStart: () => this.moveFocusBy(from, { y: -1, x: 0 }),\n        onBlockEnd: () => this.moveFocusBy(from, { y: 1, x: 0 }),\n        onInlineStart: () => this.moveFocusBy(from, { y: 0, x: -1 }),\n        onInlineEnd: () => this.moveFocusBy(from, { y: 0, x: 1 }),\n        onPageUp: () => this.moveFocusBy(from, { y: -this.pageSize, x: 0 }),\n        onPageDown: () => this.moveFocusBy(from, { y: this.pageSize, x: 0 }),\n        onHome: () =>\n          event.ctrlKey\n            ? this.moveFocusBy(from, { y: -Infinity, x: -Infinity })\n            : this.moveFocusBy(from, { y: 0, x: -Infinity }),\n        onEnd: () =>\n          event.ctrlKey\n            ? this.moveFocusBy(from, { y: Infinity, x: Infinity })\n            : this.moveFocusBy(from, { y: 0, x: Infinity }),\n      });\n  };\n\n  private moveFocusBy(cell: FocusedCell, delta: { x: number; y: number }) {\n    // For vertical moves preserve column- and element indices set by user.\n    // It allows keeping indices while moving over disabled actions or cells with colspan > 1.\n    if (delta.y !== 0 && delta.x === 0) {\n      this.keepUserIndex = true;\n    }\n    focusNextElement(this.getNextFocusable(cell, delta));\n  }\n\n  private isRegistered(element: null | Element): boolean {\n    return !element || (this._navigationAPI.current?.isRegistered(element) ?? false);\n  }\n\n  private updateFocusedCell(focusedElement?: HTMLElement): void {\n    if (!focusedElement) {\n      return;\n    }\n\n    const cellElement = getClosestCell(focusedElement);\n    const rowElement = cellElement?.closest('tr');\n    if (!cellElement || !rowElement) {\n      return;\n    }\n\n    const colIndex = parseInt(cellElement.getAttribute('aria-colindex') ?? '');\n    const rowIndex = parseInt(rowElement.getAttribute('aria-rowindex') ?? '');\n    if (isNaN(colIndex) || isNaN(rowIndex)) {\n      return;\n    }\n\n    const cellFocusables = this.getFocusablesFrom(cellElement);\n    const elementIndex = cellFocusables.indexOf(focusedElement);\n\n    const prevColIndex = this.focusedCell?.colIndex ?? -1;\n    const prevElementIndex = this.focusedCell?.elementIndex ?? -1;\n    this.focusedCell = {\n      rowIndex,\n      colIndex: this.keepUserIndex && prevColIndex !== -1 ? prevColIndex : colIndex,\n      elementIndex: this.keepUserIndex && prevElementIndex !== -1 ? prevElementIndex : elementIndex,\n      element: focusedElement,\n    };\n  }\n\n  private getNextFocusable(from: FocusedCell, delta: { y: number; x: number }) {\n    // Find next row to move focus into (can be null if the top/bottom is reached).\n    const targetAriaRowIndex = from.rowIndex + delta.y;\n    const targetRow = findTableRowByAriaRowIndex(this.table, targetAriaRowIndex, delta.y);\n    if (!targetRow) {\n      return null;\n    }\n\n    // Return next interactive cell content element if available.\n    const cellElement = getClosestCell(from.element);\n    const cellFocusables = cellElement ? this.getFocusablesFrom(cellElement) : [];\n    const nextElementIndex = from.elementIndex + delta.x;\n    const isValidDirection = !!delta.x;\n    const isValidIndex = from.elementIndex !== -1 && 0 <= nextElementIndex && nextElementIndex < cellFocusables.length;\n    const isTargetDifferent = from.element !== cellFocusables[nextElementIndex];\n    if (isValidDirection && isValidIndex && isTargetDifferent) {\n      return cellFocusables[nextElementIndex];\n    }\n\n    // Find next cell to focus or move focus into (can be null if the left/right edge is reached).\n    const targetAriaColIndex = from.colIndex + delta.x;\n    const targetCell = findTableRowCellByAriaColIndex(targetRow, targetAriaColIndex, delta.x);\n    if (!targetCell) {\n      return null;\n    }\n\n    // When target cell matches the current cell it means we reached the left or right boundary.\n    if (targetCell === cellElement && delta.x !== 0) {\n      return null;\n    }\n\n    const targetCellFocusables = this.getFocusablesFrom(targetCell);\n\n    // When delta.x = 0 keep element index if possible.\n    let focusIndex = from.elementIndex;\n    // Use first element index when moving to the right or to extreme left.\n    if ((isFinite(delta.x) && delta.x > 0) || delta.x === -Infinity) {\n      focusIndex = 0;\n    }\n    // Use last element index when moving to the left or to extreme right.\n    if ((isFinite(delta.x) && delta.x < 0) || delta.x === Infinity) {\n      focusIndex = targetCellFocusables.length - 1;\n    }\n\n    return targetCellFocusables[focusIndex] ?? targetCell;\n  }\n\n  private getFocusablesFrom(target: HTMLElement) {\n    const isElementRegistered = (element: Element) => this._navigationAPI.current?.isRegistered(element);\n    return getAllFocusables(target).filter(el => isElementRegistered(el) && !isElementDisabled(el));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}