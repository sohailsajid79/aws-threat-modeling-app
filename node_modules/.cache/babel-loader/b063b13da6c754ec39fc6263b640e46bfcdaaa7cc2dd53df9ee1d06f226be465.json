{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getLogicalBoundingClientRect, getScrollInlineStart } from '@cloudscape-design/component-toolkit/internal';\nimport AsyncStore from '../../area-chart/async-store';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\nexport function useStickyColumns(_ref) {\n  let {\n    visibleColumns,\n    stickyColumnsFirst,\n    stickyColumnsLast\n  } = _ref;\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef(null);\n  const tableRef = useRef(null);\n  const cellsRef = useRef(new Map());\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast\n      });\n    }\n  });\n  useResizeObserver(wrapperRef, updateStickyStyles);\n  useResizeObserver(tableRef, updateStickyStyles);\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n    const selector = state => state.wrapperState;\n    const updateWrapperStyles = (state, prev) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingInlineStart = state.scrollPaddingInlineStart + 'px';\n        wrapperRef.current.style.scrollPaddingInlineEnd = state.scrollPaddingInlineEnd + 'px';\n      }\n    };\n    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n  const setWrapper = useCallback(node => {\n    if (wrapperRef.current) {\n      wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n    }\n    if (node && hasStickyColumns) {\n      node.addEventListener('scroll', updateStickyStyles);\n    }\n    wrapperRef.current = node;\n  }, [hasStickyColumns, updateStickyStyles]);\n  const setTable = useCallback(node => {\n    tableRef.current = node;\n  }, []);\n  const setCell = useCallback((columnId, node) => {\n    if (node) {\n      cellsRef.current.set(columnId, node);\n    } else {\n      cellsRef.current.delete(columnId);\n    }\n  }, []);\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : undefined\n    },\n    refs: {\n      wrapper: setWrapper,\n      table: setTable,\n      cell: setCell\n    }\n  };\n}\nexport function useStickyCellStyles(_ref2) {\n  let {\n    stickyColumns,\n    columnId,\n    getClassName\n  } = _ref2;\n  var _a;\n  const setCell = stickyColumns.refs.cell;\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef(null);\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(cellElement => {\n    if (unsubscribeRef.current) {\n      // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n      unsubscribeRef.current();\n    }\n    // Update cellRef and the store's state to point to the new DOM node\n    setCell(columnId, cellElement);\n    // Update cell styles imperatively to avoid unnecessary re-renders.\n    const selector = state => {\n      var _a;\n      return (_a = state.cellState.get(columnId)) !== null && _a !== void 0 ? _a : null;\n    };\n    const updateCellStyles = (state, prev) => {\n      if (isCellStatesEqual(state, prev)) {\n        return;\n      }\n      const className = getClassName(state);\n      if (cellElement) {\n        Object.keys(className).forEach(key => {\n          if (className[key]) {\n            cellElement.classList.add(key);\n          } else {\n            cellElement.classList.remove(key);\n          }\n        });\n        cellElement.style.insetInlineStart = (state === null || state === void 0 ? void 0 : state.offset.insetInlineStart) !== undefined ? `${state.offset.insetInlineStart}px` : '';\n        cellElement.style.insetInlineEnd = (state === null || state === void 0 ? void 0 : state.offset.insetInlineEnd) !== undefined ? `${state.offset.insetInlineEnd}px` : '';\n      }\n    };\n    // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n    // set up a new subscription to the store's updates\n    if (cellElement) {\n      unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n        updateCellStyles(selector(newState), selector(prevState));\n      });\n    }\n  },\n  // getClassName is expected to be pure\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [columnId, setCell, stickyColumns.store]);\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState.get(columnId);\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : undefined\n  };\n}\nexport default class StickyColumnsStore extends AsyncStore {\n  constructor() {\n    super({\n      cellState: new Map(),\n      wrapperState: {\n        scrollPaddingInlineStart: 0,\n        scrollPaddingInlineEnd: 0\n      }\n    });\n    this.cellOffsets = {\n      offsets: new Map(),\n      stickyWidthInlineStart: 0,\n      stickyWidthInlineEnd: 0\n    };\n    this.isStuckToTheInlineStart = false;\n    this.isStuckToTheInlineEnd = false;\n    this.padInlineStart = false;\n    this.generateCellStyles = props => {\n      const isEnabled = this.isEnabled(props);\n      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n      return props.visibleColumns.reduce((acc, columnId, index) => {\n        var _a, _b, _c, _d;\n        let stickySide = 'non-sticky';\n        if (index < props.stickyColumnsFirst) {\n          stickySide = 'inline-start';\n        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n          stickySide = 'inline-end';\n        }\n        if (!isEnabled || stickySide === 'non-sticky') {\n          return acc;\n        }\n        // Determine the offset of the sticky column using the `cellOffsets` state object\n        const isFirstColumn = index === 0;\n        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.offsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;\n        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.offsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;\n        acc.set(columnId, {\n          padInlineStart: isFirstColumn && this.padInlineStart,\n          lastInsetInlineStart: this.isStuckToTheInlineStart && lastLeftStickyColumnIndex === index,\n          lastInsetInlineEnd: this.isStuckToTheInlineEnd && lastRightStickyColumnIndex === index,\n          offset: {\n            insetInlineStart: stickySide === 'inline-start' ? stickyColumnOffsetLeft : undefined,\n            insetInlineEnd: stickySide === 'inline-end' ? stickyColumnOffsetRight : undefined\n          }\n        });\n        return acc;\n      }, new Map());\n    };\n    this.updateCellOffsets = props => {\n      this.cellOffsets = updateCellOffsets(props.cells, props);\n    };\n    this.isEnabled = props => {\n      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n      if (noStickyColumns) {\n        return false;\n      }\n      const wrapperWidth = getLogicalBoundingClientRect(props.wrapper).inlineSize;\n      const tableWidth = getLogicalBoundingClientRect(props.table).inlineSize;\n      const isWrapperScrollable = tableWidth > wrapperWidth;\n      if (!isWrapperScrollable) {\n        return false;\n      }\n      const totalStickySpace = this.cellOffsets.stickyWidthInlineStart + this.cellOffsets.stickyWidthInlineEnd;\n      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n      if (!hasEnoughScrollableSpace) {\n        return false;\n      }\n      return true;\n    };\n  }\n  updateCellStyles(props) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingInlineStart: this.cellOffsets.stickyWidthInlineStart,\n          scrollPaddingInlineEnd: this.cellOffsets.stickyWidthInlineEnd\n        }\n      }));\n    }\n  }\n  updateScroll(props) {\n    const wrapperScrollInlineStart = getScrollInlineStart(props.wrapper);\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingInlineStart = parseFloat(getComputedStyle(props.table).paddingInlineStart) || 0;\n    const tablePaddingInlineEnd = parseFloat(getComputedStyle(props.table).paddingInlineEnd) || 0;\n    this.isStuckToTheInlineStart = wrapperScrollInlineStart > tablePaddingInlineStart;\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollInlineStart values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheInlineEnd = Math.ceil(wrapperScrollInlineStart) < wrapperScrollWidth - wrapperClientWidth - tablePaddingInlineEnd;\n    this.padInlineStart = tablePaddingInlineStart !== 0 && this.isStuckToTheInlineStart;\n  }\n}","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","clsx","useResizeObserver","useStableCallback","getLogicalBoundingClientRect","getScrollInlineStart","AsyncStore","isCellStatesEqual","isWrapperStatesEqual","updateCellOffsets","MINIMUM_SCROLLABLE_SPACE","useStickyColumns","_ref","visibleColumns","stickyColumnsFirst","stickyColumnsLast","store","StickyColumnsStore","wrapperRef","tableRef","cellsRef","Map","hasStickyColumns","updateStickyStyles","current","updateCellStyles","wrapper","table","cells","selector","state","wrapperState","updateWrapperStyles","prev","style","scrollPaddingInlineStart","scrollPaddingInlineEnd","unsubscribe","subscribe","newState","prevState","setWrapper","node","removeEventListener","addEventListener","setTable","setCell","columnId","set","delete","Object","assign","get","undefined","refs","cell","useStickyCellStyles","_ref2","stickyColumns","getClassName","unsubscribeRef","refCallback","cellElement","_a","cellState","className","keys","forEach","key","classList","add","remove","insetInlineStart","offset","insetInlineEnd","cellStyles","ref","constructor","cellOffsets","offsets","stickyWidthInlineStart","stickyWidthInlineEnd","isStuckToTheInlineStart","isStuckToTheInlineEnd","padInlineStart","generateCellStyles","props","isEnabled","lastLeftStickyColumnIndex","lastRightStickyColumnIndex","length","reduce","acc","index","stickySide","isFirstColumn","stickyColumnOffsetLeft","_b","first","stickyColumnOffsetRight","_d","_c","last","lastInsetInlineStart","lastInsetInlineEnd","noStickyColumns","wrapperWidth","inlineSize","tableWidth","isWrapperScrollable","totalStickySpace","tablePaddingLeft","parseFloat","getComputedStyle","paddingLeft","tablePaddingRight","paddingRight","hasEnoughScrollableSpace","hadStickyColumns","size","updateScroll","wrapperScrollInlineStart","wrapperScrollWidth","scrollWidth","wrapperClientWidth","clientWidth","tablePaddingInlineStart","paddingInlineStart","tablePaddingInlineEnd","paddingInlineEnd","Math","ceil"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/table/sticky-columns/use-sticky-columns.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getLogicalBoundingClientRect, getScrollInlineStart } from '@cloudscape-design/component-toolkit/internal';\n\nimport AsyncStore, { ReadonlyAsyncStore } from '../../area-chart/async-store';\nimport {\n  CellOffsets,\n  StickyColumnsCellState,\n  StickyColumnsProps,\n  StickyColumnsState,\n  StickyColumnsWrapperState,\n} from './interfaces';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\n\nexport interface StickyColumnsModel {\n  store: ReadonlyAsyncStore<StickyColumnsState>;\n  style: {\n    wrapper?: React.CSSProperties;\n  };\n  refs: {\n    table: React.RefCallback<HTMLElement>;\n    wrapper: React.RefCallback<HTMLElement>;\n    cell: (columnId: PropertyKey, node: null | HTMLElement) => void;\n  };\n}\n\nexport function useStickyColumns({\n  visibleColumns,\n  stickyColumnsFirst,\n  stickyColumnsLast,\n}: StickyColumnsProps): StickyColumnsModel {\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const tableRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const cellsRef = useRef(new Map<PropertyKey, HTMLElement>());\n\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  });\n\n  useResizeObserver(wrapperRef, updateStickyStyles);\n\n  useResizeObserver(tableRef, updateStickyStyles);\n\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n\n    const selector = (state: StickyColumnsState) => state.wrapperState;\n\n    const updateWrapperStyles = (state: StickyColumnsWrapperState, prev: StickyColumnsWrapperState) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingInlineStart = state.scrollPaddingInlineStart + 'px';\n        wrapperRef.current.style.scrollPaddingInlineEnd = state.scrollPaddingInlineEnd + 'px';\n      }\n    };\n\n    const unsubscribe = store.subscribe(selector, (newState, prevState) =>\n      updateWrapperStyles(selector(newState), selector(prevState))\n    );\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n\n  const setWrapper = useCallback(\n    (node: null | HTMLElement) => {\n      if (wrapperRef.current) {\n        wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n      }\n      if (node && hasStickyColumns) {\n        node.addEventListener('scroll', updateStickyStyles);\n      }\n      wrapperRef.current = node;\n    },\n    [hasStickyColumns, updateStickyStyles]\n  );\n\n  const setTable = useCallback((node: null | HTMLElement) => {\n    tableRef.current = node;\n  }, []);\n\n  const setCell = useCallback((columnId: PropertyKey, node: null | HTMLElement) => {\n    if (node) {\n      cellsRef.current.set(columnId, node);\n    } else {\n      cellsRef.current.delete(columnId);\n    }\n  }, []);\n\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? { ...store.get().wrapperState } : undefined,\n    },\n    refs: { wrapper: setWrapper, table: setTable, cell: setCell },\n  };\n}\n\ninterface UseStickyCellStylesProps {\n  stickyColumns: StickyColumnsModel;\n  columnId: PropertyKey;\n  getClassName: (styles: null | StickyColumnsCellState) => Record<string, boolean>;\n}\n\ninterface StickyCellStyles {\n  ref: React.RefCallback<HTMLElement>;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function useStickyCellStyles({\n  stickyColumns,\n  columnId,\n  getClassName,\n}: UseStickyCellStylesProps): StickyCellStyles {\n  const setCell = stickyColumns.refs.cell;\n\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef<null | (() => void)>(null);\n\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(\n    (cellElement: null | HTMLElement) => {\n      if (unsubscribeRef.current) {\n        // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n        unsubscribeRef.current();\n      }\n\n      // Update cellRef and the store's state to point to the new DOM node\n      setCell(columnId, cellElement);\n\n      // Update cell styles imperatively to avoid unnecessary re-renders.\n      const selector = (state: StickyColumnsState) => state.cellState.get(columnId) ?? null;\n\n      const updateCellStyles = (state: null | StickyColumnsCellState, prev: null | StickyColumnsCellState) => {\n        if (isCellStatesEqual(state, prev)) {\n          return;\n        }\n\n        const className = getClassName(state);\n        if (cellElement) {\n          Object.keys(className).forEach(key => {\n            if (className[key]) {\n              cellElement.classList.add(key);\n            } else {\n              cellElement.classList.remove(key);\n            }\n          });\n          cellElement.style.insetInlineStart =\n            state?.offset.insetInlineStart !== undefined ? `${state.offset.insetInlineStart}px` : '';\n          cellElement.style.insetInlineEnd =\n            state?.offset.insetInlineEnd !== undefined ? `${state.offset.insetInlineEnd}px` : '';\n        }\n      };\n\n      // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n      // set up a new subscription to the store's updates\n      if (cellElement) {\n        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n          updateCellStyles(selector(newState), selector(prevState));\n        });\n      }\n    },\n\n    // getClassName is expected to be pure\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [columnId, setCell, stickyColumns.store]\n  );\n\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState.get(columnId);\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: cellStyles?.offset ?? undefined,\n  };\n}\n\ninterface UpdateCellStylesProps {\n  wrapper: HTMLElement;\n  table: HTMLElement;\n  cells: Map<PropertyKey, HTMLElement>;\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport default class StickyColumnsStore extends AsyncStore<StickyColumnsState> {\n  private cellOffsets: CellOffsets = {\n    offsets: new Map(),\n    stickyWidthInlineStart: 0,\n    stickyWidthInlineEnd: 0,\n  };\n  private isStuckToTheInlineStart = false;\n  private isStuckToTheInlineEnd = false;\n  private padInlineStart = false;\n\n  constructor() {\n    super({ cellState: new Map(), wrapperState: { scrollPaddingInlineStart: 0, scrollPaddingInlineEnd: 0 } });\n  }\n\n  public updateCellStyles(props: UpdateCellStylesProps) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingInlineStart: this.cellOffsets.stickyWidthInlineStart,\n          scrollPaddingInlineEnd: this.cellOffsets.stickyWidthInlineEnd,\n        },\n      }));\n    }\n  }\n\n  private updateScroll(props: UpdateCellStylesProps) {\n    const wrapperScrollInlineStart = getScrollInlineStart(props.wrapper);\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingInlineStart = parseFloat(getComputedStyle(props.table).paddingInlineStart) || 0;\n    const tablePaddingInlineEnd = parseFloat(getComputedStyle(props.table).paddingInlineEnd) || 0;\n\n    this.isStuckToTheInlineStart = wrapperScrollInlineStart > tablePaddingInlineStart;\n\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollInlineStart values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheInlineEnd =\n      Math.ceil(wrapperScrollInlineStart) < wrapperScrollWidth - wrapperClientWidth - tablePaddingInlineEnd;\n\n    this.padInlineStart = tablePaddingInlineStart !== 0 && this.isStuckToTheInlineStart;\n  }\n\n  private generateCellStyles = (props: UpdateCellStylesProps): Map<PropertyKey, StickyColumnsCellState> => {\n    const isEnabled = this.isEnabled(props);\n    const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n    const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n\n    return props.visibleColumns.reduce((acc, columnId, index) => {\n      let stickySide = 'non-sticky';\n      if (index < props.stickyColumnsFirst) {\n        stickySide = 'inline-start';\n      } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n        stickySide = 'inline-end';\n      }\n\n      if (!isEnabled || stickySide === 'non-sticky') {\n        return acc;\n      }\n\n      // Determine the offset of the sticky column using the `cellOffsets` state object\n      const isFirstColumn = index === 0;\n      const stickyColumnOffsetLeft = this.cellOffsets.offsets.get(columnId)?.first ?? 0;\n      const stickyColumnOffsetRight = this.cellOffsets.offsets.get(columnId)?.last ?? 0;\n\n      acc.set(columnId, {\n        padInlineStart: isFirstColumn && this.padInlineStart,\n        lastInsetInlineStart: this.isStuckToTheInlineStart && lastLeftStickyColumnIndex === index,\n        lastInsetInlineEnd: this.isStuckToTheInlineEnd && lastRightStickyColumnIndex === index,\n        offset: {\n          insetInlineStart: stickySide === 'inline-start' ? stickyColumnOffsetLeft : undefined,\n          insetInlineEnd: stickySide === 'inline-end' ? stickyColumnOffsetRight : undefined,\n        },\n      });\n      return acc;\n    }, new Map<PropertyKey, StickyColumnsCellState>());\n  };\n\n  private updateCellOffsets = (props: UpdateCellStylesProps): void => {\n    this.cellOffsets = updateCellOffsets(props.cells, props);\n  };\n\n  private isEnabled = (props: UpdateCellStylesProps): boolean => {\n    const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n    if (noStickyColumns) {\n      return false;\n    }\n\n    const wrapperWidth = getLogicalBoundingClientRect(props.wrapper).inlineSize;\n    const tableWidth = getLogicalBoundingClientRect(props.table).inlineSize;\n    const isWrapperScrollable = tableWidth > wrapperWidth;\n    if (!isWrapperScrollable) {\n      return false;\n    }\n\n    const totalStickySpace = this.cellOffsets.stickyWidthInlineStart + this.cellOffsets.stickyWidthInlineEnd;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    const hasEnoughScrollableSpace =\n      totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n    if (!hasEnoughScrollableSpace) {\n      return false;\n    }\n\n    return true;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}