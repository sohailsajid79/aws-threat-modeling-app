{"ast":null,"code":"// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX(series) {\n  const xValues = getXValues(series);\n  if (xValues.length === 0) {\n    return [];\n  }\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues);\n  }\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce((_ref, x) => {\n    let [min, max] = _ref;\n    return [x < min ? x : min, max < x ? x : max];\n  }, [xValues[0], xValues[0]]);\n}\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY(series, scaleType) {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    var _a;\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n  return [min, max];\n}\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints(series, xScale, yScale) {\n  const xValues = getXValues(series);\n  // Lookup for xy[xIndex][yIndex]\n  const xy = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx = [];\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach((_ref2, xIndex) => {\n    let {\n      x,\n      scaledX\n    } = _ref2;\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n    // A column of series points related to the same x.\n    const points = [];\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      var _a;\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: {\n            x: scaledX,\n            y0: scaledY,\n            y1: scaledY\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: 0\n        });\n      } else {\n        const value = ((_a = s.data[xIndex]) === null || _a === void 0 ? void 0 : _a.y) || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: {\n            x: scaledX,\n            y0: yScale.d3Scale(y0) || 0,\n            y1: yScale.d3Scale(y1) || 0\n          },\n          index: {\n            x: xIndex,\n            s: sIndex,\n            y: 0\n          },\n          value: value\n        });\n        stackY = y1;\n      }\n    });\n    // Sort points by y and insert the missing y-index.\n    points.sort((p1, p2) => p1.y1 - p2.y1).forEach((point, index) => {\n      point.index.y = index;\n      // Insert the points to the respective two-dimensional lookup arrays.\n      insertIntoMatrix(xy, point.index.x, point.index.y, point);\n      insertIntoMatrix(xs, point.index.x, point.index.s, point);\n      insertIntoMatrix(sx, point.index.s, point.index.x, point);\n    });\n  });\n  return {\n    xy,\n    xs,\n    sx\n  };\n}\n// Finds the closest point in the sorted array.\nexport function findClosest(sortedArray, target, getter) {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = x => isAscending ? getter(x) < target : getter(x) > target;\n  const delta = x => Math.abs(getter(x) - target);\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid(series) {\n  var _a;\n  const sampleXValues = getXValues(series);\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (((_a = s.data[i]) === null || _a === void 0 ? void 0 : _a.x) !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues(series) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(_ref3 => {\n        let {\n          x\n        } = _ref3;\n        return x;\n      });\n    }\n  }\n  return [];\n}\n// Returns data that is visible in the given scale.\nfunction getVisibleData(data, xScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x);\n    if (scaledX !== undefined) {\n      visibleData.push({\n        x,\n        scaledX: scaledX + scaledOffsetX\n      });\n    }\n  }\n  return visibleData;\n}\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix(matrix, row, col, value) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n// Creates new array with only unique elements of the given array.\nfunction uniq(arr) {\n  const set = new Set();\n  const uniqArray = [];\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n  return uniqArray;\n}","map":{"version":3,"names":["EPSILON","computeDomainX","series","xValues","getXValues","length","uniq","reduce","_ref","x","min","max","computeDomainY","scaleType","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","forEach","s","type","Math","y","_","xIndex","stackY","_a","data","computePlotPoints","xScale","yScale","xy","xs","sx","getVisibleData","_ref2","scaledX","points","sIndex","scaledY","d3Scale","push","y0","y1","scaled","index","value","sort","p1","p2","point","insertIntoMatrix","findClosest","sortedArray","target","getter","Error","isAscending","compare","delta","abs","lo","hi","mid","floor","isSeriesValid","sampleXValues","i","map","_ref3","scaledOffsetX","isCategorical","bandwidth","visibleData","undefined","matrix","row","col","arr","set","Set","uniqArray","has","add"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/area-chart/model/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartDataTypes, XDomain, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { AreaChartProps } from '../interfaces';\nimport { ChartModel } from './index';\n\n// A sufficiently small value.\n// The Number.EPSILON is not available in the target ECMA version.\n// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\nconst EPSILON = 0.0000000000001;\n\n// When x-domain is not set explicitly - guess it based on the available data.\nexport function computeDomainX<T extends ChartDataTypes>(series: readonly AreaChartProps.Series<T>[]): XDomain<T> {\n  const xValues = getXValues(series);\n\n  if (xValues.length === 0) {\n    return [] as unknown as XDomain<T>;\n  }\n\n  // Assuming categorical domain.\n  // In that case, all values are to be included.\n  if (typeof xValues[0] === 'string') {\n    return uniq(xValues) as unknown as XDomain<T>;\n  }\n\n  // For non-categorical domain find min and max bounds.\n  return xValues.reduce(\n    ([min, max], x) => [x < min ? x : min, max < x ? x : max],\n    [xValues[0], xValues[0]]\n  ) as unknown as XDomain<T>;\n}\n\n// When y-domain is not set explicitly - guess it based on the available data and series.\nexport function computeDomainY<T>(series: readonly AreaChartProps.Series<T>[], scaleType: YScaleType): YDomain {\n  let min = Number.POSITIVE_INFINITY;\n  let max = Number.NEGATIVE_INFINITY;\n\n  // Find the min and max for threshold series.\n  series.forEach(s => {\n    if (s.type === 'threshold') {\n      min = Math.min(min, s.y);\n      max = Math.max(max, s.y);\n    }\n  });\n\n  // Find the min and max for area series considering their stacking.\n  getXValues(series).forEach((_, xIndex) => {\n    // Maintains the prev stack level.\n    let stackY = scaleType === 'linear' ? 0 : EPSILON;\n\n    for (const s of series) {\n      if (s.type === 'area') {\n        stackY = stackY + (s.data[xIndex]?.y || 0);\n        min = Math.min(min, stackY);\n        max = Math.max(max, stackY);\n      }\n    }\n  });\n\n  // If min/max is not overridden than either series or series data is empty.\n  if (min === Number.POSITIVE_INFINITY) {\n    return [];\n  }\n\n  // Log scales can't start from 0, so, if possible, start from 1.\n  if (scaleType === 'log' && min === 0 && max > 1) {\n    return [1, max];\n  }\n\n  return [min, max];\n}\n\n// For given data, series and scales, compute all points and group them as\n// x:y, x:series and series:x to allow constant time access to the required point or subset.\nexport function computePlotPoints<T>(\n  series: readonly AreaChartProps.Series<T>[],\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): {\n  xy: ChartModel.PlotPoint<T>[][];\n  xs: ChartModel.PlotPoint<T>[][];\n  sx: ChartModel.PlotPoint<T>[][];\n} {\n  const xValues = getXValues(series);\n\n  // Lookup for xy[xIndex][yIndex]\n  const xy: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for xs[xIndex][seriesIndex]\n  const xs: ChartModel.PlotPoint<T>[][] = [];\n  // Lookup for sx[seriesIndex][xIndex]\n  const sx: ChartModel.PlotPoint<T>[][] = [];\n\n  // Filter out the data which is beyond the plot for whatever reason.\n  getVisibleData(xValues, xScale).forEach(({ x, scaledX }, xIndex) => {\n    // Maintains the prev stack level. Starting from epsilon to not break log scales.\n    let stackY = yScale.scaleType === 'linear' ? 0 : EPSILON;\n\n    // A column of series points related to the same x.\n    const points: ChartModel.PlotPoint<T>[] = [];\n\n    // Collect the points, leaving y-index as 0 for now.\n    series.forEach((s, sIndex) => {\n      if (s.type === 'threshold') {\n        const scaledY = yScale.d3Scale(s.y) || 0;\n        points.push({\n          x: x,\n          y0: s.y,\n          y1: s.y,\n          scaled: { x: scaledX, y0: scaledY, y1: scaledY },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: 0,\n        });\n      } else {\n        const value = s.data[xIndex]?.y || 0;\n        const y0 = stackY;\n        const y1 = stackY + value;\n        points.push({\n          x: x,\n          y0: y0,\n          y1: y1,\n          scaled: { x: scaledX, y0: yScale.d3Scale(y0) || 0, y1: yScale.d3Scale(y1) || 0 },\n          index: { x: xIndex, s: sIndex, y: 0 },\n          value: value,\n        });\n\n        stackY = y1;\n      }\n    });\n\n    // Sort points by y and insert the missing y-index.\n    points\n      .sort((p1, p2) => p1.y1 - p2.y1)\n      .forEach((point, index) => {\n        point.index.y = index;\n\n        // Insert the points to the respective two-dimensional lookup arrays.\n        insertIntoMatrix(xy, point.index.x, point.index.y, point);\n        insertIntoMatrix(xs, point.index.x, point.index.s, point);\n        insertIntoMatrix(sx, point.index.s, point.index.x, point);\n      });\n  });\n\n  return { xy, xs, sx };\n}\n\n// Finds the closest point in the sorted array.\nexport function findClosest<T>(sortedArray: readonly T[], target: number, getter: (item: T) => number): T {\n  // The method guarantees to return a point hence empty arrays are not allowed.\n  if (sortedArray.length === 0) {\n    throw new Error('Invariant violation: array is empty.');\n  }\n\n  const isAscending = getter(sortedArray[0]) < getter(sortedArray[sortedArray.length - 1]);\n  const compare = (x: T) => (isAscending ? getter(x) < target : getter(x) > target);\n  const delta = (x: T) => Math.abs(getter(x) - target);\n\n  // Use binary search to find the closest value in a sorted array.\n  let lo = 0;\n  let hi = sortedArray.length - 1;\n  while (hi - lo > 1) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (compare(sortedArray[mid])) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return delta(sortedArray[lo]) < delta(sortedArray[hi]) ? sortedArray[lo] : sortedArray[hi];\n}\n\n// Compares all x-values between series to ensure they are consistent.\nexport function isSeriesValid<T>(series: readonly AreaChartProps.Series<T>[]) {\n  const sampleXValues = getXValues(series);\n\n  for (const s of series) {\n    if (s.type === 'area') {\n      for (let i = 0; i < Math.max(s.data.length, sampleXValues.length); i++) {\n        if (s.data[i]?.x !== sampleXValues[i]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\n// Takes first area series x-values as all data x-values are to match across series.\nfunction getXValues<T>(series: readonly AreaChartProps.Series<T>[]) {\n  for (const s of series) {\n    if (s.type === 'area') {\n      return s.data.map(({ x }) => x);\n    }\n  }\n\n  return [];\n}\n\n// Returns data that is visible in the given scale.\nfunction getVisibleData<T>(data: readonly T[], xScale: ChartScale) {\n  const scaledOffsetX = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n\n  const visibleData = [];\n  for (const x of data) {\n    const scaledX = xScale.d3Scale(x as any);\n\n    if (scaledX !== undefined) {\n      visibleData.push({ x, scaledX: scaledX + scaledOffsetX });\n    }\n  }\n  return visibleData;\n}\n\n// Inserts given value into a two-dimensional array.\nfunction insertIntoMatrix<T>(matrix: T[][], row: number, col: number, value: T) {\n  if (!matrix[row]) {\n    matrix[row] = [];\n  }\n  matrix[row][col] = value;\n}\n\n// Creates new array with only unique elements of the given array.\nfunction uniq<T>(arr: readonly T[]): readonly T[] {\n  const set = new Set();\n  const uniqArray: T[] = [];\n\n  for (const value of arr) {\n    if (!set.has(value)) {\n      set.add(value);\n      uniqArray.push(value);\n    }\n  }\n\n  return uniqArray;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}