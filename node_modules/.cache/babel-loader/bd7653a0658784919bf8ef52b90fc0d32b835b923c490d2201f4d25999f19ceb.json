{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { calculateScroll, getFirstScrollableParent, scrollRectangleIntoView } from '../internal/utils/scrollable-containers';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n  hideOnOverscroll\n}) {\n  const previousInternalPositionRef = useRef(null);\n  const [popoverStyle, setPopoverStyle] = useState({});\n  const [internalPosition, setInternalPosition] = useState(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef(() => {});\n  const scrollableContainerRectRef = useRef(null);\n  const updatePositionHandler = useCallback((onContentResize = false) => {\n    var _a;\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    const track = trackRef.current;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    const {\n      offsetWidth,\n      offsetHeight\n    } = getOffsetDimensions(popover);\n    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevInsetBlockStart = popover.style.insetBlockStart;\n    const prevInsetInlineStart = popover.style.insetInlineStart;\n    popover.style.insetBlockStart = '0';\n    popover.style.insetInlineStart = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxBlockSize = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView);\n    const trackRect = getLogicalBoundingClientRect(track);\n    const arrowRect = getDimensions(arrow);\n    const containingBlock = getContainingBlock(popover);\n    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = getLogicalBoundingClientRect(contentRef.current);\n    const contentBoundingBox = {\n      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n      blockSize: contentRect.blockSize + 2 * bodyBorderWidth\n    };\n    // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n    // we maintain the previously defined internal position,\n    // but we still call calculatePosition to know if the popover should be scrollable.\n    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : undefined;\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      rect\n    } = calculatePosition({\n      preferredPosition,\n      fixedInternalPosition,\n      trigger: trackRect,\n      arrow: arrowRect,\n      body: contentBoundingBox,\n      container: containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewport: viewportRect,\n      renderWithPortal,\n      allowVerticalOverflow\n    });\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(rect, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.insetBlockStart = prevInsetBlockStart;\n    popover.style.insetInlineStart = prevInsetInlineStart;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxBlockSize = rect.blockSize + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Remember the internal position in case we want to keep it later.\n    previousInternalPositionRef.current = newInternalPosition;\n    setInternalPosition(newInternalPosition);\n    const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n    // Position the popover\n    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;\n    setPopoverStyle({\n      insetBlockStart,\n      insetInlineStart: popoverOffset.insetInlineStart\n    });\n    // Scroll if necessary\n    if (shouldScroll) {\n      const scrollableParent = getFirstScrollableParent(popover);\n      scrollRectangleIntoView(rect, scrollableParent);\n    }\n    if (hideOnOverscroll && trackRef.current instanceof HTMLElement) {\n      const scrollableContainer = getFirstScrollableParent(trackRef.current);\n      if (scrollableContainer) {\n        scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n      }\n    }\n    positionHandlerRef.current = () => {\n      const trackRect = getLogicalBoundingClientRect(track);\n      const newTrackOffset = toRelativePosition(trackRect, containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);\n      setPopoverStyle({\n        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart\n      });\n      if (hideOnOverscroll && scrollableContainerRectRef.current) {\n        // Assuming the arrow tip is at the vertical center of the popover trigger.\n        // This is good enough for disabled reason tooltip in select and multiselect.\n        // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n        setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n      }\n    };\n  }, [trackRef, popoverRef, bodyRef, contentRef, arrowRef, keepPosition, preferredPosition, renderWithPortal, allowVerticalOverflow, allowScrollToFit, hideOnOverscroll]);\n  return {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef,\n    isOverscrolling\n  };\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart\n  };\n}\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  var _a, _b, _c, _d;\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: (_b = (_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window.innerWidth,\n    blockSize: (_d = (_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  const {\n    insetBlockStart,\n    insetInlineStart\n  } = getLogicalBoundingClientRect(document.documentElement);\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"names":["useCallback","useRef","useState","nodeContains","getLogicalBoundingClientRect","getContainingBlock","calculateScroll","getFirstScrollableParent","scrollRectangleIntoView","calculatePosition","getDimensions","getOffsetDimensions","isCenterOutside","usePopoverPosition","popoverRef","bodyRef","arrowRef","trackRef","contentRef","allowScrollToFit","allowVerticalOverflow","preferredPosition","renderWithPortal","keepPosition","hideOnOverscroll","previousInternalPositionRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","isOverscrolling","setIsOverscrolling","positionHandlerRef","scrollableContainerRectRef","updatePositionHandler","onContentResize","current","popover","body","arrow","document","ownerDocument","track","offsetWidth","offsetHeight","prevInsetBlockStart","style","insetBlockStart","prevInsetInlineStart","insetInlineStart","maxBlockSize","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","arrowRect","containingBlock","containingBlockRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","inlineSize","blockSize","shouldKeepPosition","fixedInternalPosition","_a","undefined","scrollable","newInternalPosition","rect","trigger","container","getDocumentRect","viewport","popoverOffset","toRelativePosition","trackRelativeOffset","shouldScroll","scrollableParent","HTMLElement","scrollableContainer","newTrackOffset","element","parseInt","getComputedStyle","borderWidth","parent","window","_b","visualViewport","width","innerWidth","_d","_c","height","innerHeight","documentElement","scrollWidth","scrollHeight"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/popover/use-popover-position.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getContainingBlock } from '../internal/utils/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps, Rect } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n  hideOnOverscroll,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<HTMLElement | SVGElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n  hideOnOverscroll?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const scrollableContainerRectRef = useRef<Rect | null>(null);\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      if (hideOnOverscroll && trackRef.current instanceof HTMLElement) {\n        const scrollableContainer = getFirstScrollableParent(trackRef.current);\n        if (scrollableContainer) {\n          scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n        }\n      }\n\n      positionHandlerRef.current = () => {\n        const trackRect = getLogicalBoundingClientRect(track);\n\n        const newTrackOffset = toRelativePosition(\n          trackRect,\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n\n        if (hideOnOverscroll && scrollableContainerRectRef.current) {\n          // Assuming the arrow tip is at the vertical center of the popover trigger.\n          // This is good enough for disabled reason tooltip in select and multiselect.\n          // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n          setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n        }\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n      allowScrollToFit,\n      hideOnOverscroll,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.visualViewport?.width ?? window.innerWidth,\n    blockSize: window.visualViewport?.height ?? window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}