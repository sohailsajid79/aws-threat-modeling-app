{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef } from 'react';\nimport clsx from 'clsx';\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { KeyCode } from '../internal/keycode';\nimport handleKey from '../internal/utils/handle-key';\nimport { Segment } from './segment';\nimport styles from './styles.css.js';\nexport default function InternalSegmentedControl({\n  selectedId,\n  options,\n  label,\n  ariaLabelledby,\n  onChange\n}) {\n  const segmentByIdRef = useRef({});\n  const selectedOptions = (options || []).filter(option => {\n    return option.id === selectedId;\n  });\n  const currentSelectedOption = selectedOptions.length ? selectedOptions[0] : null;\n  const focusableSegments = (options || []).filter(option => !option.disabled || option.disabled && !!option.disabledReason);\n  const moveHighlight = (event, activeIndex) => {\n    var _a;\n    if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left) {\n      return;\n    }\n    let nextIndex = activeIndex;\n    handleKey(event, {\n      onInlineStart: () => nextIndex = activeIndex === 0 ? focusableSegments.length - 1 : activeIndex - 1,\n      onInlineEnd: () => nextIndex = activeIndex + 1 === focusableSegments.length ? 0 : activeIndex + 1\n    });\n    const nextSegmentId = focusableSegments[nextIndex].id;\n    (_a = segmentByIdRef.current[nextSegmentId]) === null || _a === void 0 ? void 0 : _a.focus();\n  };\n  return React.createElement(\"div\", {\n    className: clsx(styles['segment-part'], styles[`segment-count-${options === null || options === void 0 ? void 0 : options.length}`]),\n    \"aria-label\": label,\n    \"aria-labelledby\": ariaLabelledby,\n    role: \"toolbar\"\n  }, options && options.map((option, index) => {\n    const isActive = selectedId === option.id;\n    const focusableSegmentIndex = focusableSegments.indexOf(option);\n    let tabIndex = isActive ? 0 : -1;\n    if (currentSelectedOption === null && focusableSegmentIndex === 0) {\n      tabIndex = 0;\n    }\n    return React.createElement(Segment, {\n      key: index,\n      id: option.id,\n      disabled: !!option.disabled,\n      disabledReason: option.disabledReason,\n      iconName: option.iconName,\n      iconAlt: option.iconAlt,\n      iconUrl: option.iconUrl,\n      iconSvg: option.iconSvg,\n      text: option.text,\n      isActive: isActive,\n      tabIndex: tabIndex,\n      ref: node => {\n        if (node) {\n          segmentByIdRef.current[option.id] = node;\n        } else {\n          delete segmentByIdRef.current[option.id];\n        }\n      },\n      onClick: () => {\n        if (option.disabled) {\n          return;\n        }\n        if (selectedId !== option.id) {\n          fireNonCancelableEvent(onChange, {\n            selectedId: option.id\n          });\n        }\n      },\n      onKeyDown: event => moveHighlight(event, focusableSegmentIndex)\n    });\n  }));\n}","map":{"version":3,"names":["React","useRef","clsx","fireNonCancelableEvent","KeyCode","handleKey","Segment","styles","InternalSegmentedControl","selectedId","options","label","ariaLabelledby","onChange","segmentByIdRef","selectedOptions","filter","option","id","currentSelectedOption","length","focusableSegments","disabled","disabledReason","moveHighlight","event","activeIndex","keyCode","right","left","nextIndex","onInlineStart","onInlineEnd","nextSegmentId","_a","current","focus","createElement","className","role","map","index","isActive","focusableSegmentIndex","indexOf","tabIndex","key","iconName","iconAlt","iconUrl","iconSvg","text","ref","node","onClick","onKeyDown"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/segmented-control/internal-segmented-control.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { KeyCode } from '../internal/keycode';\nimport handleKey from '../internal/utils/handle-key';\nimport { SegmentedControlProps } from './interfaces';\nimport { Segment } from './segment';\n\nimport styles from './styles.css.js';\n\nexport default function InternalSegmentedControl({\n  selectedId,\n  options,\n  label,\n  ariaLabelledby,\n  onChange,\n}: SegmentedControlProps) {\n  const segmentByIdRef = useRef<{ [id: string]: HTMLButtonElement }>({});\n  const selectedOptions = (options || []).filter(option => {\n    return option.id === selectedId;\n  });\n  const currentSelectedOption = selectedOptions.length ? selectedOptions[0] : null;\n  const focusableSegments = (options || []).filter(\n    option => !option.disabled || (option.disabled && !!option.disabledReason)\n  );\n\n  const moveHighlight = (event: React.KeyboardEvent<HTMLButtonElement>, activeIndex: number) => {\n    if (event.keyCode !== KeyCode.right && event.keyCode !== KeyCode.left) {\n      return;\n    }\n\n    let nextIndex = activeIndex;\n\n    handleKey(event, {\n      onInlineStart: () => (nextIndex = activeIndex === 0 ? focusableSegments.length - 1 : activeIndex - 1),\n      onInlineEnd: () => (nextIndex = activeIndex + 1 === focusableSegments.length ? 0 : activeIndex + 1),\n    });\n\n    const nextSegmentId = focusableSegments[nextIndex].id;\n    segmentByIdRef.current[nextSegmentId]?.focus();\n  };\n\n  return (\n    <div\n      className={clsx(styles['segment-part'], styles[`segment-count-${options?.length}`])}\n      aria-label={label}\n      aria-labelledby={ariaLabelledby}\n      role=\"toolbar\"\n    >\n      {options &&\n        options.map((option: SegmentedControlProps.Option, index) => {\n          const isActive = selectedId === option.id;\n          const focusableSegmentIndex = focusableSegments.indexOf(option);\n          let tabIndex = isActive ? 0 : -1;\n          if (currentSelectedOption === null && focusableSegmentIndex === 0) {\n            tabIndex = 0;\n          }\n          return (\n            <Segment\n              key={index}\n              id={option.id}\n              disabled={!!option.disabled}\n              disabledReason={option.disabledReason}\n              iconName={option.iconName}\n              iconAlt={option.iconAlt}\n              iconUrl={option.iconUrl}\n              iconSvg={option.iconSvg}\n              text={option.text}\n              isActive={isActive}\n              tabIndex={tabIndex}\n              ref={node => {\n                if (node) {\n                  segmentByIdRef.current[option.id] = node;\n                } else {\n                  delete segmentByIdRef.current[option.id];\n                }\n              }}\n              onClick={() => {\n                if (option.disabled) {\n                  return;\n                }\n\n                if (selectedId !== option.id) {\n                  fireNonCancelableEvent(onChange, { selectedId: option.id });\n                }\n              }}\n              onKeyDown={event => moveHighlight(event, focusableSegmentIndex)}\n            />\n          );\n        })}\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}