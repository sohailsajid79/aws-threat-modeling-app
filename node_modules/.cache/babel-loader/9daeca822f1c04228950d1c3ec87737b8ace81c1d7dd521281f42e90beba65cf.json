{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(filteringProperties, filteringText) {\n  let maxLength = 0;\n  let matchedProperty = null;\n  for (const property of filteringProperties) {\n    if (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel) || property.propertyLabel.length > maxLength && startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase())) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n  return matchedProperty;\n}\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(allowedOperators, filteringText) {\n  filteringText = filteringText.toLowerCase();\n  let maxLength = 0;\n  let matchedOperator = null;\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n  return matchedOperator;\n}\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(allowedOperators, filteringText) {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\nexport function matchTokenValue(_ref, filteringOptions) {\n  let {\n    property,\n    operator,\n    value\n  } = _ref;\n  var _a, _b;\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch = {\n    propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n    operator,\n    value\n  };\n  for (const option of propertyOptions) {\n    if (option.label && option.label === value || !option.label && option.value === value) {\n      // exact match found: return it\n      return {\n        propertyKey: property === null || property === void 0 ? void 0 : property.propertyKey,\n        operator,\n        value: option.value\n      };\n    }\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === ((_b = (_a = option.label) !== null && _a !== void 0 ? _a : option.value) !== null && _b !== void 0 ? _b : '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n  return bestMatch;\n}\nexport function trimStart(source) {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\nexport function trimFirstSpace(source) {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\nexport function removeOperator(source, operator) {\n  const operatorLastIndex = source.indexOf(operator) + operator.length;\n  const textWithoutOperator = source.slice(operatorLastIndex);\n  // We need to remove the first leading space in case the user presses space\n  // after the operator, for example: Owner: admin, will result in value of ` admin`\n  // and we need to remove the first space, if the user added any more spaces only the\n  // first one will be removed.\n  return trimFirstSpace(textWithoutOperator);\n}\nfunction startsWith(source, target) {\n  return source.indexOf(target) === 0;\n}\n/**\n * Transforms query token groups to tokens (only taking 1 level of nesting).\n */\nexport function tokenGroupToTokens(tokenGroups) {\n  const tokens = [];\n  for (const tokenOrGroup of tokenGroups) {\n    if ('operator' in tokenOrGroup) {\n      tokens.push(tokenOrGroup);\n    } else {\n      for (const nestedTokenOrGroup of tokenOrGroup.tokens) {\n        if ('operator' in nestedTokenOrGroup) {\n          tokens.push(nestedTokenOrGroup);\n        } else {\n          // Ignore deeply nested tokens\n        }\n      }\n    }\n  }\n  return tokens;\n}","map":{"version":3,"names":["matchFilteringProperty","filteringProperties","filteringText","maxLength","matchedProperty","property","propertyLabel","length","startsWith","toLowerCase","matchOperator","allowedOperators","matchedOperator","operator","matchOperatorPrefix","trim","matchTokenValue","_ref","filteringOptions","value","propertyOptions","filter","option","bestMatch","propertyKey","label","_b","_a","trimStart","source","spacesLength","i","slice","trimFirstSpace","removeOperator","operatorLastIndex","indexOf","textWithoutOperator","target","tokenGroupToTokens","tokenGroups","tokens","tokenOrGroup","push","nestedTokenOrGroup"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/property-filter/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ComparisonOperator,\n  InternalFilteringOption,\n  InternalFilteringProperty,\n  InternalToken,\n  Token,\n} from './interfaces';\n\n// Finds the longest property the filtering text starts from.\nexport function matchFilteringProperty(\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringText: string\n): null | InternalFilteringProperty {\n  let maxLength = 0;\n  let matchedProperty: null | InternalFilteringProperty = null;\n\n  for (const property of filteringProperties) {\n    if (\n      (property.propertyLabel.length >= maxLength && startsWith(filteringText, property.propertyLabel)) ||\n      (property.propertyLabel.length > maxLength &&\n        startsWith(filteringText.toLowerCase(), property.propertyLabel.toLowerCase()))\n    ) {\n      maxLength = property.propertyLabel.length;\n      matchedProperty = property;\n    }\n  }\n\n  return matchedProperty;\n}\n\n// Finds the longest operator the filtering text starts from.\nexport function matchOperator(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | ComparisonOperator {\n  filteringText = filteringText.toLowerCase();\n\n  let maxLength = 0;\n  let matchedOperator: null | ComparisonOperator = null;\n\n  for (const operator of allowedOperators) {\n    if (operator.length > maxLength && startsWith(filteringText, operator.toLowerCase())) {\n      maxLength = operator.length;\n      matchedOperator = operator;\n    }\n  }\n\n  return matchedOperator;\n}\n\n// Finds if the filtering text matches any operator prefix.\nexport function matchOperatorPrefix(\n  allowedOperators: readonly ComparisonOperator[],\n  filteringText: string\n): null | string {\n  if (filteringText.trim().length === 0) {\n    return '';\n  }\n  for (const operator of allowedOperators) {\n    if (startsWith(operator.toLowerCase(), filteringText.toLowerCase())) {\n      return filteringText;\n    }\n  }\n  return null;\n}\n\nexport function matchTokenValue(\n  { property, operator, value }: InternalToken,\n  filteringOptions: readonly InternalFilteringOption[]\n): Token {\n  const propertyOptions = filteringOptions.filter(option => option.property === property);\n  const bestMatch: Token = { propertyKey: property?.propertyKey, operator, value };\n  for (const option of propertyOptions) {\n    if ((option.label && option.label === value) || (!option.label && option.value === value)) {\n      // exact match found: return it\n      return { propertyKey: property?.propertyKey, operator, value: option.value };\n    }\n\n    // By default, the token value is a string, but when a custom property is used,\n    // the token value can be any, therefore we need to check for its type before calling toLowerCase()\n    if (typeof value === 'string' && value.toLowerCase() === (option.label ?? option.value ?? '').toLowerCase()) {\n      // non-exact match: save and keep running in case exact match found later\n      bestMatch.value = option.value;\n    }\n  }\n\n  return bestMatch;\n}\n\nexport function trimStart(source: string): string {\n  let spacesLength = 0;\n  for (let i = 0; i < source.length; i++) {\n    if (source[i] === ' ') {\n      spacesLength++;\n    } else {\n      break;\n    }\n  }\n  return source.slice(spacesLength);\n}\n\nexport function trimFirstSpace(source: string): string {\n  return source[0] === ' ' ? source.slice(1) : source;\n}\n\nexport function removeOperator(source: string, operator: string) {\n  const operatorLastIndex = source.indexOf(operator) + operator.length;\n  const textWithoutOperator = source.slice(operatorLastIndex);\n  // We need to remove the first leading space in case the user presses space\n  // after the operator, for example: Owner: admin, will result in value of ` admin`\n  // and we need to remove the first space, if the user added any more spaces only the\n  // first one will be removed.\n  return trimFirstSpace(textWithoutOperator);\n}\n\nfunction startsWith(source: string, target: string): boolean {\n  return source.indexOf(target) === 0;\n}\n\ninterface AbstractToken {\n  operator: any;\n}\n\ninterface AbstractTokenGroup<T extends AbstractToken> {\n  operation: any;\n  tokens: readonly (T | AbstractTokenGroup<T>)[];\n}\n\n/**\n * Transforms query token groups to tokens (only taking 1 level of nesting).\n */\nexport function tokenGroupToTokens<T extends AbstractToken>(tokenGroups: readonly (T | AbstractTokenGroup<T>)[]): T[] {\n  const tokens: T[] = [];\n  for (const tokenOrGroup of tokenGroups) {\n    if ('operator' in tokenOrGroup) {\n      tokens.push(tokenOrGroup);\n    } else {\n      for (const nestedTokenOrGroup of tokenOrGroup.tokens) {\n        if ('operator' in nestedTokenOrGroup) {\n          tokens.push(nestedTokenOrGroup);\n        } else {\n          // Ignore deeply nested tokens\n        }\n      }\n    }\n  }\n  return tokens;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}