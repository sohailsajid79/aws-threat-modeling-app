{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, forwardRef, useContext, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport { nodeBelongs } from '../utils/node-belongs';\nexport const defaultValue = {\n  navigationActive: false,\n  registerFocusable: () => () => {}\n};\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\nexport function useSingleTabStopNavigation(focusable, options) {\n  var _a;\n  const {\n    navigationActive: contextNavigationActive,\n    registerFocusable\n  } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;\n  }\n  return {\n    navigationActive,\n    tabIndex\n  };\n}\nexport const SingleTabStopNavigationProvider = forwardRef(({\n  navigationActive,\n  children,\n  getNextFocusTarget,\n  isElementSuppressed,\n  onRegisterFocusable,\n  onUnregisterActive\n}, ref) => {\n  // A set of registered focusable elements that can use keyboard navigation.\n  const focusables = useRef(new Set());\n  // A map of registered focusable element handlers to update the respective tab indices.\n  const focusHandlers = useRef(new Map());\n  // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n  const focusablesState = useRef(new WeakMap());\n  // A reference to the currently focused element.\n  const focusTarget = useRef(null);\n  function onUnregisterFocusable(focusableElement) {\n    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n    if (isUnregisteringFocusedNode) {\n      // Wait for unmounted node to get removed from the DOM.\n      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);\n    }\n  }\n  // Register a focusable element to allow navigating into it.\n  // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n  function registerFocusable(focusableElement, changeHandler) {\n    focusables.current.add(focusableElement);\n    focusHandlers.current.set(focusableElement, changeHandler);\n    const isFocusable = !!focusablesState.current.get(focusableElement);\n    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n    if (newIsFocusable !== isFocusable) {\n      focusablesState.current.set(focusableElement, newIsFocusable);\n      changeHandler(newIsFocusable);\n    }\n    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);\n    return () => unregisterFocusable(focusableElement);\n  }\n  function unregisterFocusable(focusableElement) {\n    focusables.current.delete(focusableElement);\n    focusHandlers.current.delete(focusableElement);\n    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);\n  }\n  // Update focus target with next single focusable element and notify all registered focusables of a change.\n  function updateFocusTarget() {\n    var _a;\n    focusTarget.current = getNextFocusTarget();\n    for (const focusableElement of focusables.current) {\n      const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;\n      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        focusHandlers.current.get(focusableElement)(newIsFocusable);\n      }\n    }\n  }\n  function getFocusTarget() {\n    return focusTarget.current;\n  }\n  function isRegistered(element) {\n    return focusables.current.has(element);\n  }\n  useImperativeHandle(ref, () => ({\n    updateFocusTarget,\n    getFocusTarget,\n    isRegistered\n  }));\n  return React.createElement(SingleTabStopNavigationContext.Provider, {\n    value: {\n      navigationActive,\n      registerFocusable\n    }\n  }, children);\n});","map":{"version":3,"names":["React","createContext","forwardRef","useContext","useImperativeHandle","useLayoutEffect","useRef","useState","nodeBelongs","defaultValue","navigationActive","registerFocusable","SingleTabStopNavigationContext","useSingleTabStopNavigation","focusable","options","contextNavigationActive","focusTargetActive","setFocusTargetActive","navigationDisabled","tabIndex","current","unregister","isFocusable","_a","SingleTabStopNavigationProvider","children","getNextFocusTarget","isElementSuppressed","onRegisterFocusable","onUnregisterActive","ref","focusables","Set","focusHandlers","Map","focusablesState","WeakMap","focusTarget","onUnregisterFocusable","focusableElement","isUnregisteringFocusedNode","document","activeElement","setTimeout","changeHandler","add","set","get","newIsFocusable","unregisterFocusable","delete","updateFocusTarget","getFocusTarget","isRegistered","element","has","createElement","Provider","value"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/context/single-tab-stop-navigation-context.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, {\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { nodeBelongs } from '../utils/node-belongs';\n\nexport type FocusableChangeHandler = (isFocusable: boolean) => void;\n\nexport interface SingleTabStopNavigationOptions {\n  tabIndex?: number;\n}\n\nexport const defaultValue: {\n  navigationActive: boolean;\n  registerFocusable(focusable: HTMLElement, handler: FocusableChangeHandler): () => void;\n} = {\n  navigationActive: false,\n  registerFocusable: () => () => {},\n};\n\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\n\nexport function useSingleTabStopNavigation(\n  focusable: null | React.RefObject<HTMLElement>,\n  options?: { tabIndex?: number }\n) {\n  const { navigationActive: contextNavigationActive, registerFocusable } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = options?.tabIndex && options?.tabIndex < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n\n  let tabIndex = options?.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : options?.tabIndex ?? 0;\n  }\n\n  return { navigationActive, tabIndex };\n}\n\nexport interface SingleTabStopNavigationProviderProps {\n  navigationActive: boolean;\n  children: React.ReactNode;\n  getNextFocusTarget: () => null | HTMLElement;\n  isElementSuppressed?(focusableElement: Element): boolean;\n  onRegisterFocusable?(focusableElement: Element): void;\n  onUnregisterActive?(focusableElement: Element): void;\n}\n\nexport interface SingleTabStopNavigationAPI {\n  updateFocusTarget(): void;\n  getFocusTarget(): null | HTMLElement;\n  isRegistered(element: Element): boolean;\n}\n\nexport const SingleTabStopNavigationProvider = forwardRef(\n  (\n    {\n      navigationActive,\n      children,\n      getNextFocusTarget,\n      isElementSuppressed,\n      onRegisterFocusable,\n      onUnregisterActive,\n    }: SingleTabStopNavigationProviderProps,\n    ref: React.Ref<SingleTabStopNavigationAPI>\n  ) => {\n    // A set of registered focusable elements that can use keyboard navigation.\n    const focusables = useRef(new Set<Element>());\n    // A map of registered focusable element handlers to update the respective tab indices.\n    const focusHandlers = useRef(new Map<Element, FocusableChangeHandler>());\n    // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n    const focusablesState = useRef(new WeakMap<Element, boolean>());\n    // A reference to the currently focused element.\n    const focusTarget = useRef<null | HTMLElement>(null);\n\n    function onUnregisterFocusable(focusableElement: Element) {\n      const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n      if (isUnregisteringFocusedNode) {\n        // Wait for unmounted node to get removed from the DOM.\n        setTimeout(() => onUnregisterActive?.(focusableElement), 0);\n      }\n    }\n\n    // Register a focusable element to allow navigating into it.\n    // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n    function registerFocusable(focusableElement: Element, changeHandler: FocusableChangeHandler) {\n      focusables.current.add(focusableElement);\n      focusHandlers.current.set(focusableElement, changeHandler);\n      const isFocusable = !!focusablesState.current.get(focusableElement);\n      const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        changeHandler(newIsFocusable);\n      }\n      onRegisterFocusable?.(focusableElement);\n      return () => unregisterFocusable(focusableElement);\n    }\n    function unregisterFocusable(focusableElement: Element) {\n      focusables.current.delete(focusableElement);\n      focusHandlers.current.delete(focusableElement);\n      onUnregisterFocusable?.(focusableElement);\n    }\n\n    // Update focus target with next single focusable element and notify all registered focusables of a change.\n    function updateFocusTarget() {\n      focusTarget.current = getNextFocusTarget();\n      for (const focusableElement of focusables.current) {\n        const isFocusable = focusablesState.current.get(focusableElement) ?? false;\n        const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n        if (newIsFocusable !== isFocusable) {\n          focusablesState.current.set(focusableElement, newIsFocusable);\n          focusHandlers.current.get(focusableElement)!(newIsFocusable);\n        }\n      }\n    }\n\n    function getFocusTarget() {\n      return focusTarget.current;\n    }\n\n    function isRegistered(element: Element) {\n      return focusables.current.has(element);\n    }\n\n    useImperativeHandle(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));\n\n    return (\n      <SingleTabStopNavigationContext.Provider value={{ navigationActive, registerFocusable }}>\n        {children}\n      </SingleTabStopNavigationContext.Provider>\n    );\n  }\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}