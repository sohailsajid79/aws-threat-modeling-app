{"ast":null,"code":"import { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { KeyCode } from '../../keycode';\nimport { backspaceHandler, enterHandler, keyHandler } from './keyboard-handler';\nimport { isCommand, isDigit } from './utils/keys';\nconst onAutoComplete = (value, onChange, maskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\nconst preventDefault = (event, result) => result && event.preventDefault();\nconst useMask = ({\n  value = '',\n  onBlur,\n  onChange,\n  onKeyDown,\n  format,\n  inputRef,\n  autofix = false,\n  disableAutocompleteOnBlur = false,\n  setPosition\n}) => {\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n  const onMaskChange = updatedValue => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n    onChange(autofixedUpdatedValue);\n  };\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n  return {\n    value: maskedValue,\n    onKeyDown: event => {\n      var _a, _b;\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      let result;\n      const {\n        keyCode,\n        key,\n        ctrlKey,\n        metaKey\n      } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n      if (result) {\n        const {\n          value,\n          position\n        } = result;\n        onMaskChange(value);\n        setPosition(position);\n      }\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: ({\n      detail\n    }) => onMaskChange(detail.value),\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n      onBlur && onBlur();\n    },\n    onPaste: event => {\n      var _a, _b;\n      const text = (event.clipboardData || window.clipboardData).getData('text');\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    }\n  };\n};\nexport default useMask;","map":{"version":3,"names":["warnOnce","KeyCode","backspaceHandler","enterHandler","keyHandler","isCommand","isDigit","onAutoComplete","value","onChange","maskFormat","autoCompletedValue","autoComplete","preventDefault","event","result","useMask","onBlur","onKeyDown","format","inputRef","autofix","disableAutocompleteOnBlur","setPosition","isValid","onMaskChange","updatedValue","autofixedUpdatedValue","correctMinMaxValues","initialValue","maskedValue","getValidValue","selectionStart","_a","current","selectionEnd","_b","keyCode","key","ctrlKey","metaKey","detail","isSeparator","backspace","enter","position","onPaste","text","clipboardData","window","getData","formattedText","formatPastedText"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/components/masked-input/use-mask.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject } from 'react';\n\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\n\nimport { InputProps } from '../../../input/interfaces';\nimport { CancelableEventHandler, NonCancelableEventHandler } from '../../events';\nimport { KeyCode } from '../../keycode';\nimport { backspaceHandler, enterHandler, HandlerResult, keyHandler } from './keyboard-handler';\nimport { isCommand, isDigit } from './utils/keys';\nimport MaskFormat from './utils/mask-format';\n\ninterface UseMaskHook {\n  value: string;\n  onChange: NonCancelableEventHandler<InputProps.ChangeDetail>;\n  onKeyDown: CancelableEventHandler<InputProps.KeyDetail>;\n  onBlur: NonCancelableEventHandler<null>;\n  onPaste: (event: React.ClipboardEvent) => void;\n}\n\ninterface UseMaskProps {\n  value: string;\n  onChange: (value: string) => void;\n  onKeyDown?: (event: CustomEvent) => void;\n  onBlur?: () => void;\n  format: MaskFormat;\n  autofix?: boolean;\n  inputRef: RefObject<HTMLInputElement>;\n  disableAutocompleteOnBlur?: boolean;\n  setPosition: (position: number | null) => void;\n}\n\nconst onAutoComplete = (value: string, onChange: UseMaskProps['onChange'], maskFormat: MaskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\n\nconst preventDefault = (event: CustomEvent, result?: HandlerResult | null) => result && event.preventDefault();\n\nconst useMask = ({\n  value = '',\n  onBlur,\n  onChange,\n  onKeyDown,\n  format,\n  inputRef,\n  autofix = false,\n  disableAutocompleteOnBlur = false,\n  setPosition,\n}: UseMaskProps): UseMaskHook => {\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n\n  const onMaskChange = (updatedValue: string) => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n\n    onChange(autofixedUpdatedValue);\n  };\n\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n\n  return {\n    value: maskedValue,\n    onKeyDown: (event: CustomEvent) => {\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      let result: HandlerResult | undefined;\n      const { keyCode, key, ctrlKey, metaKey } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n\n      if (result) {\n        const { value, position } = result;\n\n        onMaskChange(value);\n        setPosition(position);\n      }\n\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: ({ detail }) => onMaskChange(detail.value),\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n\n      onBlur && onBlur();\n    },\n    onPaste: (event: React.ClipboardEvent) => {\n      const text = (event.clipboardData || (window as any).clipboardData).getData('text');\n\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    },\n  };\n};\n\nexport default useMask;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}