{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useMemo, useRef } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { useHeightMeasure } from '../../internal/hooks/container-queries/use-height-measure';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport handleKey from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { throttle } from '../../internal/utils/throttle';\nimport { useReaction } from '../async-store';\nimport computeChartProps from './compute-chart-props';\nimport createSeriesDecorator from './create-series-decorator';\nimport InteractionsStore from './interactions-store';\nimport { findClosest } from './utils';\nconst MAX_HOVER_MARGIN = 6;\nconst SVG_HOVER_THROTTLE = 25;\nconst POPOVER_DEADZONE = 12;\n// Represents the core the chart logic, including the model of all allowed user interactions.\nexport default function useChartModel({\n  isRtl,\n  fitHeight,\n  externalSeries: allSeries,\n  visibleSeries: series,\n  setVisibleSeries,\n  highlightedSeries,\n  setHighlightedSeries,\n  xDomain,\n  yDomain,\n  xScaleType,\n  yScaleType,\n  height: explicitHeight,\n  width,\n  popoverRef,\n  statusType\n}) {\n  var _a;\n  // Chart elements refs used in handlers.\n  const plotRef = useRef(null);\n  const containerRef = useRef(null);\n  const verticalMarkerRef = useRef(null);\n  const plotMeasureRef = useRef(null);\n  const hasVisibleSeries = series.length > 0;\n  const height = (_a = useHeightMeasure(() => plotMeasureRef.current, !fitHeight, [hasVisibleSeries, statusType])) !== null && _a !== void 0 ? _a : explicitHeight;\n  const stableSetVisibleSeries = useStableCallback(setVisibleSeries);\n  const model = useMemo(() => {\n    // Compute scales, ticks and two-dimensional plots.\n    const computed = computeChartProps({\n      isRtl,\n      series,\n      xDomain,\n      yDomain,\n      xScaleType,\n      yScaleType,\n      height,\n      width\n    });\n    // A store for chart interactions that don't require plot recomputation.\n    const interactions = new InteractionsStore(series, computed.plot);\n    const containsMultipleSeries = interactions.series.length > 1;\n    // A series decorator to provide extra props such as color and marker type.\n    const getInternalSeries = createSeriesDecorator(allSeries);\n    const isMouseOverPopover = (clientX, clientY) => {\n      var _a;\n      if ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.firstChild) {\n        const popoverPosition = popoverRef.current.firstChild.getBoundingClientRect();\n        if (clientX > popoverPosition.x - POPOVER_DEADZONE && clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE && clientY > popoverPosition.y - POPOVER_DEADZONE && clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE) {\n          return true;\n        }\n      }\n      return false;\n    };\n    // A Callback for svg mouseover to hover the plot points.\n    // Throttling is necessary for a substantially smoother customer experience.\n    const onSVGMouseMoveThrottled = throttle((clientX, clientY) => {\n      // No hover logic when the popover is pinned or no data available.\n      if (interactions.get().isPopoverPinned || !plotRef.current || interactions.plot.xy.length === 0 || isMouseOverPopover(clientX, clientY)) {\n        return;\n      }\n      const svgRect = plotRef.current.svg.getBoundingClientRect();\n      const offsetX = clientX - svgRect.left;\n      const offsetY = clientY - svgRect.top;\n      const closestX = findClosest(interactions.plot.xy, offsetX, xPoints => xPoints[0].scaled.x);\n      const closestPoint = findClosest(closestX, offsetY, point => point.scaled.y1);\n      // If close enough to the point - highlight the point and its column.\n      // If not - only highlight the closest column.\n      if (Math.abs(offsetX - closestPoint.scaled.x) < MAX_HOVER_MARGIN && Math.abs(offsetY - closestPoint.scaled.y1) < MAX_HOVER_MARGIN) {\n        interactions.highlightPoint(closestPoint);\n      } else {\n        interactions.highlightX(closestX);\n      }\n    }, SVG_HOVER_THROTTLE);\n    const onSVGMouseMove = ({\n      clientX,\n      clientY\n    }) => onSVGMouseMoveThrottled(clientX, clientY);\n    // A callback for svg mouseout to clear all highlights.\n    const onSVGMouseOut = event => {\n      // Because the mouseover is throttled, in can occur slightly after the mouseout,\n      // neglecting its effect; cancelling the throttled function prevents that.\n      onSVGMouseMoveThrottled.cancel();\n      // No hover logic when the popover is pinned or mouse is over popover\n      if (interactions.get().isPopoverPinned || isMouseOverPopover(event.clientX, event.clientY)) {\n        return;\n      }\n      // Check if the target is contained within svg to allow hovering on the popover body.\n      if (!nodeContains(plotRef.current.svg, event.relatedTarget)) {\n        interactions.clearHighlightedLegend();\n        interactions.clearHighlight();\n      }\n    };\n    // A callback for svg click to pin/unpin the popover.\n    const onSVGMouseDown = event => {\n      interactions.togglePopoverPin();\n      event.preventDefault();\n    };\n    const moveWithinXAxis = direction => {\n      if (interactions.get().highlightedPoint) {\n        return moveWithinSeries(direction);\n      } else if (containsMultipleSeries) {\n        const {\n          highlightedX\n        } = interactions.get();\n        if (highlightedX) {\n          const currentXIndex = highlightedX[0].index.x;\n          const nextXIndex = circleIndex(currentXIndex + direction, [0, interactions.plot.xy.length - 1]);\n          interactions.highlightX(interactions.plot.xy[nextXIndex]);\n        }\n      }\n    };\n    // A helper function to highlight the next or previous point within selected series.\n    const moveWithinSeries = direction => {\n      // Can only use motion when a particular point is highlighted.\n      const point = interactions.get().highlightedPoint;\n      if (!point) {\n        return;\n      }\n      // Take the index of the currently highlighted series.\n      const sIndex = point.index.s;\n      // Take the incremented(circularly) x-index of the currently highlighted point.\n      const xIndex = circleIndex(point.index.x + direction, [0, interactions.plot.xs.length - 1]);\n      // Highlight the next point using x:s grouped data.\n      interactions.highlightPoint(interactions.plot.xs[xIndex][sIndex]);\n    };\n    // A helper function to highlight the next or previous point within the selected column.\n    const moveBetweenSeries = direction => {\n      const point = interactions.get().highlightedPoint;\n      if (!point) {\n        const {\n          highlightedX\n        } = interactions.get();\n        if (highlightedX) {\n          const xIndex = highlightedX[0].index.x;\n          const points = interactions.plot.xy[xIndex];\n          const yIndex = direction === 1 ? 0 : points.length - 1;\n          interactions.highlightPoint(points[yIndex]);\n        }\n        return;\n      }\n      // Take the index of the currently highlighted column.\n      const xIndex = point.index.x;\n      const currentYIndex = point.index.y;\n      if (containsMultipleSeries && (currentYIndex === 0 && direction === -1 || currentYIndex === interactions.plot.xy[xIndex].length - 1 && direction === 1)) {\n        interactions.highlightX(interactions.plot.xy[xIndex]);\n      } else {\n        // Take the incremented(circularly) y-index of the currently highlighted point.\n        const nextYIndex = circleIndex(currentYIndex + direction, [0, interactions.plot.xy[xIndex].length - 1]);\n        // Highlight the next point using x:y grouped data.\n        interactions.highlightPoint(interactions.plot.xy[xIndex][nextYIndex]);\n      }\n    };\n    // A callback for svg keydown to enable motions and popover pin with the keyboard.\n    const onSVGKeyDown = event => {\n      const keyCode = event.keyCode;\n      if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n        return;\n      }\n      // Preventing default fixes an issue in Safari+VO when VO additionally interprets arrow keys as its commands.\n      event.preventDefault();\n      // No keydown logic when the popover is pinned.\n      if (interactions.get().isPopoverPinned) {\n        return;\n      }\n      handleKey(event, {\n        onBlockEnd: () => moveBetweenSeries(-1),\n        onBlockStart: () => moveBetweenSeries(1),\n        onInlineStart: () => moveWithinXAxis(-1),\n        onInlineEnd: () => moveWithinXAxis(1),\n        onActivate: () => interactions.pinPopover()\n      });\n    };\n    const highlightFirstX = () => {\n      interactions.highlightX(interactions.plot.xy[0]);\n    };\n    // A callback for application focus to highlight series.\n    const onApplicationFocus = (_event, trigger) => {\n      // When focus is caused by a click event nothing is expected as clicks are handled separately.\n      if (trigger === 'keyboard') {\n        const {\n          highlightedX,\n          highlightedPoint,\n          highlightedSeries,\n          legendSeries\n        } = interactions.get();\n        if (containsMultipleSeries && !highlightedX && !highlightedPoint && !highlightedSeries && !legendSeries) {\n          highlightFirstX();\n        } else if (!highlightedX) {\n          interactions.highlightFirstPoint();\n        }\n      }\n    };\n    // A callback for application blur to clear all highlights unless the popover is pinned.\n    const onApplicationBlur = event => {\n      // Pinned popover stays pinned even if the focus is lost.\n      // If blur is not caused by the popover, forget the previously highlighted point.\n      if (!nodeBelongs(containerRef.current, event.relatedTarget) && !interactions.get().isPopoverPinned) {\n        interactions.clearHighlight();\n      }\n    };\n    const onFilterSeries = series => {\n      stableSetVisibleSeries(series);\n    };\n    const onLegendHighlight = series => {\n      interactions.highlightSeries(series);\n    };\n    const onPopoverDismiss = outsideClick => {\n      interactions.unpinPopover();\n      // Return focus back to the application or plot (when no point is highlighted).\n      if (!outsideClick) {\n        // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n        setTimeout(() => {\n          if (interactions.get().highlightedPoint || interactions.get().highlightedX) {\n            plotRef.current.focusApplication();\n          } else {\n            interactions.clearHighlight();\n            plotRef.current.focusPlot();\n          }\n        }, 0);\n      }\n    };\n    const onContainerBlur = () => {\n      interactions.clearState();\n    };\n    const onDocumentKeyDown = event => {\n      if (event.key === 'Escape') {\n        interactions.clearHighlight();\n        interactions.clearHighlightedLegend();\n      }\n    };\n    const onPopoverLeave = event => {\n      if (nodeContains(plotRef.current.svg, event.relatedTarget) || interactions.get().isPopoverPinned) {\n        return;\n      }\n      interactions.clearHighlight();\n      interactions.clearHighlightedLegend();\n    };\n    return {\n      width,\n      height,\n      series,\n      allSeries,\n      getInternalSeries,\n      computed,\n      interactions,\n      handlers: {\n        onSVGMouseMove,\n        onSVGMouseOut,\n        onSVGMouseDown,\n        onSVGKeyDown,\n        onApplicationFocus,\n        onApplicationBlur,\n        onFilterSeries,\n        onLegendHighlight,\n        onPopoverDismiss,\n        onContainerBlur,\n        onDocumentKeyDown,\n        onPopoverLeave\n      },\n      refs: {\n        plot: plotRef,\n        plotMeasure: plotMeasureRef,\n        container: containerRef,\n        verticalMarker: verticalMarkerRef,\n        popoverRef\n      }\n    };\n  }, [allSeries, series, xDomain, yDomain, xScaleType, yScaleType, height, width, stableSetVisibleSeries, popoverRef, isRtl]);\n  // Notify client when series highlight change.\n  useReaction(model.interactions, state => state.highlightedSeries, setHighlightedSeries);\n  // Update interactions store when series highlight in a controlled way.\n  useEffect(() => {\n    if (highlightedSeries !== model.interactions.get().highlightedSeries) {\n      model.interactions.highlightSeries(highlightedSeries);\n    }\n  }, [model, highlightedSeries]);\n  return model;\n}","map":{"version":3,"names":["useEffect","useMemo","useRef","nodeContains","useStableCallback","useHeightMeasure","KeyCode","circleIndex","handleKey","nodeBelongs","throttle","useReaction","computeChartProps","createSeriesDecorator","InteractionsStore","findClosest","MAX_HOVER_MARGIN","SVG_HOVER_THROTTLE","POPOVER_DEADZONE","useChartModel","isRtl","fitHeight","externalSeries","allSeries","visibleSeries","series","setVisibleSeries","highlightedSeries","setHighlightedSeries","xDomain","yDomain","xScaleType","yScaleType","height","explicitHeight","width","popoverRef","statusType","plotRef","containerRef","verticalMarkerRef","plotMeasureRef","hasVisibleSeries","length","_a","current","stableSetVisibleSeries","model","computed","interactions","plot","containsMultipleSeries","getInternalSeries","isMouseOverPopover","clientX","clientY","firstChild","popoverPosition","getBoundingClientRect","x","y","onSVGMouseMoveThrottled","get","isPopoverPinned","xy","svgRect","svg","offsetX","left","offsetY","top","closestX","xPoints","scaled","closestPoint","point","y1","Math","abs","highlightPoint","highlightX","onSVGMouseMove","onSVGMouseOut","event","cancel","relatedTarget","clearHighlightedLegend","clearHighlight","onSVGMouseDown","togglePopoverPin","preventDefault","moveWithinXAxis","direction","highlightedPoint","moveWithinSeries","highlightedX","currentXIndex","index","nextXIndex","sIndex","s","xIndex","xs","moveBetweenSeries","points","yIndex","currentYIndex","nextYIndex","onSVGKeyDown","keyCode","up","right","down","space","enter","onBlockEnd","onBlockStart","onInlineStart","onInlineEnd","onActivate","pinPopover","highlightFirstX","onApplicationFocus","_event","trigger","legendSeries","highlightFirstPoint","onApplicationBlur","onFilterSeries","onLegendHighlight","highlightSeries","onPopoverDismiss","outsideClick","unpinPopover","setTimeout","focusApplication","focusPlot","onContainerBlur","clearState","onDocumentKeyDown","key","onPopoverLeave","handlers","refs","plotMeasure","container","verticalMarker","state"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/area-chart/model/use-chart-model.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { MouseEvent, RefObject, useEffect, useMemo, useRef } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\n\nimport { XDomain, XScaleType, YDomain, YScaleType } from '../../internal/components/cartesian-chart/interfaces';\nimport { ChartPlotRef } from '../../internal/components/chart-plot';\nimport { useHeightMeasure } from '../../internal/hooks/container-queries/use-height-measure';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport handleKey from '../../internal/utils/handle-key';\nimport { nodeBelongs } from '../../internal/utils/node-belongs';\nimport { throttle } from '../../internal/utils/throttle';\nimport { useReaction } from '../async-store';\nimport { AreaChartProps } from '../interfaces';\nimport computeChartProps from './compute-chart-props';\nimport createSeriesDecorator from './create-series-decorator';\nimport { ChartModel } from './index';\nimport InteractionsStore from './interactions-store';\nimport { findClosest } from './utils';\n\nconst MAX_HOVER_MARGIN = 6;\nconst SVG_HOVER_THROTTLE = 25;\nconst POPOVER_DEADZONE = 12;\n\nexport interface UseChartModelProps<T extends AreaChartProps.DataTypes> {\n  isRtl?: boolean;\n  fitHeight?: boolean;\n  externalSeries: readonly AreaChartProps.Series<T>[];\n  visibleSeries: readonly AreaChartProps.Series<T>[];\n  setVisibleSeries: (series: readonly AreaChartProps.Series<T>[]) => void;\n  highlightedSeries: null | AreaChartProps.Series<T>;\n  setHighlightedSeries: (series: null | AreaChartProps.Series<T>) => void;\n  xDomain?: XDomain<T>;\n  yDomain?: YDomain;\n  xScaleType: XScaleType;\n  yScaleType: YScaleType;\n  height: number;\n  width: number;\n  popoverRef: RefObject<HTMLElement>;\n  statusType: 'loading' | 'finished' | 'error';\n}\n\n// Represents the core the chart logic, including the model of all allowed user interactions.\nexport default function useChartModel<T extends AreaChartProps.DataTypes>({\n  isRtl,\n  fitHeight,\n  externalSeries: allSeries,\n  visibleSeries: series,\n  setVisibleSeries,\n  highlightedSeries,\n  setHighlightedSeries,\n  xDomain,\n  yDomain,\n  xScaleType,\n  yScaleType,\n  height: explicitHeight,\n  width,\n  popoverRef,\n  statusType,\n}: UseChartModelProps<T>): ChartModel<T> {\n  // Chart elements refs used in handlers.\n  const plotRef = useRef<ChartPlotRef>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const verticalMarkerRef = useRef<SVGLineElement>(null);\n\n  const plotMeasureRef = useRef<SVGLineElement>(null);\n  const hasVisibleSeries = series.length > 0;\n  const height =\n    useHeightMeasure(() => plotMeasureRef.current, !fitHeight, [hasVisibleSeries, statusType]) ?? explicitHeight;\n  const stableSetVisibleSeries = useStableCallback(setVisibleSeries);\n\n  const model = useMemo(() => {\n    // Compute scales, ticks and two-dimensional plots.\n    const computed = computeChartProps({\n      isRtl,\n      series,\n      xDomain,\n      yDomain,\n      xScaleType,\n      yScaleType,\n      height,\n      width,\n    });\n\n    // A store for chart interactions that don't require plot recomputation.\n    const interactions = new InteractionsStore(series, computed.plot);\n\n    const containsMultipleSeries = interactions.series.length > 1;\n\n    // A series decorator to provide extra props such as color and marker type.\n    const getInternalSeries = createSeriesDecorator(allSeries);\n\n    const isMouseOverPopover = (clientX: number, clientY: number) => {\n      if (popoverRef.current?.firstChild) {\n        const popoverPosition = (popoverRef.current.firstChild as HTMLElement).getBoundingClientRect();\n        if (\n          clientX > popoverPosition.x - POPOVER_DEADZONE &&\n          clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE &&\n          clientY > popoverPosition.y - POPOVER_DEADZONE &&\n          clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE\n        ) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    // A Callback for svg mouseover to hover the plot points.\n    // Throttling is necessary for a substantially smoother customer experience.\n    const onSVGMouseMoveThrottled = throttle((clientX: number, clientY: number) => {\n      // No hover logic when the popover is pinned or no data available.\n      if (\n        interactions.get().isPopoverPinned ||\n        !plotRef.current ||\n        interactions.plot.xy.length === 0 ||\n        isMouseOverPopover(clientX, clientY)\n      ) {\n        return;\n      }\n\n      const svgRect = plotRef.current.svg.getBoundingClientRect();\n      const offsetX = clientX - svgRect.left;\n      const offsetY = clientY - svgRect.top;\n\n      const closestX = findClosest(interactions.plot.xy, offsetX, xPoints => xPoints[0].scaled.x);\n      const closestPoint = findClosest(closestX, offsetY, point => point.scaled.y1);\n\n      // If close enough to the point - highlight the point and its column.\n      // If not - only highlight the closest column.\n      if (\n        Math.abs(offsetX - closestPoint.scaled.x) < MAX_HOVER_MARGIN &&\n        Math.abs(offsetY - closestPoint.scaled.y1) < MAX_HOVER_MARGIN\n      ) {\n        interactions.highlightPoint(closestPoint);\n      } else {\n        interactions.highlightX(closestX);\n      }\n    }, SVG_HOVER_THROTTLE);\n\n    const onSVGMouseMove = ({ clientX, clientY }: React.MouseEvent<SVGElement>) =>\n      onSVGMouseMoveThrottled(clientX, clientY);\n\n    // A callback for svg mouseout to clear all highlights.\n    const onSVGMouseOut = (event: React.MouseEvent<SVGElement>) => {\n      // Because the mouseover is throttled, in can occur slightly after the mouseout,\n      // neglecting its effect; cancelling the throttled function prevents that.\n      onSVGMouseMoveThrottled.cancel();\n\n      // No hover logic when the popover is pinned or mouse is over popover\n      if (interactions.get().isPopoverPinned || isMouseOverPopover(event.clientX, event.clientY)) {\n        return;\n      }\n\n      // Check if the target is contained within svg to allow hovering on the popover body.\n      if (!nodeContains(plotRef.current!.svg, event.relatedTarget as Element)) {\n        interactions.clearHighlightedLegend();\n        interactions.clearHighlight();\n      }\n    };\n\n    // A callback for svg click to pin/unpin the popover.\n    const onSVGMouseDown = (event: React.MouseEvent<SVGSVGElement>) => {\n      interactions.togglePopoverPin();\n      event.preventDefault();\n    };\n\n    const moveWithinXAxis = (direction: -1 | 1) => {\n      if (interactions.get().highlightedPoint) {\n        return moveWithinSeries(direction);\n      } else if (containsMultipleSeries) {\n        const { highlightedX } = interactions.get();\n        if (highlightedX) {\n          const currentXIndex = highlightedX[0].index.x;\n          const nextXIndex = circleIndex(currentXIndex + direction, [0, interactions.plot.xy.length - 1]);\n          interactions.highlightX(interactions.plot.xy[nextXIndex]);\n        }\n      }\n    };\n\n    // A helper function to highlight the next or previous point within selected series.\n    const moveWithinSeries = (direction: -1 | 1) => {\n      // Can only use motion when a particular point is highlighted.\n      const point = interactions.get().highlightedPoint;\n      if (!point) {\n        return;\n      }\n\n      // Take the index of the currently highlighted series.\n      const sIndex = point.index.s;\n      // Take the incremented(circularly) x-index of the currently highlighted point.\n      const xIndex = circleIndex(point.index.x + direction, [0, interactions.plot.xs.length - 1]);\n      // Highlight the next point using x:s grouped data.\n      interactions.highlightPoint(interactions.plot.xs[xIndex][sIndex]);\n    };\n\n    // A helper function to highlight the next or previous point within the selected column.\n    const moveBetweenSeries = (direction: -1 | 1) => {\n      const point = interactions.get().highlightedPoint;\n      if (!point) {\n        const { highlightedX } = interactions.get();\n        if (highlightedX) {\n          const xIndex = highlightedX[0].index.x;\n          const points = interactions.plot.xy[xIndex];\n          const yIndex = direction === 1 ? 0 : points.length - 1;\n          interactions.highlightPoint(points[yIndex]);\n        }\n        return;\n      }\n\n      // Take the index of the currently highlighted column.\n      const xIndex = point.index.x;\n      const currentYIndex = point.index.y;\n\n      if (\n        containsMultipleSeries &&\n        ((currentYIndex === 0 && direction === -1) ||\n          (currentYIndex === interactions.plot.xy[xIndex].length - 1 && direction === 1))\n      ) {\n        interactions.highlightX(interactions.plot.xy[xIndex]);\n      } else {\n        // Take the incremented(circularly) y-index of the currently highlighted point.\n        const nextYIndex = circleIndex(currentYIndex + direction, [0, interactions.plot.xy[xIndex].length - 1]);\n        // Highlight the next point using x:y grouped data.\n        interactions.highlightPoint(interactions.plot.xy[xIndex][nextYIndex]);\n      }\n    };\n\n    // A callback for svg keydown to enable motions and popover pin with the keyboard.\n    const onSVGKeyDown = (event: React.KeyboardEvent<HTMLElement | SVGElement>) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      // Preventing default fixes an issue in Safari+VO when VO additionally interprets arrow keys as its commands.\n      event.preventDefault();\n\n      // No keydown logic when the popover is pinned.\n      if (interactions.get().isPopoverPinned) {\n        return;\n      }\n\n      handleKey(event, {\n        onBlockEnd: () => moveBetweenSeries(-1),\n        onBlockStart: () => moveBetweenSeries(1),\n        onInlineStart: () => moveWithinXAxis(-1),\n        onInlineEnd: () => moveWithinXAxis(1),\n        onActivate: () => interactions.pinPopover(),\n      });\n    };\n\n    const highlightFirstX = () => {\n      interactions.highlightX(interactions.plot.xy[0]);\n    };\n\n    // A callback for application focus to highlight series.\n    const onApplicationFocus = (_event: React.FocusEvent, trigger: 'mouse' | 'keyboard') => {\n      // When focus is caused by a click event nothing is expected as clicks are handled separately.\n      if (trigger === 'keyboard') {\n        const { highlightedX, highlightedPoint, highlightedSeries, legendSeries } = interactions.get();\n        if (containsMultipleSeries && !highlightedX && !highlightedPoint && !highlightedSeries && !legendSeries) {\n          highlightFirstX();\n        } else if (!highlightedX) {\n          interactions.highlightFirstPoint();\n        }\n      }\n    };\n\n    // A callback for application blur to clear all highlights unless the popover is pinned.\n    const onApplicationBlur = (event: React.FocusEvent<Element>) => {\n      // Pinned popover stays pinned even if the focus is lost.\n      // If blur is not caused by the popover, forget the previously highlighted point.\n      if (!nodeBelongs(containerRef.current, event.relatedTarget) && !interactions.get().isPopoverPinned) {\n        interactions.clearHighlight();\n      }\n    };\n\n    const onFilterSeries = (series: readonly AreaChartProps.Series<T>[]) => {\n      stableSetVisibleSeries(series);\n    };\n\n    const onLegendHighlight = (series: null | AreaChartProps.Series<T>) => {\n      interactions.highlightSeries(series);\n    };\n\n    const onPopoverDismiss = (outsideClick?: boolean) => {\n      interactions.unpinPopover();\n\n      // Return focus back to the application or plot (when no point is highlighted).\n      if (!outsideClick) {\n        // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.\n        setTimeout(() => {\n          if (interactions.get().highlightedPoint || interactions.get().highlightedX) {\n            plotRef.current!.focusApplication();\n          } else {\n            interactions.clearHighlight();\n            plotRef.current!.focusPlot();\n          }\n        }, 0);\n      }\n    };\n\n    const onContainerBlur = () => {\n      interactions.clearState();\n    };\n\n    const onDocumentKeyDown = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        interactions.clearHighlight();\n        interactions.clearHighlightedLegend();\n      }\n    };\n\n    const onPopoverLeave = (event: MouseEvent) => {\n      if (nodeContains(plotRef.current!.svg, event.relatedTarget as Element) || interactions.get().isPopoverPinned) {\n        return;\n      }\n      interactions.clearHighlight();\n      interactions.clearHighlightedLegend();\n    };\n    return {\n      width,\n      height,\n      series,\n      allSeries,\n      getInternalSeries,\n      computed,\n      interactions,\n      handlers: {\n        onSVGMouseMove,\n        onSVGMouseOut,\n        onSVGMouseDown,\n        onSVGKeyDown,\n        onApplicationFocus,\n        onApplicationBlur,\n        onFilterSeries,\n        onLegendHighlight,\n        onPopoverDismiss,\n        onContainerBlur,\n        onDocumentKeyDown,\n        onPopoverLeave,\n      },\n      refs: {\n        plot: plotRef,\n        plotMeasure: plotMeasureRef,\n        container: containerRef,\n        verticalMarker: verticalMarkerRef,\n        popoverRef,\n      },\n    };\n  }, [\n    allSeries,\n    series,\n    xDomain,\n    yDomain,\n    xScaleType,\n    yScaleType,\n    height,\n    width,\n    stableSetVisibleSeries,\n    popoverRef,\n    isRtl,\n  ]);\n\n  // Notify client when series highlight change.\n  useReaction(model.interactions, state => state.highlightedSeries, setHighlightedSeries);\n\n  // Update interactions store when series highlight in a controlled way.\n  useEffect(() => {\n    if (highlightedSeries !== model.interactions.get().highlightedSeries) {\n      model.interactions.highlightSeries(highlightedSeries);\n    }\n  }, [model, highlightedSeries]);\n\n  return model;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}