{"ast":null,"code":"import { warnOnce } from '@cloudscape-design/component-toolkit/internal';\nimport { KeyCode } from '../../keycode';\nimport { backspaceHandler, enterHandler, keyHandler } from './keyboard-handler';\nimport { isCommand, isDigit } from './utils/keys';\nconst onAutoComplete = (value, onChange, maskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\nconst preventDefault = (event, result) => result && event.preventDefault();\nconst useMask = _ref => {\n  let {\n    value = '',\n    onBlur,\n    onChange,\n    onKeyDown,\n    format,\n    inputRef,\n    autofix = false,\n    disableAutocompleteOnBlur = false,\n    setPosition\n  } = _ref;\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n  const onMaskChange = updatedValue => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n    onChange(autofixedUpdatedValue);\n  };\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n  return {\n    value: maskedValue,\n    onKeyDown: event => {\n      var _a, _b;\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      let result;\n      const {\n        keyCode,\n        key,\n        ctrlKey,\n        metaKey\n      } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n      if (result) {\n        const {\n          value,\n          position\n        } = result;\n        onMaskChange(value);\n        setPosition(position);\n      }\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: _ref2 => {\n      let {\n        detail\n      } = _ref2;\n      return onMaskChange(detail.value);\n    },\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n      onBlur && onBlur();\n    },\n    onPaste: event => {\n      var _a, _b;\n      const text = (event.clipboardData || window.clipboardData).getData('text');\n      const selectionStart = ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.selectionStart) || 0;\n      const selectionEnd = ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.selectionEnd) || 0;\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    }\n  };\n};\nexport default useMask;","map":{"version":3,"names":["warnOnce","KeyCode","backspaceHandler","enterHandler","keyHandler","isCommand","isDigit","onAutoComplete","value","onChange","maskFormat","autoCompletedValue","autoComplete","preventDefault","event","result","useMask","_ref","onBlur","onKeyDown","format","inputRef","autofix","disableAutocompleteOnBlur","setPosition","isValid","onMaskChange","updatedValue","autofixedUpdatedValue","correctMinMaxValues","initialValue","maskedValue","getValidValue","selectionStart","_a","current","selectionEnd","_b","keyCode","key","ctrlKey","metaKey","detail","isSeparator","backspace","enter","position","_ref2","onPaste","text","clipboardData","window","getData","formattedText","formatPastedText"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/components/masked-input/use-mask.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject } from 'react';\n\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\n\nimport { InputProps } from '../../../input/interfaces';\nimport { CancelableEventHandler, NonCancelableEventHandler } from '../../events';\nimport { KeyCode } from '../../keycode';\nimport { backspaceHandler, enterHandler, HandlerResult, keyHandler } from './keyboard-handler';\nimport { isCommand, isDigit } from './utils/keys';\nimport MaskFormat from './utils/mask-format';\n\ninterface UseMaskHook {\n  value: string;\n  onChange: NonCancelableEventHandler<InputProps.ChangeDetail>;\n  onKeyDown: CancelableEventHandler<InputProps.KeyDetail>;\n  onBlur: NonCancelableEventHandler<null>;\n  onPaste: (event: React.ClipboardEvent) => void;\n}\n\ninterface UseMaskProps {\n  value: string;\n  onChange: (value: string) => void;\n  onKeyDown?: (event: CustomEvent) => void;\n  onBlur?: () => void;\n  format: MaskFormat;\n  autofix?: boolean;\n  inputRef: RefObject<HTMLInputElement>;\n  disableAutocompleteOnBlur?: boolean;\n  setPosition: (position: number | null) => void;\n}\n\nconst onAutoComplete = (value: string, onChange: UseMaskProps['onChange'], maskFormat: MaskFormat) => {\n  // Do not autocomplete if input is empty\n  if (!value) {\n    return;\n  }\n\n  const autoCompletedValue = maskFormat.autoComplete(value);\n  if (autoCompletedValue !== value) {\n    onChange(autoCompletedValue);\n  }\n};\n\nconst preventDefault = (event: CustomEvent, result?: HandlerResult | null) => result && event.preventDefault();\n\nconst useMask = ({\n  value = '',\n  onBlur,\n  onChange,\n  onKeyDown,\n  format,\n  inputRef,\n  autofix = false,\n  disableAutocompleteOnBlur = false,\n  setPosition,\n}: UseMaskProps): UseMaskHook => {\n  if (!format.isValid(value)) {\n    warnOnce('useMask', `Invalid string \"${value}\" provided`);\n  }\n\n  const onMaskChange = (updatedValue: string) => {\n    const autofixedUpdatedValue = autofix ? format.correctMinMaxValues(updatedValue) : updatedValue;\n    if (autofixedUpdatedValue === value || !format.isValid(autofixedUpdatedValue)) {\n      return;\n    }\n\n    onChange(autofixedUpdatedValue);\n  };\n\n  const initialValue = autofix ? format.correctMinMaxValues(value) : value;\n  const maskedValue = format.getValidValue(initialValue);\n\n  return {\n    value: maskedValue,\n    onKeyDown: (event: CustomEvent) => {\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      let result: HandlerResult | undefined;\n      const { keyCode, key, ctrlKey, metaKey } = event.detail;\n      if (isDigit(key) || format.isSeparator(key)) {\n        result = keyHandler(maskedValue, key, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.backspace) {\n        result = backspaceHandler(maskedValue, format, selectionStart, selectionEnd);\n        preventDefault(event, result);\n      } else if (keyCode === KeyCode.enter) {\n        result = enterHandler(maskedValue, format);\n      } else if (!isCommand(keyCode, ctrlKey, metaKey)) {\n        event.preventDefault();\n      }\n\n      if (result) {\n        const { value, position } = result;\n\n        onMaskChange(value);\n        setPosition(position);\n      }\n\n      // Proxy original event\n      onKeyDown && onKeyDown(event);\n    },\n    onChange: ({ detail }) => onMaskChange(detail.value),\n    onBlur: () => {\n      if (!disableAutocompleteOnBlur) {\n        onAutoComplete(maskedValue, onChange, format);\n      }\n\n      onBlur && onBlur();\n    },\n    onPaste: (event: React.ClipboardEvent) => {\n      const text = (event.clipboardData || (window as any).clipboardData).getData('text');\n\n      const selectionStart = inputRef.current?.selectionStart || 0;\n      const selectionEnd = inputRef.current?.selectionEnd || 0;\n\n      const formattedText = format.formatPastedText(text, maskedValue, selectionStart, selectionEnd);\n      onMaskChange(formattedText);\n    },\n  };\n};\n\nexport default useMask;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}