{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\n/**\n * A hook that uses an Intersection Observer on the target element ref\n * and detects if the element is intersecting with its parent.\n */\nexport function useIntersectionObserver() {\n  const observerRef = useRef(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n  const ref = useCallback(targetElement => {\n    if (typeof IntersectionObserver === 'undefined') {\n      // Do nothing in environments like JSDOM\n      return;\n    }\n    if (observerRef.current) {\n      // Dismiss previous observer because the target changed\n      observerRef.current.disconnect();\n    }\n    // Create a new observer with the target element\n    if (targetElement) {\n      observerRef.current = new IntersectionObserver(_ref => {\n        let [entry] = _ref;\n        return setIsIntersecting(entry.isIntersecting);\n      });\n      observerRef.current.observe(targetElement);\n    }\n  }, []);\n  return {\n    ref,\n    isIntersecting\n  };\n}","map":{"version":3,"names":["useCallback","useRef","useState","useIntersectionObserver","observerRef","isIntersecting","setIsIntersecting","ref","targetElement","IntersectionObserver","current","disconnect","_ref","entry","observe"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/hooks/use-intersection-observer/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RefCallback, useCallback, useRef, useState } from 'react';\n\n/**\n * A hook that uses an Intersection Observer on the target element ref\n * and detects if the element is intersecting with its parent.\n */\nexport function useIntersectionObserver<T extends HTMLElement>() {\n  const observerRef = useRef<IntersectionObserver | null>(null);\n  const [isIntersecting, setIsIntersecting] = useState(false);\n\n  const ref = useCallback<RefCallback<T>>(targetElement => {\n    if (typeof IntersectionObserver === 'undefined') {\n      // Do nothing in environments like JSDOM\n      return;\n    }\n\n    if (observerRef.current) {\n      // Dismiss previous observer because the target changed\n      observerRef.current.disconnect();\n    }\n\n    // Create a new observer with the target element\n    if (targetElement) {\n      observerRef.current = new IntersectionObserver(([entry]) => setIsIntersecting(entry.isIntersecting));\n      observerRef.current.observe(targetElement);\n    }\n  }, []);\n\n  return { ref, isIntersecting };\n}\n"],"mappings":"AAAA;AACA;AAEA,SAAsBA,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAElE;;;;AAIA,OAAM,SAAUC,uBAAuBA,CAAA;EACrC,MAAMC,WAAW,GAAGH,MAAM,CAA8B,IAAI,CAAC;EAC7D,MAAM,CAACI,cAAc,EAAEC,iBAAiB,CAAC,GAAGJ,QAAQ,CAAC,KAAK,CAAC;EAE3D,MAAMK,GAAG,GAAGP,WAAW,CAAiBQ,aAAa,IAAG;IACtD,IAAI,OAAOC,oBAAoB,KAAK,WAAW,EAAE;MAC/C;MACA;;IAGF,IAAIL,WAAW,CAACM,OAAO,EAAE;MACvB;MACAN,WAAW,CAACM,OAAO,CAACC,UAAU,EAAE;;IAGlC;IACA,IAAIH,aAAa,EAAE;MACjBJ,WAAW,CAACM,OAAO,GAAG,IAAID,oBAAoB,CAACG,IAAA;QAAA,IAAC,CAACC,KAAK,CAAC,GAAAD,IAAA;QAAA,OAAKN,iBAAiB,CAACO,KAAK,CAACR,cAAc,CAAC;MAAA,EAAC;MACpGD,WAAW,CAACM,OAAO,CAACI,OAAO,CAACN,aAAa,CAAC;;EAE9C,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IAAED,GAAG;IAAEF;EAAc,CAAE;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}