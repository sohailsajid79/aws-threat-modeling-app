{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getBreakpointValue } from '../../breakpoints';\nimport { getOverflowParentDimensions, getOverflowParents } from '../../utils/scrollable-containers';\nimport styles from './styles.css.js';\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\nconst getClosestParentDimensions = element => {\n  const parents = getOverflowParents(element).map(element => {\n    const {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart\n    } = getLogicalBoundingClientRect(element);\n    return {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart\n    };\n  });\n  return parents.shift();\n};\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\nexport const getAvailableSpace = _ref => {\n  let {\n    trigger,\n    overflowParents,\n    stretchWidth = false,\n    stretchHeight = false,\n    isMobile\n  } = _ref;\n  const availableSpaceReserveVertical = stretchHeight ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd\n  } = getLogicalBoundingClientRect(trigger);\n  return overflowParents.reduce((_ref2, overflowParent) => {\n    let {\n      blockStart,\n      blockEnd,\n      inlineStart,\n      inlineEnd\n    } = _ref2;\n    const offsetTop = triggerBlockEnd - overflowParent.insetBlockStart;\n    const currentBlockStart = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n    const currentBlockEnd = overflowParent.blockSize - offsetTop - availableSpaceReserveVertical;\n    const currentInlineStart = triggerInlineEnd - overflowParent.insetInlineStart - availableSpaceReserveHorizontal;\n    const currentInlineEnd = overflowParent.insetInlineStart + overflowParent.inlineSize - triggerInlineStart - availableSpaceReserveHorizontal;\n    return {\n      blockStart: Math.min(blockStart, currentBlockStart),\n      blockEnd: Math.min(blockEnd, currentBlockEnd),\n      inlineStart: Math.min(inlineStart, currentInlineStart),\n      inlineEnd: Math.min(inlineEnd, currentInlineEnd)\n    };\n  }, {\n    blockStart: Number.MAX_VALUE,\n    blockEnd: Number.MAX_VALUE,\n    inlineStart: Number.MAX_VALUE,\n    inlineEnd: Number.MAX_VALUE\n  });\n};\nexport const getInteriorAvailableSpace = _ref3 => {\n  let {\n    trigger,\n    overflowParents,\n    isMobile\n  } = _ref3;\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd\n  } = getLogicalBoundingClientRect(trigger);\n  return overflowParents.reduce((_ref4, overflowParent) => {\n    let {\n      blockStart,\n      blockEnd,\n      inlineStart,\n      inlineEnd\n    } = _ref4;\n    const currentBlockStart = triggerBlockEnd - overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentBlockEnd = overflowParent.blockSize - triggerBlockStart + overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentInlineStart = triggerInlineStart - overflowParent.insetInlineStart - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    const currentInlineEnd = overflowParent.insetInlineStart + overflowParent.inlineSize - triggerInlineEnd - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    return {\n      blockStart: Math.min(blockStart, currentBlockStart),\n      blockEnd: Math.min(blockEnd, currentBlockEnd),\n      inlineStart: Math.min(inlineStart, currentInlineStart),\n      inlineEnd: Math.min(inlineEnd, currentInlineEnd)\n    };\n  }, {\n    blockStart: Number.MAX_VALUE,\n    blockEnd: Number.MAX_VALUE,\n    inlineStart: Number.MAX_VALUE,\n    inlineEnd: Number.MAX_VALUE\n  });\n};\nexport const getWidths = _ref5 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth = false\n  } = _ref5;\n  // Determine the width of the trigger\n  const {\n    inlineSize: triggerInlineSize\n  } = getLogicalBoundingClientRect(triggerElement);\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerInlineSize, desiredMinWidth) : triggerInlineSize;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerInlineSize) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const {\n    inlineSize: requiredWidth\n  } = getLogicalBoundingClientRect(dropdownElement);\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return {\n    idealWidth,\n    minWidth,\n    triggerInlineSize\n  };\n};\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = _ref6 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    expandToViewport,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  } = _ref6;\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const {\n    idealWidth\n  } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  return idealWidth <= availableSpace.inlineStart || idealWidth <= availableSpace.inlineEnd;\n};\nexport const getDropdownPosition = _ref7 => {\n  let {\n    triggerElement,\n    dropdownElement,\n    overflowParents,\n    minWidth: desiredMinWidth,\n    preferCenter = false,\n    stretchWidth = false,\n    stretchHeight = false,\n    isMobile = false,\n    stretchBeyondTriggerWidth = false\n  } = _ref7;\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  const {\n    idealWidth,\n    minWidth,\n    triggerInlineSize\n  } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth\n  });\n  let dropInlineStart;\n  let insetInlineStart = null;\n  let inlineSize = idealWidth;\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd, minWidth);\n  }\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerInlineSize) / 2;\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.inlineStart - triggerInlineSize;\n    const availableOutsideRight = availableSpace.inlineEnd - triggerInlineSize;\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      insetInlineStart = -spillOver;\n    }\n  }\n  const dropBlockStart = availableSpace.blockEnd < dropdownElement.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    insetInlineStart: insetInlineStart === null ? 'auto' : `${insetInlineStart}px`,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`\n  };\n};\nexport const getInteriorDropdownPosition = (trigger, dropdown, overflowParents, isMobile) => {\n  const availableSpace = getInteriorAvailableSpace({\n    trigger,\n    overflowParents,\n    isMobile\n  });\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    inlineSize: triggerInlineSize\n  } = getLogicalBoundingClientRect(trigger);\n  const {\n    insetBlockStart: parentDropdownBlockStart,\n    blockSize: parentDropdownHeight\n  } = getClosestParentDimensions(trigger);\n  let dropInlineStart;\n  let {\n    inlineSize\n  } = getLogicalBoundingClientRect(dropdown);\n  const insetBlockStart = triggerBlockStart - parentDropdownBlockStart;\n  if (inlineSize <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n  } else if (inlineSize <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd);\n  }\n  const insetInlineStart = dropInlineStart ? 0 - inlineSize : triggerInlineSize;\n  const dropBlockStart = availableSpace.blockEnd < dropdown.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const insetBlockEnd = dropBlockStart ? parentDropdownBlockStart + parentDropdownHeight - triggerBlockEnd : 0;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n    insetBlockStart: `${insetBlockStart}px`,\n    insetBlockEnd: `${insetBlockEnd}px`,\n    insetInlineStart: `${insetInlineStart}px`\n  };\n};\nexport const calculatePosition = (dropdownElement, triggerElement, verticalContainerElement, interior, expandToViewport, preferCenter, stretchWidth, stretchHeight, isMobile, minWidth, stretchBeyondTriggerWidth) => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxBlockSize = '';\n  dropdownElement.style.inlineSize = '';\n  dropdownElement.style.insetBlockStart = '';\n  dropdownElement.style.insetBlockEnd = '';\n  dropdownElement.style.insetInlineStart = '';\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const position = interior ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile) : getDropdownPosition({\n    triggerElement,\n    dropdownElement,\n    overflowParents,\n    minWidth,\n    preferCenter,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n    stretchBeyondTriggerWidth\n  });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};","map":{"version":3,"names":["getLogicalBoundingClientRect","getBreakpointValue","getOverflowParentDimensions","getOverflowParents","styles","AVAILABLE_SPACE_RESERVE_DEFAULT","AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL","AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL","getClosestParentDimensions","element","parents","map","blockSize","inlineSize","insetBlockStart","insetInlineStart","shift","defaultMaxDropdownWidth","getAvailableSpace","_ref","trigger","overflowParents","stretchWidth","stretchHeight","isMobile","availableSpaceReserveVertical","availableSpaceReserveHorizontal","insetBlockEnd","triggerBlockEnd","triggerInlineStart","insetInlineEnd","triggerInlineEnd","reduce","_ref2","overflowParent","blockStart","blockEnd","inlineStart","inlineEnd","offsetTop","currentBlockStart","offsetHeight","currentBlockEnd","currentInlineStart","currentInlineEnd","Math","min","Number","MAX_VALUE","getInteriorAvailableSpace","_ref3","AVAILABLE_SPACE_RESERVE_VERTICAL","AVAILABLE_SPACE_RESERVE_HORIZONTAL","triggerBlockStart","_ref4","getWidths","_ref5","triggerElement","dropdownElement","desiredMinWidth","stretchBeyondTriggerWidth","triggerInlineSize","minWidth","maxWidth","max","requiredWidth","idealWidth","hasEnoughSpaceToStretchBeyondTriggerWidth","_ref6","expandToViewport","excludeClosestParent","canExpandOutsideViewport","availableSpace","getDropdownPosition","_ref7","preferCenter","dropInlineStart","spillOver","availableOutsideLeft","availableOutsideRight","fitsInCenter","dropBlockStart","availableHeight","croppedHeight","floor","getInteriorDropdownPosition","dropdown","parentDropdownBlockStart","parentDropdownHeight","calculatePosition","verticalContainerElement","interior","style","maxBlockSize","classList","remove","position","triggerBox","getBoundingClientRect"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/components/dropdown/dropdown-fit-handler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getBreakpointValue } from '../../breakpoints';\nimport { BoundingBox, getOverflowParentDimensions, getOverflowParents } from '../../utils/scrollable-containers';\n\nimport styles from './styles.css.js';\n\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\n\ninterface AvailableSpace {\n  blockStart: number;\n  blockEnd: number;\n  inlineStart: number;\n  inlineEnd: number;\n}\nexport interface DropdownPosition {\n  blockSize: string;\n  inlineSize: string;\n  dropBlockStart: boolean;\n  dropInlineStart: boolean;\n  insetInlineStart: string;\n}\nexport interface InteriorDropdownPosition extends DropdownPosition {\n  insetBlockEnd: string;\n  insetBlockStart: string;\n}\n\nconst getClosestParentDimensions = (element: HTMLElement): any => {\n  const parents = getOverflowParents(element).map(element => {\n    const { blockSize, inlineSize, insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(element);\n    return {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart,\n    };\n  });\n\n  return parents.shift();\n};\n\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\n\nexport const getAvailableSpace = ({\n  trigger,\n  overflowParents,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const availableSpaceReserveVertical = stretchHeight\n    ? 0\n    : isMobile\n      ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n      : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth\n    ? 0\n    : isMobile\n      ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n      : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd,\n  } = getLogicalBoundingClientRect(trigger);\n\n  return overflowParents.reduce(\n    ({ blockStart, blockEnd, inlineStart, inlineEnd }, overflowParent) => {\n      const offsetTop = triggerBlockEnd - overflowParent.insetBlockStart;\n      const currentBlockStart = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n      const currentBlockEnd = overflowParent.blockSize - offsetTop - availableSpaceReserveVertical;\n      const currentInlineStart = triggerInlineEnd - overflowParent.insetInlineStart - availableSpaceReserveHorizontal;\n      const currentInlineEnd =\n        overflowParent.insetInlineStart +\n        overflowParent.inlineSize -\n        triggerInlineStart -\n        availableSpaceReserveHorizontal;\n\n      return {\n        blockStart: Math.min(blockStart, currentBlockStart),\n        blockEnd: Math.min(blockEnd, currentBlockEnd),\n        inlineStart: Math.min(inlineStart, currentInlineStart),\n        inlineEnd: Math.min(inlineEnd, currentInlineEnd),\n      };\n    },\n    {\n      blockStart: Number.MAX_VALUE,\n      blockEnd: Number.MAX_VALUE,\n      inlineStart: Number.MAX_VALUE,\n      inlineEnd: Number.MAX_VALUE,\n    }\n  );\n};\n\nexport const getInteriorAvailableSpace = ({\n  trigger,\n  overflowParents,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd,\n  } = getLogicalBoundingClientRect(trigger);\n\n  return overflowParents.reduce(\n    ({ blockStart, blockEnd, inlineStart, inlineEnd }, overflowParent) => {\n      const currentBlockStart = triggerBlockEnd - overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentBlockEnd =\n        overflowParent.blockSize -\n        triggerBlockStart +\n        overflowParent.insetBlockStart -\n        AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentInlineStart =\n        triggerInlineStart - overflowParent.insetInlineStart - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n      const currentInlineEnd =\n        overflowParent.insetInlineStart +\n        overflowParent.inlineSize -\n        triggerInlineEnd -\n        AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n\n      return {\n        blockStart: Math.min(blockStart, currentBlockStart),\n        blockEnd: Math.min(blockEnd, currentBlockEnd),\n        inlineStart: Math.min(inlineStart, currentInlineStart),\n        inlineEnd: Math.min(inlineEnd, currentInlineEnd),\n      };\n    },\n    {\n      blockStart: Number.MAX_VALUE,\n      blockEnd: Number.MAX_VALUE,\n      inlineStart: Number.MAX_VALUE,\n      inlineEnd: Number.MAX_VALUE,\n    }\n  );\n};\n\nexport const getWidths = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  stretchBeyondTriggerWidth?: boolean;\n}) => {\n  // Determine the width of the trigger\n  const { inlineSize: triggerInlineSize } = getLogicalBoundingClientRect(triggerElement);\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerInlineSize, desiredMinWidth) : triggerInlineSize;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerInlineSize) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const { inlineSize: requiredWidth } = getLogicalBoundingClientRect(dropdownElement);\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return { idealWidth, minWidth, triggerInlineSize };\n};\n\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  expandToViewport,\n  stretchWidth,\n  stretchHeight,\n  isMobile,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  expandToViewport: boolean;\n  stretchWidth: boolean;\n  stretchHeight: boolean;\n  isMobile: boolean;\n}) => {\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const { idealWidth } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true,\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  return idealWidth <= availableSpace.inlineStart || idealWidth <= availableSpace.inlineEnd;\n};\n\nexport const getDropdownPosition = ({\n  triggerElement,\n  dropdownElement,\n  overflowParents,\n  minWidth: desiredMinWidth,\n  preferCenter = false,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile = false,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  minWidth?: number;\n  preferCenter?: boolean;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n  stretchBeyondTriggerWidth?: boolean;\n}): DropdownPosition => {\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  const { idealWidth, minWidth, triggerInlineSize } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth,\n  });\n\n  let dropInlineStart: boolean;\n  let insetInlineStart: number | null = null;\n  let inlineSize = idealWidth;\n\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd, minWidth);\n  }\n\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerInlineSize) / 2;\n\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.inlineStart - triggerInlineSize;\n    const availableOutsideRight = availableSpace.inlineEnd - triggerInlineSize;\n\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      insetInlineStart = -spillOver;\n    }\n  }\n\n  const dropBlockStart =\n    availableSpace.blockEnd < dropdownElement.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    insetInlineStart: insetInlineStart === null ? 'auto' : `${insetInlineStart}px`,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n  };\n};\n\nexport const getInteriorDropdownPosition = (\n  trigger: HTMLElement,\n  dropdown: HTMLElement,\n  overflowParents: ReadonlyArray<BoundingBox>,\n  isMobile?: boolean\n): InteriorDropdownPosition => {\n  const availableSpace = getInteriorAvailableSpace({ trigger, overflowParents, isMobile });\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    inlineSize: triggerInlineSize,\n  } = getLogicalBoundingClientRect(trigger);\n  const { insetBlockStart: parentDropdownBlockStart, blockSize: parentDropdownHeight } =\n    getClosestParentDimensions(trigger);\n\n  let dropInlineStart;\n\n  let { inlineSize } = getLogicalBoundingClientRect(dropdown);\n  const insetBlockStart = triggerBlockStart - parentDropdownBlockStart;\n  if (inlineSize <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n  } else if (inlineSize <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd);\n  }\n\n  const insetInlineStart = dropInlineStart ? 0 - inlineSize : triggerInlineSize;\n\n  const dropBlockStart =\n    availableSpace.blockEnd < dropdown.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const insetBlockEnd = dropBlockStart ? parentDropdownBlockStart + parentDropdownHeight - triggerBlockEnd : 0;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n    insetBlockStart: `${insetBlockStart}px`,\n    insetBlockEnd: `${insetBlockEnd}px`,\n    insetInlineStart: `${insetInlineStart}px`,\n  };\n};\n\nexport const calculatePosition = (\n  dropdownElement: HTMLDivElement,\n  triggerElement: HTMLDivElement,\n  verticalContainerElement: HTMLDivElement,\n  interior: boolean,\n  expandToViewport: boolean,\n  preferCenter: boolean,\n  stretchWidth: boolean,\n  stretchHeight: boolean,\n  isMobile: boolean,\n  minWidth?: number,\n  stretchBeyondTriggerWidth?: boolean\n): [DropdownPosition, DOMRect] => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxBlockSize = '';\n  dropdownElement.style.inlineSize = '';\n  dropdownElement.style.insetBlockStart = '';\n  dropdownElement.style.insetBlockEnd = '';\n  dropdownElement.style.insetInlineStart = '';\n\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const position = interior\n    ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile)\n    : getDropdownPosition({\n        triggerElement,\n        dropdownElement,\n        overflowParents,\n        minWidth,\n        preferCenter,\n        stretchWidth,\n        stretchHeight,\n        isMobile,\n        stretchBeyondTriggerWidth,\n      });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}