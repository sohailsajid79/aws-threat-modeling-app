{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { findNextSolutions, MoveSolutionState } from \"./engine-solution\";\nimport { checkItemsIntersection, sortGridItems } from \"./utils\";\nimport { createMove } from \"./utils\";\n// The solutions can't be searched for infinitely in case the algorithm can't converge.\n// The safety counter ensures there is going to be user feedback within reasonable time.\nconst MAX_SOLUTION_DEPTH = 100;\n// At any given step only a few best solutions are taken to ensure faster convergence.\n// The larger the number the better chance the most optimal solution is found for the given priorities\n// at a cost of more computations made.\nconst NUM_BEST_SOLUTIONS = 5;\n/**\n * The function takes the current layout state (item placements from the previous steps and all moves done so far)\n * and a user command increment that describes an item transition by one cell in some direction.\n * The function finds overlapping elements and resolves all overlaps if possible (always possible when no conflicts).\n * The result in an updated state (new item placements, additional moves, and item conflicts if any).\n */\nexport function resolveOverlaps(layoutState, userMove) {\n  // For better UX the layout engine is optimized for item swaps.\n  // The swapping is only preferred for the user-controlled item and it can only happen when the item overlaps another\n  // item past its midpoint. When the overlap is not enough, the underlying item is considered a conflict and it is not\n  // allowed to move anywhere. The user command cannot be committed at this step.\n  const conflicts = findConflicts(layoutState.grid, layoutState.conflicts, userMove);\n  // The user moves are always applied as is. When the user-controlled item overlaps with other items and there is\n  // no conflict, the type=\"OVERLAP\" moves are performed to settle the grid so that no items overlap with one another.\n  // For this type of move multiple solutions are often available. To ensure the best result all solutions are tried\n  // and a score is given to each. The solution with the minimal score wins.\n  // The process stars from the initial state and the user move. The initial score and the user move score are 0.\n  const initialState = new MoveSolutionState(layoutState.grid, layoutState.moves, conflicts);\n  const initialSolution = [initialState, userMove];\n  // All solutions are guaranteed to have unique move sequences but different move sequences can produce the same result.\n  // As it is never expected for one item to be moved over to the same location twice the combination of the item ID,\n  // item position, and solution score can uniquely represent the solution.\n  // For earlier moves taking a solution from the cache can prevent hundreds of subsequent computations.\n  const solutionsCache = new Map();\n  const createCacheKey = ([state, move]) => `${move.itemId} ${move.x}:${move.y}:${state.score + move.score}`;\n  let moveSolutions = [initialSolution];\n  let bestSolution = null;\n  let convergenceCounter = MAX_SOLUTION_DEPTH;\n  // The resolution process continues until there is at least one reasonable solution left.\n  // The repetitive, dead-end, and expensive (compared to the best so far) solutions are excluded\n  // so that eventually no more variants to try remain.\n  // The convergence safety counter ensures the logical errors to not cause an infinite loop.\n  while (moveSolutions.length > 0) {\n    let nextSolutions = [];\n    for (let solutionIndex = 0; solutionIndex < Math.min(NUM_BEST_SOLUTIONS, moveSolutions.length); solutionIndex++) {\n      const [solutionState, solutionMove] = moveSolutions[solutionIndex];\n      // Discard the solution before performing the move if its next score is already above the best score found so far.\n      if (bestSolution && solutionState.score + solutionMove.score >= bestSolution.score) {\n        continue;\n      }\n      // Perform the move by mutating the solution's state: grid, moves, score, etc.\n      makeMove(solutionState, solutionMove);\n      // If no overlaps are left the solution is considered valid and the best so far.\n      // The next solutions having the same or higher score will be discarded.\n      if (solutionState.overlaps.size === 0) {\n        bestSolution = solutionState;\n      }\n      // Otherwise, the next set of solutions will be considered. There can be up to four solutions per overlap\n      // (by the number of possible directions to move).\n      else {\n        for (const nextSolution of findNextSolutions(solutionState)) {\n          const solutionKey = createCacheKey(nextSolution);\n          const cachedSolution = solutionsCache.get(solutionKey);\n          if (!cachedSolution) {\n            nextSolutions.push(nextSolution);\n            solutionsCache.set(solutionKey, nextSolution);\n          }\n        }\n      }\n    }\n    // The solutions are ordered by the total score so that the best (so far) solutions are considered first.\n    moveSolutions = nextSolutions.sort((s1, s2) => s1[0].score + s1[1].score - (s2[0].score + s2[1].score));\n    nextSolutions = [];\n    // Reaching the convergence counter might indicate an issue with the algorithm as ideally it should converge faster.\n    // However, that does not necessarily mean the logical problem and no exception should be thrown.\n    // Instead, the current best solution if available applies or a simple solution is offered instead.\n    convergenceCounter--;\n    if (convergenceCounter <= 0) {\n      break;\n    }\n  }\n  // If there are conflicts it might not be possible to find a solution as the items are not allowed to\n  // overlap with the conflicts. In that case the initial state (with the user move applied) is returned.\n  // The user can move the item further to resolve the conflicts which will also unblock the overlaps resolution.\n  // Also, the solution might not be found due to the engine constraints. For example, the convergence number might\n  // be reached before any solution is found or the number of best solutions constraint can filter the only possible\n  // solutions away. In that case the simple solution is returned with all overlapping items pushed to the bottom.\n  if (!bestSolution) {\n    bestSolution = initialState.conflicts ? initialState : resolveOverlapsDown(initialState);\n  }\n  // After each step unless there are conflicts the type=\"FLOAT\" moves are performed on all items\n  // but the user controlled one that can be moved to the top without overlapping with other items.\n  return bestSolution.conflicts ? bestSolution : refloatGrid(bestSolution, userMove);\n}\n// Resolves overlaps the simple way by pushing all overlapping items to the bottom until none is left.\nfunction resolveOverlapsDown(state) {\n  // Move overlapping items to the bottom until resolved. Repeat until no overlaps left.\n  // This solution always converges because there is always free space at the bottom by design.\n  while (state.overlaps.size > 0) {\n    const overlaps = sortGridItems([...state.overlaps].map(([overlapId]) => state.grid.getItem(overlapId)));\n    for (const overlap of overlaps) {\n      let y = overlap.y + 1;\n      while (state.grid.getOverlaps({\n        ...overlap,\n        y\n      }).length > 0) {\n        y++;\n      }\n      makeMove(state, createMove(\"OVERLAP\", overlap, new Position({\n        x: overlap.x,\n        y\n      })));\n    }\n  }\n  return state;\n}\n// Find items that can \"float\" to the top and apply the necessary moves.\nfunction refloatGrid(layoutState, userMove) {\n  const state = new MoveSolutionState(layoutState.grid, layoutState.moves, layoutState.conflicts);\n  function makeRefloat() {\n    let needAnotherRefloat = false;\n    for (const item of state.grid.items) {\n      // The active item is skipped until the operation is committed.\n      if (item.id === (userMove === null || userMove === void 0 ? void 0 : userMove.itemId)) {\n        continue;\n      }\n      let y = item.y - 1;\n      let move = null;\n      while (y >= 0) {\n        const moveAttempt = createMove(\"FLOAT\", item, new Position({\n          x: item.x,\n          y\n        }));\n        if (state.grid.getOverlaps({\n          id: item.id,\n          ...moveAttempt\n        }).length > 0) {\n          break;\n        }\n        y--;\n        move = moveAttempt;\n      }\n      if (move) {\n        makeMove(state, move);\n        needAnotherRefloat = true;\n      }\n    }\n    if (needAnotherRefloat) {\n      makeRefloat();\n    }\n  }\n  makeRefloat();\n  return state;\n}\n// Finds items that cannot be resolved at the current step as of being partially overlapped by the user-move item.\nfunction findConflicts(grid, previousConflicts, userMove) {\n  var _a;\n  // The conflicts are only defined for MOVE command type to make swaps possible.\n  if (userMove.type !== \"MOVE\") {\n    return null;\n  }\n  // Using existing conflict direction if available so that conflicting items would swap consistently.\n  // If only the current direction is considered the multi-item conflicts become difficult to comprehend.\n  const direction = (_a = previousConflicts === null || previousConflicts === void 0 ? void 0 : previousConflicts.direction) !== null && _a !== void 0 ? _a : userMove.direction;\n  // Conflicts are partial overlaps. When the item is overlapped fully (considering the direction) it is\n  // no longer treated as conflict.\n  const overlaps = grid.getOverlaps({\n    ...userMove,\n    id: userMove.itemId\n  });\n  const conflicts = overlaps.filter(overlap => {\n    switch (direction) {\n      case \"left\":\n        return overlap.x < userMove.x;\n      case \"right\":\n        return overlap.x + overlap.width - 1 > userMove.x + userMove.width - 1;\n      case \"up\":\n        return overlap.y < userMove.y;\n      case \"down\":\n        return overlap.y + overlap.height - 1 > userMove.y + userMove.height - 1;\n    }\n  });\n  if (conflicts.length > 0) {\n    return {\n      direction,\n      items: new Set(conflicts.map(item => item.id))\n    };\n  }\n  return null;\n}\n// Applies given move to the solution state by updating the grid, moves, overlaps, and score.\nfunction makeMove(state, nextMove) {\n  updateGridWithMove(state, nextMove);\n  updateOverlaps(state, nextMove);\n  state.moves.push(nextMove);\n  state.score += nextMove.score;\n}\nfunction updateGridWithMove({\n  grid\n}, move) {\n  switch (move.type) {\n    case \"MOVE\":\n    case \"OVERLAP\":\n    case \"FLOAT\":\n      return grid.move(move.itemId, move.x, move.y);\n    case \"INSERT\":\n      return grid.insert({\n        id: move.itemId,\n        ...move\n      });\n    case \"REMOVE\":\n      return grid.remove(move.itemId);\n    case \"RESIZE\":\n      return grid.resize(move.itemId, move.width, move.height);\n  }\n}\nfunction updateOverlaps(state, move) {\n  var _a;\n  // Find and assign items that will overlap with the moved item after the move is performed\n  // unless the overlapping items are considered as conflicts.\n  for (const newOverlap of state.grid.getOverlaps({\n    ...move,\n    id: move.itemId\n  })) {\n    if (!((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(newOverlap.id))) {\n      state.overlaps.set(newOverlap.id, move.itemId);\n    }\n  }\n  // Remove no longer valid overlaps after the move is performed.\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    if (!checkItemsIntersection(state.grid.getItem(overlapId), state.grid.getItem(overlapIssuerId))) {\n      state.overlaps.delete(overlapId);\n    }\n  }\n}","map":{"version":3,"names":["Position","findNextSolutions","MoveSolutionState","checkItemsIntersection","sortGridItems","createMove","MAX_SOLUTION_DEPTH","NUM_BEST_SOLUTIONS","resolveOverlaps","layoutState","userMove","conflicts","findConflicts","grid","initialState","moves","initialSolution","solutionsCache","Map","createCacheKey","state","move","itemId","x","y","score","moveSolutions","bestSolution","convergenceCounter","length","nextSolutions","solutionIndex","Math","min","solutionState","solutionMove","makeMove","overlaps","size","nextSolution","solutionKey","cachedSolution","get","push","set","sort","s1","s2","resolveOverlapsDown","refloatGrid","map","overlapId","getItem","overlap","getOverlaps","makeRefloat","needAnotherRefloat","item","items","id","moveAttempt","previousConflicts","type","direction","_a","filter","width","height","Set","nextMove","updateGridWithMove","updateOverlaps","insert","remove","resize","newOverlap","has","overlapIssuerId","delete"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/layout-engine/engine-step.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Position } from \"../utils/position\";\nimport { findNextSolutions, MoveSolution, MoveSolutionState } from \"./engine-solution\";\nimport { Conflicts, LayoutEngineState } from \"./engine-state\";\nimport { ReadonlyLayoutEngineGrid } from \"./grid\";\nimport { CommittedMove } from \"./interfaces\";\nimport { checkItemsIntersection, sortGridItems } from \"./utils\";\nimport { createMove } from \"./utils\";\n\n// The solutions can't be searched for infinitely in case the algorithm can't converge.\n// The safety counter ensures there is going to be user feedback within reasonable time.\nconst MAX_SOLUTION_DEPTH = 100;\n\n// At any given step only a few best solutions are taken to ensure faster convergence.\n// The larger the number the better chance the most optimal solution is found for the given priorities\n// at a cost of more computations made.\nconst NUM_BEST_SOLUTIONS = 5;\n\n/**\n * The function takes the current layout state (item placements from the previous steps and all moves done so far)\n * and a user command increment that describes an item transition by one cell in some direction.\n * The function finds overlapping elements and resolves all overlaps if possible (always possible when no conflicts).\n * The result in an updated state (new item placements, additional moves, and item conflicts if any).\n */\nexport function resolveOverlaps(layoutState: LayoutEngineState, userMove: CommittedMove): LayoutEngineState {\n  // For better UX the layout engine is optimized for item swaps.\n  // The swapping is only preferred for the user-controlled item and it can only happen when the item overlaps another\n  // item past its midpoint. When the overlap is not enough, the underlying item is considered a conflict and it is not\n  // allowed to move anywhere. The user command cannot be committed at this step.\n  const conflicts = findConflicts(layoutState.grid, layoutState.conflicts, userMove);\n\n  // The user moves are always applied as is. When the user-controlled item overlaps with other items and there is\n  // no conflict, the type=\"OVERLAP\" moves are performed to settle the grid so that no items overlap with one another.\n  // For this type of move multiple solutions are often available. To ensure the best result all solutions are tried\n  // and a score is given to each. The solution with the minimal score wins.\n  // The process stars from the initial state and the user move. The initial score and the user move score are 0.\n  const initialState = new MoveSolutionState(layoutState.grid, layoutState.moves, conflicts);\n  const initialSolution: MoveSolution = [initialState, userMove];\n\n  // All solutions are guaranteed to have unique move sequences but different move sequences can produce the same result.\n  // As it is never expected for one item to be moved over to the same location twice the combination of the item ID,\n  // item position, and solution score can uniquely represent the solution.\n  // For earlier moves taking a solution from the cache can prevent hundreds of subsequent computations.\n  const solutionsCache = new Map<string, MoveSolution>();\n  const createCacheKey = ([state, move]: MoveSolution) =>\n    `${move.itemId} ${move.x}:${move.y}:${state.score + move.score}`;\n\n  let moveSolutions: MoveSolution[] = [initialSolution];\n  let bestSolution: null | MoveSolutionState = null;\n  let convergenceCounter = MAX_SOLUTION_DEPTH;\n\n  // The resolution process continues until there is at least one reasonable solution left.\n  // The repetitive, dead-end, and expensive (compared to the best so far) solutions are excluded\n  // so that eventually no more variants to try remain.\n  // The convergence safety counter ensures the logical errors to not cause an infinite loop.\n  while (moveSolutions.length > 0) {\n    let nextSolutions: MoveSolution[] = [];\n\n    for (let solutionIndex = 0; solutionIndex < Math.min(NUM_BEST_SOLUTIONS, moveSolutions.length); solutionIndex++) {\n      const [solutionState, solutionMove] = moveSolutions[solutionIndex];\n\n      // Discard the solution before performing the move if its next score is already above the best score found so far.\n      if (bestSolution && solutionState.score + solutionMove.score >= bestSolution.score) {\n        continue;\n      }\n\n      // Perform the move by mutating the solution's state: grid, moves, score, etc.\n      makeMove(solutionState, solutionMove);\n\n      // If no overlaps are left the solution is considered valid and the best so far.\n      // The next solutions having the same or higher score will be discarded.\n      if (solutionState.overlaps.size === 0) {\n        bestSolution = solutionState;\n      }\n      // Otherwise, the next set of solutions will be considered. There can be up to four solutions per overlap\n      // (by the number of possible directions to move).\n      else {\n        for (const nextSolution of findNextSolutions(solutionState)) {\n          const solutionKey = createCacheKey(nextSolution);\n          const cachedSolution = solutionsCache.get(solutionKey);\n          if (!cachedSolution) {\n            nextSolutions.push(nextSolution);\n            solutionsCache.set(solutionKey, nextSolution);\n          }\n        }\n      }\n    }\n\n    // The solutions are ordered by the total score so that the best (so far) solutions are considered first.\n    moveSolutions = nextSolutions.sort((s1, s2) => s1[0].score + s1[1].score - (s2[0].score + s2[1].score));\n    nextSolutions = [];\n\n    // Reaching the convergence counter might indicate an issue with the algorithm as ideally it should converge faster.\n    // However, that does not necessarily mean the logical problem and no exception should be thrown.\n    // Instead, the current best solution if available applies or a simple solution is offered instead.\n    convergenceCounter--;\n    if (convergenceCounter <= 0) {\n      break;\n    }\n  }\n\n  // If there are conflicts it might not be possible to find a solution as the items are not allowed to\n  // overlap with the conflicts. In that case the initial state (with the user move applied) is returned.\n  // The user can move the item further to resolve the conflicts which will also unblock the overlaps resolution.\n  // Also, the solution might not be found due to the engine constraints. For example, the convergence number might\n  // be reached before any solution is found or the number of best solutions constraint can filter the only possible\n  // solutions away. In that case the simple solution is returned with all overlapping items pushed to the bottom.\n  if (!bestSolution) {\n    bestSolution = initialState.conflicts ? initialState : resolveOverlapsDown(initialState);\n  }\n\n  // After each step unless there are conflicts the type=\"FLOAT\" moves are performed on all items\n  // but the user controlled one that can be moved to the top without overlapping with other items.\n  return bestSolution.conflicts ? bestSolution : refloatGrid(bestSolution, userMove);\n}\n\n// Resolves overlaps the simple way by pushing all overlapping items to the bottom until none is left.\nfunction resolveOverlapsDown(state: MoveSolutionState): MoveSolutionState {\n  // Move overlapping items to the bottom until resolved. Repeat until no overlaps left.\n  // This solution always converges because there is always free space at the bottom by design.\n  while (state.overlaps.size > 0) {\n    const overlaps = sortGridItems([...state.overlaps].map(([overlapId]) => state.grid.getItem(overlapId)));\n    for (const overlap of overlaps) {\n      let y = overlap.y + 1;\n      while (state.grid.getOverlaps({ ...overlap, y }).length > 0) {\n        y++;\n      }\n      makeMove(state, createMove(\"OVERLAP\", overlap, new Position({ x: overlap.x, y })));\n    }\n  }\n  return state;\n}\n\n// Find items that can \"float\" to the top and apply the necessary moves.\nfunction refloatGrid(layoutState: LayoutEngineState, userMove?: CommittedMove): LayoutEngineState {\n  const state = new MoveSolutionState(layoutState.grid, layoutState.moves, layoutState.conflicts);\n\n  function makeRefloat() {\n    let needAnotherRefloat = false;\n\n    for (const item of state.grid.items) {\n      // The active item is skipped until the operation is committed.\n      if (item.id === userMove?.itemId) {\n        continue;\n      }\n\n      let y = item.y - 1;\n      let move: null | CommittedMove = null;\n      while (y >= 0) {\n        const moveAttempt = createMove(\"FLOAT\", item, new Position({ x: item.x, y }));\n        if (state.grid.getOverlaps({ id: item.id, ...moveAttempt }).length > 0) {\n          break;\n        }\n        y--;\n        move = moveAttempt;\n      }\n      if (move) {\n        makeMove(state, move);\n        needAnotherRefloat = true;\n      }\n    }\n\n    if (needAnotherRefloat) {\n      makeRefloat();\n    }\n  }\n\n  makeRefloat();\n\n  return state;\n}\n\n// Finds items that cannot be resolved at the current step as of being partially overlapped by the user-move item.\nfunction findConflicts(\n  grid: ReadonlyLayoutEngineGrid,\n  previousConflicts: null | Conflicts,\n  userMove: CommittedMove,\n): null | Conflicts {\n  // The conflicts are only defined for MOVE command type to make swaps possible.\n  if (userMove.type !== \"MOVE\") {\n    return null;\n  }\n  // Using existing conflict direction if available so that conflicting items would swap consistently.\n  // If only the current direction is considered the multi-item conflicts become difficult to comprehend.\n  const direction = previousConflicts?.direction ?? userMove.direction;\n  // Conflicts are partial overlaps. When the item is overlapped fully (considering the direction) it is\n  // no longer treated as conflict.\n  const overlaps = grid.getOverlaps({ ...userMove, id: userMove.itemId });\n  const conflicts = overlaps.filter((overlap) => {\n    switch (direction) {\n      case \"left\":\n        return overlap.x < userMove.x;\n      case \"right\":\n        return overlap.x + overlap.width - 1 > userMove.x + userMove.width - 1;\n      case \"up\":\n        return overlap.y < userMove.y;\n      case \"down\":\n        return overlap.y + overlap.height - 1 > userMove.y + userMove.height - 1;\n    }\n  });\n  if (conflicts.length > 0) {\n    return { direction, items: new Set(conflicts.map((item) => item.id)) };\n  }\n  return null;\n}\n\n// Applies given move to the solution state by updating the grid, moves, overlaps, and score.\nfunction makeMove(state: MoveSolutionState, nextMove: CommittedMove): void {\n  updateGridWithMove(state, nextMove);\n  updateOverlaps(state, nextMove);\n  state.moves.push(nextMove);\n  state.score += nextMove.score;\n}\n\nfunction updateGridWithMove({ grid }: MoveSolutionState, move: CommittedMove): void {\n  switch (move.type) {\n    case \"MOVE\":\n    case \"OVERLAP\":\n    case \"FLOAT\":\n      return grid.move(move.itemId, move.x, move.y);\n    case \"INSERT\":\n      return grid.insert({ id: move.itemId, ...move });\n    case \"REMOVE\":\n      return grid.remove(move.itemId);\n    case \"RESIZE\":\n      return grid.resize(move.itemId, move.width, move.height);\n  }\n}\n\nfunction updateOverlaps(state: MoveSolutionState, move: CommittedMove) {\n  // Find and assign items that will overlap with the moved item after the move is performed\n  // unless the overlapping items are considered as conflicts.\n  for (const newOverlap of state.grid.getOverlaps({ ...move, id: move.itemId })) {\n    if (!state.conflicts?.items.has(newOverlap.id)) {\n      state.overlaps.set(newOverlap.id, move.itemId);\n    }\n  }\n  // Remove no longer valid overlaps after the move is performed.\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    if (!checkItemsIntersection(state.grid.getItem(overlapId), state.grid.getItem(overlapIssuerId))) {\n      state.overlaps.delete(overlapId);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}