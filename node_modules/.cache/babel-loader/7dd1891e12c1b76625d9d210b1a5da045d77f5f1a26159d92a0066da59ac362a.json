{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function isInside(rect, bounds) {\n  return rect.top >= bounds.top && rect.left >= bounds.left && rect.right <= bounds.right && rect.bottom <= bounds.bottom;\n}\nexport function isIntersecting(rect1, rect2) {\n  return getIntersectionArea(rect1, rect2) > 0;\n}\nexport function getIntersectionArea(rect1, rect2) {\n  let horizontalIntersectionLength = 0;\n  if (rect2.left <= rect1.left && rect1.left <= rect2.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect1.left;\n  } else if (rect2.left <= rect1.right && rect1.right <= rect2.right) {\n    horizontalIntersectionLength = rect1.right - Math.max(rect1.left, rect2.left);\n  } else if (rect1.left <= rect2.left && rect2.left <= rect1.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect2.left;\n  } else if (rect1.left <= rect2.right && rect2.right <= rect1.right) {\n    horizontalIntersectionLength = rect2.right - Math.max(rect1.left, rect2.left);\n  }\n  let verticalIntersectionLength = 0;\n  if (rect2.top <= rect1.top && rect1.top <= rect2.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect1.top;\n  } else if (rect2.top <= rect1.bottom && rect1.bottom <= rect2.bottom) {\n    verticalIntersectionLength = rect1.bottom - Math.max(rect1.top, rect2.top);\n  } else if (rect1.top <= rect2.top && rect2.top <= rect1.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect2.top;\n  } else if (rect1.top <= rect2.bottom && rect2.bottom <= rect1.bottom) {\n    verticalIntersectionLength = rect2.bottom - Math.max(rect1.top, rect2.top);\n  }\n  return horizontalIntersectionLength * verticalIntersectionLength;\n}\nexport function getGridPlacement(target, grid) {\n  function getMinDistance(min, current, collision) {\n    const minDistance = Math.abs(min - collision);\n    const currentDistance = Math.abs(current - collision);\n    return currentDistance < minDistance ? current : min;\n  }\n  let placement = {\n    top: Number.POSITIVE_INFINITY,\n    left: Number.POSITIVE_INFINITY,\n    right: Number.POSITIVE_INFINITY,\n    bottom: Number.POSITIVE_INFINITY\n  };\n  for (const rect of grid) {\n    if (isIntersecting(rect, target)) {\n      placement = {\n        top: getMinDistance(placement.top, rect.top, target.top),\n        left: getMinDistance(placement.left, rect.left, target.left),\n        right: getMinDistance(placement.right, rect.right, target.right),\n        bottom: getMinDistance(placement.bottom, rect.bottom, target.bottom)\n      };\n    }\n  }\n  return placement;\n}\nexport function getClosestNeighbor({\n  target,\n  sources,\n  direction,\n  isRtl\n}) {\n  const getFirst = rects => {\n    var _a;\n    return (_a = rects[0]) !== null && _a !== void 0 ? _a : null;\n  };\n  const verticalDiff = (r1, r2) => Math.abs(r1.top - target.top) - Math.abs(r2.top - target.top);\n  const horizontalDiff = (r1, r2) => Math.abs(r1.left - target.left) - Math.abs(r2.left - target.left);\n  if (isRtl && direction === \"left\") {\n    direction = \"right\";\n  } else if (isRtl && direction === \"right\") {\n    direction = \"left\";\n  }\n  switch (direction) {\n    case \"left\":\n      return getFirst(sources.filter(rect => rect.right <= target.left).sort((r1, r2) => r2.left - r1.left || verticalDiff(r1, r2)));\n    case \"right\":\n      return getFirst(sources.filter(rect => rect.left >= target.right).sort((r1, r2) => r1.left - r2.left || verticalDiff(r1, r2)));\n    case \"up\":\n      return getFirst(sources.filter(rect => rect.bottom <= target.top).sort((r1, r2) => r2.top - r1.top || horizontalDiff(r1, r2)));\n    case \"down\":\n      return getFirst(sources.filter(rect => rect.top >= target.bottom).sort((r1, r2) => r1.top - r2.top || horizontalDiff(r1, r2)));\n  }\n}","map":{"version":3,"names":["isInside","rect","bounds","top","left","right","bottom","isIntersecting","rect1","rect2","getIntersectionArea","horizontalIntersectionLength","Math","min","max","verticalIntersectionLength","getGridPlacement","target","grid","getMinDistance","current","collision","minDistance","abs","currentDistance","placement","Number","POSITIVE_INFINITY","getClosestNeighbor","sources","direction","isRtl","getFirst","rects","_a","verticalDiff","r1","r2","horizontalDiff","filter","sort"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/utils/rects.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Direction, Rect } from \"../interfaces\";\n\nexport function isInside(rect: Rect, bounds: Rect) {\n  return (\n    rect.top >= bounds.top && rect.left >= bounds.left && rect.right <= bounds.right && rect.bottom <= bounds.bottom\n  );\n}\n\nexport function isIntersecting(rect1: Rect, rect2: Rect) {\n  return getIntersectionArea(rect1, rect2) > 0;\n}\n\nexport function getIntersectionArea(rect1: Rect, rect2: Rect) {\n  let horizontalIntersectionLength = 0;\n  if (rect2.left <= rect1.left && rect1.left <= rect2.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect1.left;\n  } else if (rect2.left <= rect1.right && rect1.right <= rect2.right) {\n    horizontalIntersectionLength = rect1.right - Math.max(rect1.left, rect2.left);\n  } else if (rect1.left <= rect2.left && rect2.left <= rect1.right) {\n    horizontalIntersectionLength = Math.min(rect1.right, rect2.right) - rect2.left;\n  } else if (rect1.left <= rect2.right && rect2.right <= rect1.right) {\n    horizontalIntersectionLength = rect2.right - Math.max(rect1.left, rect2.left);\n  }\n\n  let verticalIntersectionLength = 0;\n  if (rect2.top <= rect1.top && rect1.top <= rect2.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect1.top;\n  } else if (rect2.top <= rect1.bottom && rect1.bottom <= rect2.bottom) {\n    verticalIntersectionLength = rect1.bottom - Math.max(rect1.top, rect2.top);\n  } else if (rect1.top <= rect2.top && rect2.top <= rect1.bottom) {\n    verticalIntersectionLength = Math.min(rect1.bottom, rect2.bottom) - rect2.top;\n  } else if (rect1.top <= rect2.bottom && rect2.bottom <= rect1.bottom) {\n    verticalIntersectionLength = rect2.bottom - Math.max(rect1.top, rect2.top);\n  }\n\n  return horizontalIntersectionLength * verticalIntersectionLength;\n}\n\nexport function getGridPlacement(target: Rect, grid: readonly Rect[]): Rect {\n  function getMinDistance(min: number, current: number, collision: number) {\n    const minDistance = Math.abs(min - collision);\n    const currentDistance = Math.abs(current - collision);\n    return currentDistance < minDistance ? current : min;\n  }\n\n  let placement = {\n    top: Number.POSITIVE_INFINITY,\n    left: Number.POSITIVE_INFINITY,\n    right: Number.POSITIVE_INFINITY,\n    bottom: Number.POSITIVE_INFINITY,\n  };\n\n  for (const rect of grid) {\n    if (isIntersecting(rect, target)) {\n      placement = {\n        top: getMinDistance(placement.top, rect.top, target.top),\n        left: getMinDistance(placement.left, rect.left, target.left),\n        right: getMinDistance(placement.right, rect.right, target.right),\n        bottom: getMinDistance(placement.bottom, rect.bottom, target.bottom),\n      };\n    }\n  }\n\n  return placement;\n}\n\nexport function getClosestNeighbor({\n  target,\n  sources,\n  direction,\n  isRtl,\n}: {\n  target: Rect;\n  sources: readonly Rect[];\n  direction: Direction;\n  isRtl: boolean;\n}): null | Rect {\n  const getFirst = (rects: Rect[]) => rects[0] ?? null;\n  const verticalDiff = (r1: Rect, r2: Rect) => Math.abs(r1.top - target.top) - Math.abs(r2.top - target.top);\n  const horizontalDiff = (r1: Rect, r2: Rect) => Math.abs(r1.left - target.left) - Math.abs(r2.left - target.left);\n\n  if (isRtl && direction === \"left\") {\n    direction = \"right\";\n  } else if (isRtl && direction === \"right\") {\n    direction = \"left\";\n  }\n\n  switch (direction) {\n    case \"left\":\n      return getFirst(\n        sources.filter((rect) => rect.right <= target.left).sort((r1, r2) => r2.left - r1.left || verticalDiff(r1, r2)),\n      );\n    case \"right\":\n      return getFirst(\n        sources.filter((rect) => rect.left >= target.right).sort((r1, r2) => r1.left - r2.left || verticalDiff(r1, r2)),\n      );\n    case \"up\":\n      return getFirst(\n        sources.filter((rect) => rect.bottom <= target.top).sort((r1, r2) => r2.top - r1.top || horizontalDiff(r1, r2)),\n      );\n    case \"down\":\n      return getFirst(\n        sources.filter((rect) => rect.top >= target.bottom).sort((r1, r2) => r1.top - r2.top || horizontalDiff(r1, r2)),\n      );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}