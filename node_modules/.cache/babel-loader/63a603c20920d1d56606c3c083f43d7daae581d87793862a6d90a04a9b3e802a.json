{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nexport function useNavigation({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n  highlightX,\n  verticalMarkerX,\n  isRtl,\n  horizontalBars\n}) {\n  const [targetX, setTargetX] = useState(null);\n  const [xIndex, setXIndex] = useState(0);\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(({\n    series\n  }) => series.type === 'bar'), [visibleSeries]);\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const {\n    navigableSeries\n  } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n  const onLineFocus = () => {\n    var _a;\n    if (verticalMarkerX === null) {\n      const index = !isRtl ? 0 : allUniqueX.length - 1;\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(index);\n      } else {\n        moveBetweenSeries(0, (_a = allUniqueX[index].datum) === null || _a === void 0 ? void 0 : _a.x);\n      }\n    }\n  };\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({\n          scaledX: point.x,\n          datum: point.datum\n        });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n  const moveBetweenSeries = useCallback((direction, startFrom) => {\n    var _a, _b, _c, _d, _e;\n    if (isGroupNavigation) {\n      return;\n    }\n    const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    const MAX_SERIES_INDEX = navigableSeries.length - 1;\n    // Find the index of the currently highlighted series (if any)\n    let previousSeriesIndex = -1;\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    }\n    // Move forwards or backwards to the new series\n    // If index === -1, show all data points from all series at the given X instead of one single series\n    const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n    let nextSeriesIndex = 0;\n    if (previousSeriesIndex !== null) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = firstPossibleIndex;\n      } else if (nextSeriesIndex < firstPossibleIndex) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n    if (nextSeriesIndex === -1) {\n      highlightSeries(null);\n      highlightPoint(null);\n      return;\n    }\n    const nextSeries = navigableSeries[nextSeriesIndex];\n    const nextInternalSeries = series.filter(({\n      series\n    }) => series === nextSeries)[0];\n    const actualTargetX = (_a = targetX !== null && targetX !== void 0 ? targetX : startFrom) !== null && _a !== void 0 ? _a : null;\n    // 2. Find point in the next series\n    let targetXPoint = ((_b = xScale.d3Scale(actualTargetX)) !== null && _b !== void 0 ? _b : NaN) + xOffset;\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n    if (nextSeries.type === 'line') {\n      const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n      const closestNextSeriesPoint = nextScaledSeries.reduce((prev, curr) => Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightPoint(Object.assign(Object.assign({}, closestNextSeriesPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (isYThreshold(nextSeries)) {\n      const scaledTargetIndex = scaledSeries.map(it => {\n        var _a;\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(actualTargetX);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_c = yScale.d3Scale(nextSeries.y)) !== null && _c !== void 0 ? _c : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_d = scaledSeries[scaledTargetIndex]) === null || _d === void 0 ? void 0 : _d.datum\n      });\n    } else if (isXThreshold(nextSeries)) {\n      highlightPoint({\n        x: (_e = xScale.d3Scale(nextSeries.x)) !== null && _e !== void 0 ? _e : NaN,\n        y: yScale.d3Scale.range()[0],\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: {\n          x: nextSeries.x,\n          y: NaN\n        }\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, containsMultipleSeries, highlightSeries, highlightPoint, series, targetX, scaledSeries, yScale]);\n  const moveWithinSeries = useCallback(direction => {\n    var _a;\n    const series = highlightedSeries || visibleSeries[0].series;\n    if (series.type === 'line' || isYThreshold(series)) {\n      const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n      const previousPoint = highlightedPoint || targetScaledSeries[0];\n      const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n      const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n      const nextPoint = targetScaledSeries[nextPointIndex];\n      setTargetX(((_a = nextPoint.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      setXIndex(nextPointIndex);\n      highlightPoint(nextPoint);\n    } else if (series.type === 'bar') {\n      const xDomain = xScale.domain;\n      const MAX_GROUP_INDEX = xDomain.length - 1;\n      let nextGroupIndex = 0;\n      if (highlightedGroupIndex !== null) {\n        if (isRtl && !horizontalBars) {\n          direction = -direction;\n        }\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n      const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, scaledSeries, highlightedPoint, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup, isRtl, horizontalBars]);\n  const moveToLineGroupIndex = useCallback(index => {\n    var _a, _b, _c, _d;\n    const point = allUniqueX[index];\n    setXIndex(index);\n    setTargetX(((_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n    highlightX({\n      scaledX: (_b = point === null || point === void 0 ? void 0 : point.scaledX) !== null && _b !== void 0 ? _b : null,\n      label: (_d = (_c = point.datum) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : null\n    });\n  }, [allUniqueX, highlightX]);\n  const moveWithinXAxis = useCallback(direction => {\n    if (highlightedSeries || isGroupNavigation) {\n      moveWithinSeries(direction);\n    } else {\n      const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n      moveToLineGroupIndex(nextPointGroupIndex);\n    }\n  }, [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]);\n  const onKeyDown = useCallback(event => {\n    const keyCode = event.keyCode;\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n    event.preventDefault();\n    if (isHandlersDisabled) {\n      return;\n    }\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]);\n  return {\n    isGroupNavigation,\n    onFocus,\n    onKeyDown,\n    xIndex\n  };\n}","map":{"version":3,"names":["useCallback","useMemo","useState","KeyCode","circleIndex","findNavigableSeries","isXThreshold","isYThreshold","nextValidDomainIndex","useNavigation","series","visibleSeries","scaledSeries","barGroups","xScale","yScale","highlightedPoint","highlightedGroupIndex","highlightedSeries","isHandlersDisabled","pinPopover","highlightSeries","highlightGroup","highlightPoint","highlightX","verticalMarkerX","isRtl","horizontalBars","targetX","setTargetX","xIndex","setXIndex","isGroupNavigation","some","type","navigableSeries","containsMultipleSeries","length","onBarGroupFocus","groupIndex","domain","onLineFocus","index","allUniqueX","moveToLineGroupIndex","moveBetweenSeries","_a","datum","x","onFocus","result","i","point","undefined","scaledX","push","direction","startFrom","xOffset","isCategorical","Math","max","d3Scale","bandwidth","MAX_SERIES_INDEX","previousSeriesIndex","indexOf","firstPossibleIndex","nextSeriesIndex","nextSeries","nextInternalSeries","filter","actualTargetX","targetXPoint","_b","NaN","isFinite","nextScaledSeries","it","closestNextSeriesPoint","reduce","prev","curr","abs","Infinity","y","Object","assign","color","scaledTargetIndex","map","_c","_d","_e","range","moveWithinSeries","targetScaledSeries","previousPoint","indexOfPreviousPoint","nextPointIndex","nextPoint","xDomain","MAX_GROUP_INDEX","nextGroupIndex","nextDomainIndex","label","moveWithinXAxis","nextPointGroupIndex","onKeyDown","event","keyCode","up","right","down","left","space","enter","preventDefault"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/hooks/use-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useState } from 'react';\n\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps, VerticalMarkerX } from '../interfaces';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n  clearHighlightedSeries(): void;\n  verticalMarkerX: VerticalMarkerX<T> | null;\n\n  isRtl?: boolean;\n  horizontalBars: boolean;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n  highlightX,\n  verticalMarkerX,\n  isRtl,\n  horizontalBars,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n  const [xIndex, setXIndex] = useState(0);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(({ series }) => series.type === 'bar'), [visibleSeries]);\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineFocus = () => {\n    if (verticalMarkerX === null) {\n      const index = !isRtl ? 0 : allUniqueX.length - 1;\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(index);\n      } else {\n        moveBetweenSeries(0, allUniqueX[index].datum?.x);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({ scaledX: point.x, datum: point.datum });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n\n  const moveBetweenSeries = useCallback(\n    (direction: number, startFrom?: T) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      // If index === -1, show all data points from all series at the given X instead of one single series\n      const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== null) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = firstPossibleIndex;\n        } else if (nextSeriesIndex < firstPossibleIndex) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n      if (nextSeriesIndex === -1) {\n        highlightSeries(null);\n        highlightPoint(null);\n        return;\n      }\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      const actualTargetX = targetX ?? startFrom ?? null;\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(actualTargetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(actualTargetX);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      containsMultipleSeries,\n      highlightSeries,\n      highlightPoint,\n      series,\n      targetX,\n      scaledSeries,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const previousPoint = highlightedPoint || targetScaledSeries[0];\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        setXIndex(nextPointIndex);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          if (isRtl && !horizontalBars) {\n            direction = -direction;\n          }\n\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      scaledSeries,\n      highlightedPoint,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n      isRtl,\n      horizontalBars,\n    ]\n  );\n\n  const moveToLineGroupIndex = useCallback(\n    (index: number) => {\n      const point = allUniqueX[index];\n      setXIndex(index);\n      setTargetX(point.datum?.x || null);\n      highlightX({ scaledX: point?.scaledX ?? null, label: point.datum?.x ?? null });\n    },\n    [allUniqueX, highlightX]\n  );\n\n  const moveWithinXAxis = useCallback(\n    (direction: number) => {\n      if (highlightedSeries || isGroupNavigation) {\n        moveWithinSeries(direction);\n      } else {\n        const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n        moveToLineGroupIndex(nextPointGroupIndex);\n      }\n    },\n    [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown, xIndex };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}