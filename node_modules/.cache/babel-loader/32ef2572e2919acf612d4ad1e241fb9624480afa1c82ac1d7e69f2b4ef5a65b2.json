{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nexport function sortGridItems(items) {\n  return items.sort((a, b) => b.y - a.y === 0 ? b.x - a.x : b.y - a.y);\n}\nexport function normalizeMovePath(origin, path) {\n  path = normalizePathOrigin(origin, path);\n  // Store last visited indexes per position.\n  const positionToLastIndex = new Map();\n  for (let index = 0; index < path.length; index++) {\n    positionToLastIndex.set(`${path[index].x}:${path[index].y}`, index);\n  }\n  // Compose path from last visited indices only.\n  const normalizedPath = [];\n  let index = 0;\n  while (index < path.length) {\n    const lastVisitedIndex = positionToLastIndex.get(`${path[index].x}:${path[index].y}`);\n    normalizedPath.push(path[lastVisitedIndex]);\n    index = lastVisitedIndex + 1;\n  }\n  return normalizePathSteps(origin, normalizedPath);\n}\nexport function normalizeResizePath(origin, path) {\n  path = normalizePathOrigin(origin, path);\n  if (path.length === 0) {\n    return [];\n  }\n  const normalizedPath = [path[path.length - 1]];\n  for (let stepIndex = path.length - 2; stepIndex >= 0; stepIndex--) {\n    const prev = normalizedPath[normalizedPath.length - 1];\n    const current = path[stepIndex];\n    if (current.x < prev.x || current.y < prev.y) {\n      normalizedPath.push(current);\n    }\n  }\n  normalizedPath.reverse();\n  return normalizePathSteps(origin, normalizedPath);\n}\nexport function createMove(type, item, next, score = 0) {\n  const distanceX = type === \"RESIZE\" ? next.x - item.width : next.x - item.x;\n  const distanceY = type === \"RESIZE\" ? next.y - item.height : next.y - item.y;\n  return {\n    type,\n    itemId: item.id,\n    x: type !== \"RESIZE\" ? next.x : item.x,\n    y: type !== \"RESIZE\" ? next.y : item.y,\n    width: type === \"RESIZE\" ? next.x : item.width,\n    height: type === \"RESIZE\" ? next.y : item.height,\n    direction: distanceX > 0 ? \"right\" : distanceX < 0 ? \"left\" : distanceY < 0 ? \"up\" : \"down\",\n    distanceX,\n    distanceY,\n    score\n  };\n}\nexport function getMoveOriginalRect(move) {\n  return {\n    left: move.x - move.distanceX,\n    right: move.x - move.distanceX + move.width - 1,\n    top: move.y - move.distanceY,\n    bottom: move.y - move.distanceY + move.height - 1\n  };\n}\nexport function getMoveRect(move) {\n  return {\n    left: move.x,\n    right: move.x + move.width - 1,\n    top: move.y,\n    bottom: move.y + move.height - 1\n  };\n}\nexport function checkItemsIntersection(i1, i2) {\n  if (i1.id === i2.id) {\n    return false;\n  }\n  return i1.x <= i2.x + i2.width - 1 && i2.x <= i1.x + i1.width - 1 && i1.y <= i2.y + i2.height - 1 && i2.y <= i1.y + i1.height - 1;\n}\nexport function checkOppositeDirections(d1, d2) {\n  return d1 === \"down\" && d2 === \"up\" || d1 === \"up\" && d2 === \"down\" || d1 === \"left\" && d2 === \"right\" || d1 === \"right\" && d2 === \"left\";\n}\n// Removes path prefixes that return to the original location.\nfunction normalizePathOrigin(origin, path) {\n  let lastOriginIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    if (path[i].x === origin.x && path[i].y === origin.y) {\n      lastOriginIndex = i;\n    }\n  }\n  return path.slice(lastOriginIndex + 1);\n}\n// Ensures path only includes single-length steps.\nfunction normalizePathSteps(origin, path) {\n  const normalizedPath = [];\n  let prevX = origin.x;\n  let prevY = origin.y;\n  for (const step of path) {\n    const vx = Math.sign(step.x - prevX);\n    const vy = Math.sign(step.y - prevY);\n    for (let x = prevX, y = prevY; x !== step.x || y !== step.y;) {\n      if (x !== step.x) {\n        x += vx;\n      } else {\n        y += vy;\n      }\n      normalizedPath.push(new Position({\n        x,\n        y\n      }));\n    }\n    prevX = step.x;\n    prevY = step.y;\n  }\n  return normalizedPath;\n}","map":{"version":3,"names":["Position","sortGridItems","items","sort","a","b","y","x","normalizeMovePath","origin","path","normalizePathOrigin","positionToLastIndex","Map","index","length","set","normalizedPath","lastVisitedIndex","get","push","normalizePathSteps","normalizeResizePath","stepIndex","prev","current","reverse","createMove","type","item","next","score","distanceX","width","distanceY","height","itemId","id","direction","getMoveOriginalRect","move","left","right","top","bottom","getMoveRect","checkItemsIntersection","i1","i2","checkOppositeDirections","d1","d2","lastOriginIndex","i","slice","prevX","prevY","step","vx","Math","sign","vy"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/layout-engine/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Direction, GridLayoutItem } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { CommittedMove } from \"./interfaces\";\n\nexport interface Rect {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n}\n\nexport function sortGridItems(items: GridLayoutItem[]): readonly GridLayoutItem[] {\n  return items.sort((a, b) => (b.y - a.y === 0 ? b.x - a.x : b.y - a.y));\n}\n\nexport function normalizeMovePath(origin: Position, path: readonly Position[]): readonly Position[] {\n  path = normalizePathOrigin(origin, path);\n\n  // Store last visited indexes per position.\n  const positionToLastIndex = new Map<string, number>();\n  for (let index = 0; index < path.length; index++) {\n    positionToLastIndex.set(`${path[index].x}:${path[index].y}`, index);\n  }\n\n  // Compose path from last visited indices only.\n  const normalizedPath: Position[] = [];\n  let index = 0;\n  while (index < path.length) {\n    const lastVisitedIndex = positionToLastIndex.get(`${path[index].x}:${path[index].y}`)!;\n    normalizedPath.push(path[lastVisitedIndex]);\n    index = lastVisitedIndex + 1;\n  }\n\n  return normalizePathSteps(origin, normalizedPath);\n}\n\nexport function normalizeResizePath(origin: Position, path: readonly Position[]): readonly Position[] {\n  path = normalizePathOrigin(origin, path);\n\n  if (path.length === 0) {\n    return [];\n  }\n\n  const normalizedPath: Position[] = [path[path.length - 1]];\n  for (let stepIndex = path.length - 2; stepIndex >= 0; stepIndex--) {\n    const prev = normalizedPath[normalizedPath.length - 1];\n    const current = path[stepIndex];\n    if (current.x < prev.x || current.y < prev.y) {\n      normalizedPath.push(current);\n    }\n  }\n  normalizedPath.reverse();\n\n  return normalizePathSteps(origin, normalizedPath);\n}\n\nexport function createMove(\n  type: CommittedMove[\"type\"],\n  item: GridLayoutItem,\n  next: Position,\n  score = 0,\n): CommittedMove {\n  const distanceX = type === \"RESIZE\" ? next.x - item.width : next.x - item.x;\n  const distanceY = type === \"RESIZE\" ? next.y - item.height : next.y - item.y;\n  return {\n    type,\n    itemId: item.id,\n    x: type !== \"RESIZE\" ? next.x : item.x,\n    y: type !== \"RESIZE\" ? next.y : item.y,\n    width: type === \"RESIZE\" ? next.x : item.width,\n    height: type === \"RESIZE\" ? next.y : item.height,\n    direction: distanceX > 0 ? \"right\" : distanceX < 0 ? \"left\" : distanceY < 0 ? \"up\" : \"down\",\n    distanceX,\n    distanceY,\n    score,\n  };\n}\n\nexport function getMoveOriginalRect(move: CommittedMove): Rect {\n  return {\n    left: move.x - move.distanceX,\n    right: move.x - move.distanceX + move.width - 1,\n    top: move.y - move.distanceY,\n    bottom: move.y - move.distanceY + move.height - 1,\n  };\n}\n\nexport function getMoveRect(move: CommittedMove): Rect {\n  return {\n    left: move.x,\n    right: move.x + move.width - 1,\n    top: move.y,\n    bottom: move.y + move.height - 1,\n  };\n}\n\nexport function checkItemsIntersection(i1: GridLayoutItem, i2: GridLayoutItem): boolean {\n  if (i1.id === i2.id) {\n    return false;\n  }\n  return (\n    i1.x <= i2.x + i2.width - 1 &&\n    i2.x <= i1.x + i1.width - 1 &&\n    i1.y <= i2.y + i2.height - 1 &&\n    i2.y <= i1.y + i1.height - 1\n  );\n}\n\nexport function checkOppositeDirections(d1: Direction, d2: Direction): boolean {\n  return (\n    (d1 === \"down\" && d2 === \"up\") ||\n    (d1 === \"up\" && d2 === \"down\") ||\n    (d1 === \"left\" && d2 === \"right\") ||\n    (d1 === \"right\" && d2 === \"left\")\n  );\n}\n\n// Removes path prefixes that return to the original location.\nfunction normalizePathOrigin(origin: Position, path: readonly Position[]): readonly Position[] {\n  let lastOriginIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    if (path[i].x === origin.x && path[i].y === origin.y) {\n      lastOriginIndex = i;\n    }\n  }\n  return path.slice(lastOriginIndex + 1);\n}\n\n// Ensures path only includes single-length steps.\nfunction normalizePathSteps(origin: Position, path: readonly Position[]): readonly Position[] {\n  const normalizedPath: Position[] = [];\n\n  let prevX = origin.x;\n  let prevY = origin.y;\n\n  for (const step of path) {\n    const vx = Math.sign(step.x - prevX);\n    const vy = Math.sign(step.y - prevY);\n\n    for (let x = prevX, y = prevY; x !== step.x || y !== step.y; ) {\n      if (x !== step.x) {\n        x += vx;\n      } else {\n        y += vy;\n      }\n      normalizedPath.push(new Position({ x, y }));\n    }\n\n    prevX = step.x;\n    prevY = step.y;\n  }\n\n  return normalizedPath;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}