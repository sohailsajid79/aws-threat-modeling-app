{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useReducer } from \"react\";\nimport { getLogicalBoundingClientRect } from \"@cloudscape-design/component-toolkit/internal\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\nexport function useTransition({\n  isRtl\n}) {\n  return useReducer(createTransitionReducer({\n    isRtl\n  }), {\n    transition: null,\n    removeTransition: null,\n    announcement: null\n  });\n}\nexport function selectTransitionRows(state) {\n  return state.transition ? getLayoutRows(state.transition) : 0;\n}\nfunction createTransitionReducer({\n  isRtl\n}) {\n  return function transitionReducer(state, action) {\n    switch (action.type) {\n      case \"init\":\n        return initTransition(action);\n      case \"init-remove\":\n        return initRemoveTransition(action);\n      case \"submit\":\n        return submitTransition(state);\n      case \"discard\":\n        return discardTransition(state);\n      case \"update-with-pointer\":\n        return updateTransitionWithPointerEvent(state, action);\n      case \"update-with-keyboard\":\n        return updateTransitionWithKeyboardEvent(state, action, {\n          isRtl\n        });\n      case \"acquire-item\":\n        return acquireTransitionItem(state, action);\n    }\n  };\n}\nfunction initTransition({\n  operation,\n  interactionType,\n  itemsLayout,\n  draggableItem,\n  draggableRect,\n  collisionIds\n}) {\n  const transition = {\n    operation,\n    interactionType,\n    itemsLayout,\n    layoutEngine: new LayoutEngine(itemsLayout),\n    insertionDirection: null,\n    draggableItem,\n    draggableRect,\n    acquiredItem: null,\n    collisionIds: new Set(),\n    layoutShift: null,\n    path: []\n  };\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const layoutItem = itemsLayout.items.find(it => it.id === draggableItem.id);\n  let path = [];\n  if (interactionType === \"pointer\" || operation === \"insert\") {\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n    path = layoutItem ? appendPath([], collisionRect) : [];\n  } else if (layoutItem) {\n    path = operation === \"resize\" ? [new Position({\n      x: layoutItem.x + layoutItem.width,\n      y: layoutItem.y + layoutItem.height\n    })] : [new Position({\n      x: layoutItem.x,\n      y: layoutItem.y\n    })];\n  }\n  return {\n    transition: {\n      ...transition,\n      path\n    },\n    removeTransition: null,\n    announcement: layoutItem ? {\n      type: \"dnd-started\",\n      item: draggableItem,\n      operation\n    } : null\n  };\n}\nfunction initRemoveTransition({\n  items,\n  removedItem,\n  itemsLayout\n}) {\n  const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n  const removeTransition = {\n    items,\n    removedItem,\n    layoutShift\n  };\n  return {\n    transition: null,\n    removeTransition,\n    announcement: null\n  };\n}\nfunction submitTransition(state) {\n  var _a;\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    const disturbed = new Set(removeTransition.layoutShift.moves.map(move => move.itemId));\n    disturbed.delete(removeTransition.removedItem.id);\n    return {\n      transition: null,\n      removeTransition: null,\n      announcement: {\n        type: \"item-removed\",\n        item: removeTransition.removedItem,\n        disturbed\n      }\n    };\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return ((_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.conflicts.length) === 0 ? {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-committed\",\n      item,\n      operation\n    } : null\n  } : {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction discardTransition(state) {\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    throw new Error(\"Can't discard remove transition.\");\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction updateTransitionWithPointerEvent(state, {\n  collisionIds,\n  positionOffset,\n  draggableRect\n}) {\n  var _a, _b, _c;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n  const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n  const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n  const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n  const itemSize = itemWidth * itemHeight;\n  const isOutOfBoundaries = transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n  if (isOutOfBoundaries) {\n    return {\n      transition: {\n        ...transition,\n        draggableRect,\n        collisionIds: new Set(),\n        layoutShift: null,\n        insertionDirection: null\n      },\n      removeTransition: null,\n      announcement: null\n    };\n  }\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n  const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n  const path = appendPath(transition.path, collisionRect);\n  const insertionDirection = (_c = transition.insertionDirection) !== null && _c !== void 0 ? _c : getInsertionDirection(positionOffset);\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  return {\n    transition: {\n      ...transition,\n      draggableRect,\n      collisionIds: new Set(collisionIds),\n      layoutShift,\n      path,\n      insertionDirection\n    },\n    removeTransition: null,\n    announcement: null\n  };\n}\nfunction updateTransitionWithKeyboardEvent(state, {\n  direction\n}, {\n  isRtl\n}) {\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const updateManualItemTransition = (transition, direction) => {\n    var _a, _b;\n    const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n    const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n    const lastPosition = transition.path[transition.path.length - 1];\n    const nextPosition = new Position({\n      x: lastPosition.x + xDelta,\n      y: lastPosition.y + yDelta\n    });\n    const nextPath = [...transition.path, nextPosition];\n    // Check resizing below min size.\n    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n    const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n    const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n    const minHeight = getMinRowSpan(transition.draggableItem);\n    if (transition.operation === \"resize\" && layoutItem && (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)) {\n      return state;\n    }\n    try {\n      const layoutShift = getLayoutShift(transition, nextPath);\n      const nextTransition = {\n        ...transition,\n        layoutShift,\n        path: nextPath\n      };\n      return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, direction)\n      };\n    } catch (e) {\n      // Can't create next layout because the next path is out of bounds.\n      return state;\n    }\n  };\n  switch (direction) {\n    case \"left\":\n      return updateManualItemTransition(transition, !isRtl() ? \"left\" : \"right\");\n    case \"right\":\n      return updateManualItemTransition(transition, !isRtl() ? \"right\" : \"left\");\n    case \"up\":\n      return updateManualItemTransition(transition, \"up\");\n    case \"down\":\n      return updateManualItemTransition(transition, \"down\");\n  }\n}\nfunction acquireTransitionItem(state, {\n  position,\n  layoutElement,\n  acquiredItemElement\n}) {\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    columns\n  } = transition.itemsLayout;\n  const layoutRect = getLogicalBoundingClientRect(layoutElement);\n  const itemRect = transition.draggableRect;\n  const coordinatesX = itemRect.left - layoutRect.insetInlineStart;\n  const offset = new Coordinates({\n    x: coordinatesX,\n    y: itemRect.top - layoutRect.insetBlockStart\n  });\n  const insertionDirection = getInsertionDirection(offset);\n  // Update original insertion position if the item can't fit into the layout by width.\n  const width = getDefaultColumnSpan(transition.draggableItem, columns);\n  position = new Position({\n    x: Math.min(columns - width, position.x),\n    y: position.y\n  });\n  const path = [...transition.path, position];\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n  const acquiredItem = {\n    ...transition.draggableItem,\n    columnOffset: 0,\n    columnSpan: 1,\n    rowSpan: 1\n  };\n  const nextTransition = {\n    ...transition,\n    collisionIds: new Set(),\n    layoutShift,\n    path,\n    acquiredItem,\n    acquiredItemElement\n  };\n  return {\n    transition: nextTransition,\n    removeTransition: null,\n    announcement: createOperationAnnouncement(nextTransition, null)\n  };\n}","map":{"version":3,"names":["useReducer","getLogicalBoundingClientRect","LayoutEngine","Coordinates","getDefaultColumnSpan","getDefaultRowSpan","getMinColumnSpan","getMinRowSpan","Position","createOperationAnnouncement","getHoveredRect","getInsertionDirection","getLayoutPlaceholders","getLayoutRows","getLayoutShift","appendMovePath","appendResizePath","useTransition","isRtl","createTransitionReducer","transition","removeTransition","announcement","selectTransitionRows","state","transitionReducer","action","type","initTransition","initRemoveTransition","submitTransition","discardTransition","updateTransitionWithPointerEvent","updateTransitionWithKeyboardEvent","acquireTransitionItem","operation","interactionType","itemsLayout","draggableItem","draggableRect","collisionIds","layoutEngine","insertionDirection","acquiredItem","Set","layoutShift","path","placeholdersLayout","layoutItem","items","find","it","id","collisionRect","appendPath","x","width","y","height","item","removedItem","remove","disturbed","moves","map","move","itemId","delete","Error","itemBelongsToBoard","some","_a","conflicts","length","positionOffset","layout","_b","next","itemWidth","columns","itemHeight","itemSize","isOutOfBoundaries","_c","direction","updateManualItemTransition","xDelta","yDelta","lastPosition","nextPosition","nextPath","minWidth","minHeight","nextTransition","e","position","layoutElement","acquiredItemElement","layoutRect","itemRect","coordinatesX","left","insetInlineStart","offset","top","insetBlockStart","Math","min","columnOffset","columnSpan","rowSpan"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/board/transition.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Dispatch, ReactNode, useReducer } from \"react\";\n\nimport { getLogicalBoundingClientRect } from \"@cloudscape-design/component-toolkit/internal\";\n\nimport { InteractionType, Operation } from \"../internal/dnd-controller/controller\";\nimport { BoardItemDefinitionBase, Direction, GridLayout, ItemId, Rect } from \"../internal/interfaces\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { BoardProps, RemoveTransition, Transition, TransitionAnnouncement } from \"./interfaces\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\n\nexport interface TransitionState<D> {\n  transition: null | Transition<D>;\n  removeTransition: null | RemoveTransition<D>;\n  announcement: null | TransitionAnnouncement;\n}\n\nexport type Action<D> =\n  | InitAction<D>\n  | InitRemoveAction<D>\n  | SubmitAction\n  | DiscardAction\n  | UpdateWithPointerAction\n  | UpdateWithKeyboardAction\n  | AcquireItemAction;\n\ninterface InitAction<D> {\n  type: \"init\";\n  operation: Operation;\n  interactionType: InteractionType;\n  itemsLayout: GridLayout;\n  draggableItem: BoardItemDefinitionBase<D>;\n  draggableRect: Rect;\n  collisionIds: readonly ItemId[];\n}\ninterface InitRemoveAction<D> {\n  type: \"init-remove\";\n  items: readonly BoardProps.Item<D>[];\n  removedItem: BoardItemDefinitionBase<D>;\n  itemsLayout: GridLayout;\n}\ninterface SubmitAction {\n  type: \"submit\";\n}\ninterface DiscardAction {\n  type: \"discard\";\n}\ninterface UpdateWithPointerAction {\n  type: \"update-with-pointer\";\n  collisionIds: readonly ItemId[];\n  positionOffset: Coordinates;\n  draggableRect: Rect;\n}\ninterface UpdateWithKeyboardAction {\n  type: \"update-with-keyboard\";\n  direction: Direction;\n}\ninterface AcquireItemAction {\n  type: \"acquire-item\";\n  position: Position;\n  layoutElement: HTMLElement;\n  acquiredItemElement?: ReactNode;\n}\n\nexport function useTransition<D>({ isRtl }: { isRtl: () => boolean }): [TransitionState<D>, Dispatch<Action<D>>] {\n  return useReducer(createTransitionReducer<D>({ isRtl }), {\n    transition: null,\n    removeTransition: null,\n    announcement: null,\n  });\n}\n\nexport function selectTransitionRows<D>(state: TransitionState<D>) {\n  return state.transition ? getLayoutRows(state.transition) : 0;\n}\n\nfunction createTransitionReducer<D>({ isRtl }: { isRtl: () => boolean }) {\n  return function transitionReducer(state: TransitionState<D>, action: Action<D>): TransitionState<D> {\n    switch (action.type) {\n      case \"init\":\n        return initTransition(action);\n      case \"init-remove\":\n        return initRemoveTransition(action);\n      case \"submit\":\n        return submitTransition(state);\n      case \"discard\":\n        return discardTransition(state);\n      case \"update-with-pointer\":\n        return updateTransitionWithPointerEvent(state, action);\n      case \"update-with-keyboard\":\n        return updateTransitionWithKeyboardEvent(state, action, { isRtl });\n      case \"acquire-item\":\n        return acquireTransitionItem(state, action);\n    }\n  };\n}\n\nfunction initTransition<D>({\n  operation,\n  interactionType,\n  itemsLayout,\n  draggableItem,\n  draggableRect,\n  collisionIds,\n}: InitAction<D>): TransitionState<D> {\n  const transition: Transition<D> = {\n    operation,\n    interactionType,\n    itemsLayout,\n    layoutEngine: new LayoutEngine(itemsLayout),\n    insertionDirection: null,\n    draggableItem,\n    draggableRect,\n    acquiredItem: null,\n    collisionIds: new Set(),\n    layoutShift: null,\n    path: [],\n  };\n\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n\n  const layoutItem = itemsLayout.items.find((it) => it.id === draggableItem.id);\n\n  let path: Position[] = [];\n  if (interactionType === \"pointer\" || operation === \"insert\") {\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n    path = layoutItem ? appendPath([], collisionRect) : [];\n  } else if (layoutItem) {\n    path =\n      operation === \"resize\"\n        ? [new Position({ x: layoutItem.x + layoutItem.width, y: layoutItem.y + layoutItem.height })]\n        : [new Position({ x: layoutItem.x, y: layoutItem.y })];\n  }\n\n  return {\n    transition: { ...transition, path },\n    removeTransition: null,\n    announcement: layoutItem ? { type: \"dnd-started\", item: draggableItem, operation } : null,\n  };\n}\n\nfunction initRemoveTransition<D>({ items, removedItem, itemsLayout }: InitRemoveAction<D>): TransitionState<D> {\n  const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n  const removeTransition: RemoveTransition<D> = { items, removedItem, layoutShift };\n  return { transition: null, removeTransition, announcement: null };\n}\n\nfunction submitTransition<D>(state: TransitionState<D>): TransitionState<D> {\n  const { transition, removeTransition } = state;\n\n  if (removeTransition) {\n    const disturbed = new Set(removeTransition.layoutShift.moves.map((move) => move.itemId));\n    disturbed.delete(removeTransition.removedItem.id);\n    return {\n      transition: null,\n      removeTransition: null,\n      announcement: { type: \"item-removed\", item: removeTransition.removedItem, disturbed },\n    };\n  }\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n  const itemBelongsToBoard = item.id === acquiredItem?.id || itemsLayout.items.some((it) => it.id === item.id);\n\n  return transition.layoutShift?.conflicts.length === 0\n    ? {\n        transition: null,\n        removeTransition: null,\n        announcement: itemBelongsToBoard ? { type: \"dnd-committed\", item, operation } : null,\n      }\n    : {\n        transition: null,\n        removeTransition: null,\n        announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n      };\n}\n\nfunction discardTransition<D>(state: TransitionState<D>): TransitionState<D> {\n  const { transition, removeTransition } = state;\n\n  if (removeTransition) {\n    throw new Error(\"Can't discard remove transition.\");\n  }\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n  const itemBelongsToBoard = item.id === acquiredItem?.id || itemsLayout.items.some((it) => it.id === item.id);\n\n  return {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n  };\n}\n\nfunction updateTransitionWithPointerEvent<D>(\n  state: TransitionState<D>,\n  { collisionIds, positionOffset, draggableRect }: UpdateWithPointerAction,\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const layout = transition.layoutShift?.next ?? transition.itemsLayout;\n  const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n  const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n  const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n  const itemSize = itemWidth * itemHeight;\n\n  const isOutOfBoundaries =\n    transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n\n  if (isOutOfBoundaries) {\n    return {\n      transition: {\n        ...transition,\n        draggableRect,\n        collisionIds: new Set(),\n        layoutShift: null,\n        insertionDirection: null,\n      },\n      removeTransition: null,\n      announcement: null,\n    };\n  }\n\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n  const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n  const path = appendPath(transition.path, collisionRect);\n\n  const insertionDirection = transition.insertionDirection ?? getInsertionDirection(positionOffset);\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n\n  return {\n    transition: {\n      ...transition,\n      draggableRect,\n      collisionIds: new Set(collisionIds),\n      layoutShift,\n      path,\n      insertionDirection,\n    },\n    removeTransition: null,\n    announcement: null,\n  };\n}\n\nfunction updateTransitionWithKeyboardEvent<D>(\n  state: TransitionState<D>,\n  { direction }: UpdateWithKeyboardAction,\n  { isRtl }: { isRtl: () => boolean },\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const updateManualItemTransition = (transition: Transition<D>, direction: Direction): TransitionState<D> => {\n    const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n    const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n    const lastPosition = transition.path[transition.path.length - 1];\n    const nextPosition = new Position({ x: lastPosition.x + xDelta, y: lastPosition.y + yDelta });\n    const nextPath = [...transition.path, nextPosition];\n\n    // Check resizing below min size.\n    const layout = transition.layoutShift?.next ?? transition.itemsLayout;\n    const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n    const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n    const minHeight = getMinRowSpan(transition.draggableItem);\n    if (\n      transition.operation === \"resize\" &&\n      layoutItem &&\n      (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)\n    ) {\n      return state;\n    }\n\n    try {\n      const layoutShift = getLayoutShift(transition, nextPath);\n      const nextTransition = { ...transition, layoutShift, path: nextPath };\n      return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, direction),\n      };\n    } catch (e) {\n      // Can't create next layout because the next path is out of bounds.\n      return state;\n    }\n  };\n\n  switch (direction) {\n    case \"left\":\n      return updateManualItemTransition(transition, !isRtl() ? \"left\" : \"right\");\n    case \"right\":\n      return updateManualItemTransition(transition, !isRtl() ? \"right\" : \"left\");\n    case \"up\":\n      return updateManualItemTransition(transition, \"up\");\n    case \"down\":\n      return updateManualItemTransition(transition, \"down\");\n  }\n}\n\nfunction acquireTransitionItem<D>(\n  state: TransitionState<D>,\n  { position, layoutElement, acquiredItemElement }: AcquireItemAction,\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { columns } = transition.itemsLayout;\n\n  const layoutRect = getLogicalBoundingClientRect(layoutElement);\n  const itemRect = transition.draggableRect;\n  const coordinatesX = itemRect.left - layoutRect.insetInlineStart;\n  const offset = new Coordinates({ x: coordinatesX, y: itemRect.top - layoutRect.insetBlockStart });\n  const insertionDirection = getInsertionDirection(offset);\n\n  // Update original insertion position if the item can't fit into the layout by width.\n  const width = getDefaultColumnSpan(transition.draggableItem, columns);\n  position = new Position({ x: Math.min(columns - width, position.x), y: position.y });\n\n  const path = [...transition.path, position];\n\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n\n  // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n  const acquiredItem = { ...transition.draggableItem, columnOffset: 0, columnSpan: 1, rowSpan: 1 };\n\n  const nextTransition: Transition<D> = {\n    ...transition,\n    collisionIds: new Set(),\n    layoutShift,\n    path,\n    acquiredItem,\n    acquiredItemElement,\n  };\n  return {\n    transition: nextTransition,\n    removeTransition: null,\n    announcement: createOperationAnnouncement(nextTransition, null),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}