{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  constructor(layout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n  move(moveCommand, cache = this.cache) {\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({\n      ...moveCommand\n    }, cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  resize(resizeCommand) {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({\n        x: width,\n        y: height\n      }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n    return this.getLayoutShift(cache.state);\n  }\n  insert({\n    itemId,\n    width,\n    height,\n    path: [position, ...movePath]\n  }) {\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", {\n      id: itemId,\n      x: position.x,\n      y: position.y,\n      width,\n      height\n    }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n    return this.move({\n      itemId,\n      path: movePath\n    }, cache);\n  }\n  remove(itemId) {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", {\n      id: itemId,\n      x,\n      y,\n      width,\n      height\n    }, new Position({\n      x,\n      y\n    }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n  getLayoutShift(state) {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : []\n    };\n  }\n  validateMovePath({\n    itemId,\n    path\n  }, state) {\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({\n      x: moveTarget.x,\n      y: moveTarget.y\n    }), path);\n  }\n  validateResizePath({\n    itemId,\n    path\n  }, state) {\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({\n      x,\n      y\n    }), path);\n  }\n}","map":{"version":3,"names":["Position","LayoutEngineCacheNode","LayoutEngineState","resolveOverlaps","LayoutEngineGrid","createMove","normalizeMovePath","normalizeResizePath","sortGridItems","LayoutEngine","constructor","layout","cache","items","columns","move","moveCommand","path","validateMovePath","state","stepIndex","length","item","grid","getItem","itemId","matches","getLayoutShift","resize","resizeCommand","validateResizePath","resizeTarget","width","x","height","y","insert","position","movePath","insertMove","id","remove","current","next","rows","moves","conflicts","moveTarget","step","Error"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/layout-engine/engine.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { GridLayout, ItemId } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineCacheNode } from \"./engine-cache\";\nimport { LayoutEngineState } from \"./engine-state\";\nimport { resolveOverlaps } from \"./engine-step\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { InsertCommand, LayoutShift, MoveCommand, ResizeCommand } from \"./interfaces\";\nimport { createMove, normalizeMovePath, normalizeResizePath, sortGridItems } from \"./utils\";\n\n/**\n * Layout engine is an abstraction to compute effects of user actions (move, resize, insert, remove).\n * The engine is initialized with the board state and then takes a command to calculate the respective layout shift.\n * Use a single engine instance until the user commits their move to take advantage of the internal cache.\n * Once user move is committed the layout engine needs to be re-initialized with the updated layout state.\n */\nexport class LayoutEngine {\n  private layout: GridLayout;\n  private cache: LayoutEngineCacheNode;\n\n  constructor(layout: GridLayout) {\n    this.layout = layout;\n    this.cache = new LayoutEngineCacheNode(new LayoutEngineState(new LayoutEngineGrid(layout.items, layout.columns)));\n  }\n\n  move(moveCommand: MoveCommand, cache = this.cache): LayoutShift {\n    // The validation ensures no position in the path is outside the board and updates the path so that all\n    // positions are incremental (moving one cell at a time) and no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateMovePath({ ...moveCommand }, cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const item = cache.state.grid.getItem(moveCommand.itemId);\n      const move = createMove(\"MOVE\", item, path[stepIndex]);\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  resize(resizeCommand: ResizeCommand): LayoutShift {\n    // The validation ensures no position in the path is outside the board and the width/height are above 0.\n    // The resize path is updated so that all positions are incremental (moving one cell at a time) and\n    // no loops are present (no position can occur twice).\n    // Removing the loops guarantees that moving back to one of the previous positions including the starting one\n    // revives the previous state as is. The same behavior might cause confusion in case the user comes back\n    // to a previous position accidentally especially if the move path is long.\n    const path = this.validateResizePath(resizeCommand, this.cache.state);\n\n    // The user command is resolved one step at a time. When layout engine is reused withing one transition\n    // it is expected that all steps but the last one are already cached.\n    let cache = this.cache;\n    for (let stepIndex = 0; stepIndex < path.length; stepIndex++) {\n      const resizeTarget = cache.state.grid.getItem(resizeCommand.itemId);\n      const width = path[stepIndex].x - resizeTarget.x;\n      const height = path[stepIndex].y - resizeTarget.y;\n      const move = createMove(\"RESIZE\", resizeTarget, new Position({ x: width, y: height }));\n      cache = cache.matches(path[stepIndex], () => resolveOverlaps(cache.state, move));\n    }\n\n    return this.getLayoutShift(cache.state);\n  }\n\n  insert({ itemId, width, height, path: [position, ...movePath] }: InsertCommand): LayoutShift {\n    // For insert command the new item is injected to the given location first and then it can be moved\n    // the same way as the existing item would.\n    const insertMove = createMove(\"INSERT\", { id: itemId, x: position.x, y: position.y, width, height }, position);\n    const cache = this.cache.matches(position, () => resolveOverlaps(this.cache.state, insertMove));\n\n    return this.move({ itemId, path: movePath }, cache);\n  }\n\n  remove(itemId: ItemId): LayoutShift {\n    // The remove command does not define the move path and is not cached. It is expected to be performed only once.\n    const { x, y, width, height } = this.cache.state.grid.getItem(itemId);\n    const move = createMove(\"REMOVE\", { id: itemId, x, y, width, height }, new Position({ x, y }));\n    const state = resolveOverlaps(this.cache.state, move);\n    return this.getLayoutShift(state);\n  }\n\n  private getLayoutShift(state: LayoutEngineState): LayoutShift {\n    return {\n      current: this.layout,\n      next: {\n        items: sortGridItems(state.grid.items),\n        columns: state.grid.width,\n        rows: state.grid.height,\n      },\n      moves: state.moves,\n      conflicts: state.conflicts ? [...state.conflicts.items] : [],\n    };\n  }\n\n  private validateMovePath({ itemId, path }: MoveCommand, state: LayoutEngineState): readonly Position[] {\n    const moveTarget = state.grid.getItem(itemId);\n    for (const step of path) {\n      if (step.x < 0 || step.y < 0 || step.x + moveTarget.width > state.grid.width) {\n        throw new Error(\"Invalid move: outside grid.\");\n      }\n    }\n    return normalizeMovePath(new Position({ x: moveTarget.x, y: moveTarget.y }), path);\n  }\n\n  private validateResizePath({ itemId, path }: ResizeCommand, state: LayoutEngineState): readonly Position[] {\n    const resizeTarget = state.grid.getItem(itemId);\n    const x = resizeTarget.x + resizeTarget.width;\n    const y = resizeTarget.y + resizeTarget.height;\n    for (const step of path) {\n      if (step.x < 1 || step.y < 1) {\n        throw new Error(\"Invalid resize: can't resize to 0.\");\n      }\n      if (step.x > state.grid.width) {\n        throw new Error(\"Invalid resize: outside grid.\");\n      }\n    }\n    return normalizeResizePath(new Position({ x, y }), path);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}