{"ast":null,"code":"/**\n * @typedef {import('mdast').Literal} Literal\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('micromark-extension-frontmatter').Info} Info\n * @typedef {import('micromark-extension-frontmatter').Matter} Matter\n * @typedef {import('micromark-extension-frontmatter').Options} Options\n */\n\nimport { ok as assert } from 'devlop';\nimport { toMatters } from 'micromark-extension-frontmatter';\nimport escapeStringRegexp from 'escape-string-regexp';\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function frontmatterFromMarkdown(options) {\n  const matters = toMatters(options);\n  /** @type {FromMarkdownExtension['enter']} */\n  const enter = {};\n  /** @type {FromMarkdownExtension['exit']} */\n  const exit = {};\n  let index = -1;\n  while (++index < matters.length) {\n    const matter = matters[index];\n    enter[matter.type] = opener(matter);\n    exit[matter.type] = close;\n    exit[matter.type + 'Value'] = value;\n  }\n  return {\n    enter,\n    exit\n  };\n}\n\n/**\n * @param {Matter} matter\n * @returns {FromMarkdownHandle} enter\n */\nfunction opener(matter) {\n  return open;\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function open(token) {\n    // @ts-expect-error: custom.\n    this.enter({\n      type: matter.type,\n      value: ''\n    }, token);\n    this.buffer();\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction close(token) {\n  const data = this.resume();\n  const node = this.stack[this.stack.length - 1];\n  assert('value' in node);\n  this.exit(token);\n  // Remove the initial and final eol.\n  node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction value(token) {\n  this.config.enter.data.call(this, token);\n  this.config.exit.data.call(this, token);\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function frontmatterToMarkdown(options) {\n  /** @type {ToMarkdownExtension['unsafe']} */\n  const unsafe = [];\n  /** @type {ToMarkdownExtension['handlers']} */\n  const handlers = {};\n  const matters = toMatters(options);\n  let index = -1;\n  while (++index < matters.length) {\n    const matter = matters[index];\n\n    // @ts-expect-error: this can add custom frontmatter nodes.\n    // Typing those is the responsibility of the end user.\n    handlers[matter.type] = handler(matter);\n    const open = fence(matter, 'open');\n    unsafe.push({\n      atBreak: true,\n      character: open.charAt(0),\n      after: escapeStringRegexp(open.charAt(1))\n    });\n  }\n  return {\n    unsafe,\n    handlers\n  };\n}\n\n/**\n * Create a handle that can serialize a frontmatter node as markdown.\n *\n * @param {Matter} matter\n *   Structure.\n * @returns {(node: Literal) => string} enter\n *   Handler.\n */\nfunction handler(matter) {\n  const open = fence(matter, 'open');\n  const close = fence(matter, 'close');\n  return handle;\n\n  /**\n   * Serialize a frontmatter node as markdown.\n   *\n   * @param {Literal} node\n   *   Node to serialize.\n   * @returns {string}\n   *   Serialized node.\n   */\n  function handle(node) {\n    return open + (node.value ? '\\n' + node.value : '') + '\\n' + close;\n  }\n}\n\n/**\n * Get an `open` or `close` fence.\n *\n * @param {Matter} matter\n *   Structure.\n * @param {'close' | 'open'} prop\n *   Field to get.\n * @returns {string}\n *   Fence.\n */\nfunction fence(matter, prop) {\n  return matter.marker ? pick(matter.marker, prop).repeat(3) :\n  // @ts-expect-error: They’re mutually exclusive.\n  pick(matter.fence, prop);\n}\n\n/**\n * Take `open` or `close` fields when schema is an info object, or use the\n * given value when it is a string.\n *\n * @param {Info | string} schema\n *   Info object or value.\n * @param {'close' | 'open'} prop\n *   Field to get.\n * @returns {string}\n *   Thing to use for the opening or closing.\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop];\n}","map":{"version":3,"names":["ok","assert","toMatters","escapeStringRegexp","frontmatterFromMarkdown","options","matters","enter","exit","index","length","matter","type","opener","close","value","open","token","buffer","data","resume","node","stack","replace","config","call","frontmatterToMarkdown","unsafe","handlers","handler","fence","push","atBreak","character","charAt","after","handle","prop","marker","pick","repeat","schema"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/mdast-util-frontmatter/lib/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast').Literal} Literal\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n *\n * @typedef {import('micromark-extension-frontmatter').Info} Info\n * @typedef {import('micromark-extension-frontmatter').Matter} Matter\n * @typedef {import('micromark-extension-frontmatter').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {toMatters} from 'micromark-extension-frontmatter'\nimport escapeStringRegexp from 'escape-string-regexp'\n\n/**\n * Create an extension for `mdast-util-from-markdown`.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown`.\n */\nexport function frontmatterFromMarkdown(options) {\n  const matters = toMatters(options)\n  /** @type {FromMarkdownExtension['enter']} */\n  const enter = {}\n  /** @type {FromMarkdownExtension['exit']} */\n  const exit = {}\n  let index = -1\n\n  while (++index < matters.length) {\n    const matter = matters[index]\n    enter[matter.type] = opener(matter)\n    exit[matter.type] = close\n    exit[matter.type + 'Value'] = value\n  }\n\n  return {enter, exit}\n}\n\n/**\n * @param {Matter} matter\n * @returns {FromMarkdownHandle} enter\n */\nfunction opener(matter) {\n  return open\n\n  /**\n   * @this {CompileContext}\n   * @type {FromMarkdownHandle}\n   */\n  function open(token) {\n    // @ts-expect-error: custom.\n    this.enter({type: matter.type, value: ''}, token)\n    this.buffer()\n  }\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction close(token) {\n  const data = this.resume()\n  const node = this.stack[this.stack.length - 1]\n  assert('value' in node)\n  this.exit(token)\n  // Remove the initial and final eol.\n  node.value = data.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n}\n\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */\nfunction value(token) {\n  this.config.enter.data.call(this, token)\n  this.config.exit.data.call(this, token)\n}\n\n/**\n * Create an extension for `mdast-util-to-markdown`.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown`.\n */\nexport function frontmatterToMarkdown(options) {\n  /** @type {ToMarkdownExtension['unsafe']} */\n  const unsafe = []\n  /** @type {ToMarkdownExtension['handlers']} */\n  const handlers = {}\n  const matters = toMatters(options)\n  let index = -1\n\n  while (++index < matters.length) {\n    const matter = matters[index]\n\n    // @ts-expect-error: this can add custom frontmatter nodes.\n    // Typing those is the responsibility of the end user.\n    handlers[matter.type] = handler(matter)\n\n    const open = fence(matter, 'open')\n\n    unsafe.push({\n      atBreak: true,\n      character: open.charAt(0),\n      after: escapeStringRegexp(open.charAt(1))\n    })\n  }\n\n  return {unsafe, handlers}\n}\n\n/**\n * Create a handle that can serialize a frontmatter node as markdown.\n *\n * @param {Matter} matter\n *   Structure.\n * @returns {(node: Literal) => string} enter\n *   Handler.\n */\nfunction handler(matter) {\n  const open = fence(matter, 'open')\n  const close = fence(matter, 'close')\n\n  return handle\n\n  /**\n   * Serialize a frontmatter node as markdown.\n   *\n   * @param {Literal} node\n   *   Node to serialize.\n   * @returns {string}\n   *   Serialized node.\n   */\n  function handle(node) {\n    return open + (node.value ? '\\n' + node.value : '') + '\\n' + close\n  }\n}\n\n/**\n * Get an `open` or `close` fence.\n *\n * @param {Matter} matter\n *   Structure.\n * @param {'close' | 'open'} prop\n *   Field to get.\n * @returns {string}\n *   Fence.\n */\nfunction fence(matter, prop) {\n  return matter.marker\n    ? pick(matter.marker, prop).repeat(3)\n    : // @ts-expect-error: They’re mutually exclusive.\n      pick(matter.fence, prop)\n}\n\n/**\n * Take `open` or `close` fields when schema is an info object, or use the\n * given value when it is a string.\n *\n * @param {Info | string} schema\n *   Info object or value.\n * @param {'close' | 'open'} prop\n *   Field to get.\n * @returns {string}\n *   Thing to use for the opening or closing.\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}