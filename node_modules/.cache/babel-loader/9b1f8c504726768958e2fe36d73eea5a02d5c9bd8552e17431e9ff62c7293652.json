{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n/**\n * @param containerRef ref to surrounding container with sticky element\n * @param stickyRef ref to sticky element scrolled inside of containerRef\n * @param containerOffset offset between header and container\n *                        originating borders or paddings\n */\nexport default function stickyScrolling(containerRef, stickyRef) {\n  const scrollToTop = () => {\n    if (!containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  const scrollToItem = item => {\n    if (!item || !containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const stickyBottom = getLogicalBoundingClientRect(stickyRef.current).insetBlockEnd;\n    const scrollingOffset = stickyBottom - getLogicalBoundingClientRect(item).insetBlockStart;\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  return {\n    scrollToTop,\n    scrollToItem\n  };\n}\n/**\n * Calculates the scrolling offset between container and\n * sticky element with container offset caused by border\n * or padding\n * @param container\n * @param sticky element inside of container\n * @param containerOffset caused by borders or paddings\n */\nexport function calculateScrollingOffset(container, sticky) {\n  const stickyRect = getLogicalBoundingClientRect(sticky);\n  const containerRect = getLogicalBoundingClientRect(container);\n  return stickyRect.insetBlockStart - containerRect.insetBlockStart;\n}\n/**\n * Scrolls suitable parent of container up by amount of pixels\n * @param amount pixels to be scrolled up\n * @param container used to determine next parent element for scrolling\n */\nexport function scrollUpBy(amount, container) {\n  const parent = getOverflowParents(container);\n  if (parent.length) {\n    // Take next overflow parent in stack\n    parent[0].scrollTop -= amount;\n  } else {\n    window.scrollTo({\n      top: window.pageYOffset - amount\n    });\n  }\n}","map":{"version":3,"names":["getLogicalBoundingClientRect","getOverflowParents","stickyScrolling","containerRef","stickyRef","scrollToTop","current","scrollingOffset","calculateScrollingOffset","scrollUpBy","scrollToItem","item","stickyBottom","insetBlockEnd","insetBlockStart","container","sticky","stickyRect","containerRect","amount","parent","length","scrollTop","window","scrollTo","top","pageYOffset"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/table/sticky-scrolling.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\n/**\n * @param containerRef ref to surrounding container with sticky element\n * @param stickyRef ref to sticky element scrolled inside of containerRef\n * @param containerOffset offset between header and container\n *                        originating borders or paddings\n */\nexport default function stickyScrolling(\n  containerRef: React.MutableRefObject<HTMLElement | null>,\n  stickyRef: React.MutableRefObject<HTMLElement | null>\n) {\n  const scrollToTop = () => {\n    if (!containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  const scrollToItem = (item: HTMLElement | null) => {\n    if (!item || !containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const stickyBottom = getLogicalBoundingClientRect(stickyRef.current).insetBlockEnd;\n    const scrollingOffset = stickyBottom - getLogicalBoundingClientRect(item).insetBlockStart;\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  return {\n    scrollToTop,\n    scrollToItem,\n  };\n}\n\n/**\n * Calculates the scrolling offset between container and\n * sticky element with container offset caused by border\n * or padding\n * @param container\n * @param sticky element inside of container\n * @param containerOffset caused by borders or paddings\n */\nexport function calculateScrollingOffset(container: HTMLElement, sticky: HTMLElement) {\n  const stickyRect = getLogicalBoundingClientRect(sticky);\n  const containerRect = getLogicalBoundingClientRect(container);\n  return stickyRect.insetBlockStart - containerRect.insetBlockStart;\n}\n\n/**\n * Scrolls suitable parent of container up by amount of pixels\n * @param amount pixels to be scrolled up\n * @param container used to determine next parent element for scrolling\n */\nexport function scrollUpBy(amount: number, container: HTMLElement) {\n  const parent = getOverflowParents(container);\n  if (parent.length) {\n    // Take next overflow parent in stack\n    parent[0].scrollTop -= amount;\n  } else {\n    window.scrollTo({ top: window.pageYOffset - amount });\n  }\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,4BAA4B,QAAQ,+CAA+C;AAE5F,SAASC,kBAAkB,QAAQ,yCAAyC;AAE5E;;;;;;AAMA,eAAc,SAAUC,eAAeA,CACrCC,YAAwD,EACxDC,SAAqD;EAErD,MAAMC,WAAW,GAAGA,CAAA,KAAK;IACvB,IAAI,CAACF,YAAY,CAACG,OAAO,IAAI,CAACF,SAAS,CAACE,OAAO,EAAE;MAC/C;;IAEF,MAAMC,eAAe,GAAGC,wBAAwB,CAACL,YAAY,CAACG,OAAO,EAAEF,SAAS,CAACE,OAAO,CAAC;IACzF,IAAIC,eAAe,GAAG,CAAC,EAAE;MACvBE,UAAU,CAACF,eAAe,EAAEJ,YAAY,CAACG,OAAO,CAAC;;EAErD,CAAC;EACD,MAAMI,YAAY,GAAIC,IAAwB,IAAI;IAChD,IAAI,CAACA,IAAI,IAAI,CAACR,YAAY,CAACG,OAAO,IAAI,CAACF,SAAS,CAACE,OAAO,EAAE;MACxD;;IAEF,MAAMM,YAAY,GAAGZ,4BAA4B,CAACI,SAAS,CAACE,OAAO,CAAC,CAACO,aAAa;IAClF,MAAMN,eAAe,GAAGK,YAAY,GAAGZ,4BAA4B,CAACW,IAAI,CAAC,CAACG,eAAe;IACzF,IAAIP,eAAe,GAAG,CAAC,EAAE;MACvBE,UAAU,CAACF,eAAe,EAAEJ,YAAY,CAACG,OAAO,CAAC;;EAErD,CAAC;EACD,OAAO;IACLD,WAAW;IACXK;GACD;AACH;AAEA;;;;;;;;AAQA,OAAM,SAAUF,wBAAwBA,CAACO,SAAsB,EAAEC,MAAmB;EAClF,MAAMC,UAAU,GAAGjB,4BAA4B,CAACgB,MAAM,CAAC;EACvD,MAAME,aAAa,GAAGlB,4BAA4B,CAACe,SAAS,CAAC;EAC7D,OAAOE,UAAU,CAACH,eAAe,GAAGI,aAAa,CAACJ,eAAe;AACnE;AAEA;;;;;AAKA,OAAM,SAAUL,UAAUA,CAACU,MAAc,EAAEJ,SAAsB;EAC/D,MAAMK,MAAM,GAAGnB,kBAAkB,CAACc,SAAS,CAAC;EAC5C,IAAIK,MAAM,CAACC,MAAM,EAAE;IACjB;IACAD,MAAM,CAAC,CAAC,CAAC,CAACE,SAAS,IAAIH,MAAM;GAC9B,MAAM;IACLI,MAAM,CAACC,QAAQ,CAAC;MAAEC,GAAG,EAAEF,MAAM,CAACG,WAAW,GAAGP;IAAM,CAAE,CAAC;;AAEzD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}