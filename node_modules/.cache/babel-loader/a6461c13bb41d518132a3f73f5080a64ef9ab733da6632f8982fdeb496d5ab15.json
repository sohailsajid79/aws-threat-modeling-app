{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, forwardRef, useContext, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport { nodeBelongs } from '../utils/node-belongs';\nexport const defaultValue = {\n  navigationActive: false,\n  registerFocusable: () => () => {}\n};\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\nexport function useSingleTabStopNavigation(focusable, options) {\n  var _a;\n  const {\n    navigationActive: contextNavigationActive,\n    registerFocusable\n  } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : (_a = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a !== void 0 ? _a : 0;\n  }\n  return {\n    navigationActive,\n    tabIndex\n  };\n}\nexport const SingleTabStopNavigationProvider = forwardRef((_ref, ref) => {\n  let {\n    navigationActive,\n    children,\n    getNextFocusTarget,\n    isElementSuppressed,\n    onRegisterFocusable,\n    onUnregisterActive\n  } = _ref;\n  // A set of registered focusable elements that can use keyboard navigation.\n  const focusables = useRef(new Set());\n  // A map of registered focusable element handlers to update the respective tab indices.\n  const focusHandlers = useRef(new Map());\n  // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n  const focusablesState = useRef(new WeakMap());\n  // A reference to the currently focused element.\n  const focusTarget = useRef(null);\n  function onUnregisterFocusable(focusableElement) {\n    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n    if (isUnregisteringFocusedNode) {\n      // Wait for unmounted node to get removed from the DOM.\n      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);\n    }\n  }\n  // Register a focusable element to allow navigating into it.\n  // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n  function registerFocusable(focusableElement, changeHandler) {\n    focusables.current.add(focusableElement);\n    focusHandlers.current.set(focusableElement, changeHandler);\n    const isFocusable = !!focusablesState.current.get(focusableElement);\n    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n    if (newIsFocusable !== isFocusable) {\n      focusablesState.current.set(focusableElement, newIsFocusable);\n      changeHandler(newIsFocusable);\n    }\n    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);\n    return () => unregisterFocusable(focusableElement);\n  }\n  function unregisterFocusable(focusableElement) {\n    focusables.current.delete(focusableElement);\n    focusHandlers.current.delete(focusableElement);\n    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);\n  }\n  // Update focus target with next single focusable element and notify all registered focusables of a change.\n  function updateFocusTarget() {\n    var _a;\n    focusTarget.current = getNextFocusTarget();\n    for (const focusableElement of focusables.current) {\n      const isFocusable = (_a = focusablesState.current.get(focusableElement)) !== null && _a !== void 0 ? _a : false;\n      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        focusHandlers.current.get(focusableElement)(newIsFocusable);\n      }\n    }\n  }\n  function getFocusTarget() {\n    return focusTarget.current;\n  }\n  function isRegistered(element) {\n    return focusables.current.has(element);\n  }\n  useImperativeHandle(ref, () => ({\n    updateFocusTarget,\n    getFocusTarget,\n    isRegistered\n  }));\n  return React.createElement(SingleTabStopNavigationContext.Provider, {\n    value: {\n      navigationActive,\n      registerFocusable\n    }\n  }, children);\n});","map":{"version":3,"names":["React","createContext","forwardRef","useContext","useImperativeHandle","useLayoutEffect","useRef","useState","nodeBelongs","defaultValue","navigationActive","registerFocusable","SingleTabStopNavigationContext","useSingleTabStopNavigation","focusable","options","contextNavigationActive","focusTargetActive","setFocusTargetActive","navigationDisabled","tabIndex","current","unregister","isFocusable","_a","SingleTabStopNavigationProvider","_ref","ref","children","getNextFocusTarget","isElementSuppressed","onRegisterFocusable","onUnregisterActive","focusables","Set","focusHandlers","Map","focusablesState","WeakMap","focusTarget","onUnregisterFocusable","focusableElement","isUnregisteringFocusedNode","document","activeElement","setTimeout","changeHandler","add","set","get","newIsFocusable","unregisterFocusable","delete","updateFocusTarget","getFocusTarget","isRegistered","element","has","createElement","Provider","value"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/context/single-tab-stop-navigation-context.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, {\n  createContext,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { nodeBelongs } from '../utils/node-belongs';\n\nexport type FocusableChangeHandler = (isFocusable: boolean) => void;\n\nexport interface SingleTabStopNavigationOptions {\n  tabIndex?: number;\n}\n\nexport const defaultValue: {\n  navigationActive: boolean;\n  registerFocusable(focusable: HTMLElement, handler: FocusableChangeHandler): () => void;\n} = {\n  navigationActive: false,\n  registerFocusable: () => () => {},\n};\n\n/**\n * Single tab stop navigation context is used together with keyboard navigation that requires a single tab stop.\n * It instructs interactive elements to override tab indices for just a single one to remain user-focusable.\n */\nexport const SingleTabStopNavigationContext = createContext(defaultValue);\n\nexport function useSingleTabStopNavigation(\n  focusable: null | React.RefObject<HTMLElement>,\n  options?: { tabIndex?: number }\n) {\n  const { navigationActive: contextNavigationActive, registerFocusable } = useContext(SingleTabStopNavigationContext);\n  const [focusTargetActive, setFocusTargetActive] = useState(false);\n  const navigationDisabled = options?.tabIndex && options?.tabIndex < 0;\n  const navigationActive = contextNavigationActive && !navigationDisabled;\n\n  useLayoutEffect(() => {\n    if (navigationActive && focusable && focusable.current) {\n      const unregister = registerFocusable(focusable.current, isFocusable => setFocusTargetActive(isFocusable));\n      return () => unregister();\n    }\n  });\n\n  let tabIndex = options?.tabIndex;\n  if (navigationActive) {\n    tabIndex = !focusTargetActive ? -1 : options?.tabIndex ?? 0;\n  }\n\n  return { navigationActive, tabIndex };\n}\n\nexport interface SingleTabStopNavigationProviderProps {\n  navigationActive: boolean;\n  children: React.ReactNode;\n  getNextFocusTarget: () => null | HTMLElement;\n  isElementSuppressed?(focusableElement: Element): boolean;\n  onRegisterFocusable?(focusableElement: Element): void;\n  onUnregisterActive?(focusableElement: Element): void;\n}\n\nexport interface SingleTabStopNavigationAPI {\n  updateFocusTarget(): void;\n  getFocusTarget(): null | HTMLElement;\n  isRegistered(element: Element): boolean;\n}\n\nexport const SingleTabStopNavigationProvider = forwardRef(\n  (\n    {\n      navigationActive,\n      children,\n      getNextFocusTarget,\n      isElementSuppressed,\n      onRegisterFocusable,\n      onUnregisterActive,\n    }: SingleTabStopNavigationProviderProps,\n    ref: React.Ref<SingleTabStopNavigationAPI>\n  ) => {\n    // A set of registered focusable elements that can use keyboard navigation.\n    const focusables = useRef(new Set<Element>());\n    // A map of registered focusable element handlers to update the respective tab indices.\n    const focusHandlers = useRef(new Map<Element, FocusableChangeHandler>());\n    // A map of focusable element states to avoid issuing unnecessary updates to registered elements.\n    const focusablesState = useRef(new WeakMap<Element, boolean>());\n    // A reference to the currently focused element.\n    const focusTarget = useRef<null | HTMLElement>(null);\n\n    function onUnregisterFocusable(focusableElement: Element) {\n      const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);\n      if (isUnregisteringFocusedNode) {\n        // Wait for unmounted node to get removed from the DOM.\n        setTimeout(() => onUnregisterActive?.(focusableElement), 0);\n      }\n    }\n\n    // Register a focusable element to allow navigating into it.\n    // The focusable element tabIndex is only set to 0 if the element matches the focus target.\n    function registerFocusable(focusableElement: Element, changeHandler: FocusableChangeHandler) {\n      focusables.current.add(focusableElement);\n      focusHandlers.current.set(focusableElement, changeHandler);\n      const isFocusable = !!focusablesState.current.get(focusableElement);\n      const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n      if (newIsFocusable !== isFocusable) {\n        focusablesState.current.set(focusableElement, newIsFocusable);\n        changeHandler(newIsFocusable);\n      }\n      onRegisterFocusable?.(focusableElement);\n      return () => unregisterFocusable(focusableElement);\n    }\n    function unregisterFocusable(focusableElement: Element) {\n      focusables.current.delete(focusableElement);\n      focusHandlers.current.delete(focusableElement);\n      onUnregisterFocusable?.(focusableElement);\n    }\n\n    // Update focus target with next single focusable element and notify all registered focusables of a change.\n    function updateFocusTarget() {\n      focusTarget.current = getNextFocusTarget();\n      for (const focusableElement of focusables.current) {\n        const isFocusable = focusablesState.current.get(focusableElement) ?? false;\n        const newIsFocusable = focusTarget.current === focusableElement || !!isElementSuppressed?.(focusableElement);\n        if (newIsFocusable !== isFocusable) {\n          focusablesState.current.set(focusableElement, newIsFocusable);\n          focusHandlers.current.get(focusableElement)!(newIsFocusable);\n        }\n      }\n    }\n\n    function getFocusTarget() {\n      return focusTarget.current;\n    }\n\n    function isRegistered(element: Element) {\n      return focusables.current.has(element);\n    }\n\n    useImperativeHandle(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));\n\n    return (\n      <SingleTabStopNavigationContext.Provider value={{ navigationActive, registerFocusable }}>\n        {children}\n      </SingleTabStopNavigationContext.Provider>\n    );\n  }\n);\n"],"mappings":"AAAA;AACA;AAEA,OAAOA,KAAK,IACVC,aAAa,EACbC,UAAU,EACVC,UAAU,EACVC,mBAAmB,EACnBC,eAAe,EACfC,MAAM,EACNC,QAAQ,QACH,OAAO;AAEd,SAASC,WAAW,QAAQ,uBAAuB;AAQnD,OAAO,MAAMC,YAAY,GAGrB;EACFC,gBAAgB,EAAE,KAAK;EACvBC,iBAAiB,EAAEA,CAAA,KAAM,MAAK,CAAE;CACjC;AAED;;;;AAIA,OAAO,MAAMC,8BAA8B,GAAGX,aAAa,CAACQ,YAAY,CAAC;AAEzE,OAAM,SAAUI,0BAA0BA,CACxCC,SAA8C,EAC9CC,OAA+B;;EAE/B,MAAM;IAAEL,gBAAgB,EAAEM,uBAAuB;IAAEL;EAAiB,CAAE,GAAGR,UAAU,CAACS,8BAA8B,CAAC;EACnH,MAAM,CAACK,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGX,QAAQ,CAAC,KAAK,CAAC;EACjE,MAAMY,kBAAkB,GAAG,CAAAJ,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,QAAQ,KAAI,CAAAL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,QAAQ,IAAG,CAAC;EACrE,MAAMV,gBAAgB,GAAGM,uBAAuB,IAAI,CAACG,kBAAkB;EAEvEd,eAAe,CAAC,MAAK;IACnB,IAAIK,gBAAgB,IAAII,SAAS,IAAIA,SAAS,CAACO,OAAO,EAAE;MACtD,MAAMC,UAAU,GAAGX,iBAAiB,CAACG,SAAS,CAACO,OAAO,EAAEE,WAAW,IAAIL,oBAAoB,CAACK,WAAW,CAAC,CAAC;MACzG,OAAO,MAAMD,UAAU,EAAE;;EAE7B,CAAC,CAAC;EAEF,IAAIF,QAAQ,GAAGL,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,QAAQ;EAChC,IAAIV,gBAAgB,EAAE;IACpBU,QAAQ,GAAG,CAACH,iBAAiB,GAAG,CAAC,CAAC,GAAG,CAAAO,EAAA,GAAAT,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEK,QAAQ,cAAAI,EAAA,cAAAA,EAAA,GAAI,CAAC;;EAG7D,OAAO;IAAEd,gBAAgB;IAAEU;EAAQ,CAAE;AACvC;AAiBA,OAAO,MAAMK,+BAA+B,GAAGvB,UAAU,CACvD,CAAAwB,IAAA,EASEC,GAA0C,KACxC;EAAA,IATF;IACEjB,gBAAgB;IAChBkB,QAAQ;IACRC,kBAAkB;IAClBC,mBAAmB;IACnBC,mBAAmB;IACnBC;EAAkB,CACmB,GAAAN,IAAA;EAGvC;EACA,MAAMO,UAAU,GAAG3B,MAAM,CAAC,IAAI4B,GAAG,EAAW,CAAC;EAC7C;EACA,MAAMC,aAAa,GAAG7B,MAAM,CAAC,IAAI8B,GAAG,EAAmC,CAAC;EACxE;EACA,MAAMC,eAAe,GAAG/B,MAAM,CAAC,IAAIgC,OAAO,EAAoB,CAAC;EAC/D;EACA,MAAMC,WAAW,GAAGjC,MAAM,CAAqB,IAAI,CAAC;EAEpD,SAASkC,qBAAqBA,CAACC,gBAAyB;IACtD,MAAMC,0BAA0B,GAAGlC,WAAW,CAACiC,gBAAgB,EAAEE,QAAQ,CAACC,aAAa,CAAC;IACxF,IAAIF,0BAA0B,EAAE;MAC9B;MACAG,UAAU,CAAC,MAAMb,kBAAkB,aAAlBA,kBAAkB,uBAAlBA,kBAAkB,CAAGS,gBAAgB,CAAC,EAAE,CAAC,CAAC;;EAE/D;EAEA;EACA;EACA,SAAS9B,iBAAiBA,CAAC8B,gBAAyB,EAAEK,aAAqC;IACzFb,UAAU,CAACZ,OAAO,CAAC0B,GAAG,CAACN,gBAAgB,CAAC;IACxCN,aAAa,CAACd,OAAO,CAAC2B,GAAG,CAACP,gBAAgB,EAAEK,aAAa,CAAC;IAC1D,MAAMvB,WAAW,GAAG,CAAC,CAACc,eAAe,CAAChB,OAAO,CAAC4B,GAAG,CAACR,gBAAgB,CAAC;IACnE,MAAMS,cAAc,GAAGX,WAAW,CAAClB,OAAO,KAAKoB,gBAAgB,IAAI,CAAC,EAACX,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,CAAGW,gBAAgB,CAAC;IAC5G,IAAIS,cAAc,KAAK3B,WAAW,EAAE;MAClCc,eAAe,CAAChB,OAAO,CAAC2B,GAAG,CAACP,gBAAgB,EAAES,cAAc,CAAC;MAC7DJ,aAAa,CAACI,cAAc,CAAC;;IAE/BnB,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,CAAGU,gBAAgB,CAAC;IACvC,OAAO,MAAMU,mBAAmB,CAACV,gBAAgB,CAAC;EACpD;EACA,SAASU,mBAAmBA,CAACV,gBAAyB;IACpDR,UAAU,CAACZ,OAAO,CAAC+B,MAAM,CAACX,gBAAgB,CAAC;IAC3CN,aAAa,CAACd,OAAO,CAAC+B,MAAM,CAACX,gBAAgB,CAAC;IAC9CD,qBAAqB,aAArBA,qBAAqB,uBAArBA,qBAAqB,CAAGC,gBAAgB,CAAC;EAC3C;EAEA;EACA,SAASY,iBAAiBA,CAAA;;IACxBd,WAAW,CAAClB,OAAO,GAAGQ,kBAAkB,EAAE;IAC1C,KAAK,MAAMY,gBAAgB,IAAIR,UAAU,CAACZ,OAAO,EAAE;MACjD,MAAME,WAAW,GAAG,CAAAC,EAAA,GAAAa,eAAe,CAAChB,OAAO,CAAC4B,GAAG,CAACR,gBAAgB,CAAC,cAAAjB,EAAA,cAAAA,EAAA,GAAI,KAAK;MAC1E,MAAM0B,cAAc,GAAGX,WAAW,CAAClB,OAAO,KAAKoB,gBAAgB,IAAI,CAAC,EAACX,mBAAmB,aAAnBA,mBAAmB,uBAAnBA,mBAAmB,CAAGW,gBAAgB,CAAC;MAC5G,IAAIS,cAAc,KAAK3B,WAAW,EAAE;QAClCc,eAAe,CAAChB,OAAO,CAAC2B,GAAG,CAACP,gBAAgB,EAAES,cAAc,CAAC;QAC7Df,aAAa,CAACd,OAAO,CAAC4B,GAAG,CAACR,gBAAgB,CAAE,CAACS,cAAc,CAAC;;;EAGlE;EAEA,SAASI,cAAcA,CAAA;IACrB,OAAOf,WAAW,CAAClB,OAAO;EAC5B;EAEA,SAASkC,YAAYA,CAACC,OAAgB;IACpC,OAAOvB,UAAU,CAACZ,OAAO,CAACoC,GAAG,CAACD,OAAO,CAAC;EACxC;EAEApD,mBAAmB,CAACuB,GAAG,EAAE,OAAO;IAAE0B,iBAAiB;IAAEC,cAAc;IAAEC;EAAY,CAAE,CAAC,CAAC;EAErF,OACEvD,KAAA,CAAA0D,aAAA,CAAC9C,8BAA8B,CAAC+C,QAAQ;IAACC,KAAK,EAAE;MAAElD,gBAAgB;MAAEC;IAAiB;EAAE,GACpFiB,QAAQ,CAC+B;AAE9C,CAAC,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}