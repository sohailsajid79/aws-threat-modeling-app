{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Position } from \"../utils/position\";\nimport { LayoutEngineGrid } from \"./grid\";\nimport { checkOppositeDirections, createMove, getMoveOriginalRect, getMoveRect } from \"./utils\";\n// All directions in which overlaps can be incrementally resolved.\nconst PRIORITY_DIRECTIONS = [\"down\", \"right\", \"left\", \"up\"];\n// The class represents an intermediate layout state used to find the next set of solutions for.\n// The solution is terminal when no overlaps are left and it can become the next layout state if its\n// score is smaller than that of the alternative solutions.\nexport class MoveSolutionState {\n  constructor(grid, moves, conflicts) {\n    this.moveIndex = 0;\n    this.overlaps = new Map();\n    this.score = 0;\n    this.grid = LayoutEngineGrid.clone(grid);\n    this.moves = [...moves];\n    this.moveIndex = moves.length;\n    this.conflicts = conflicts;\n  }\n  // The solution state needs to be cloned after the move is performed in case there are overlaps left\n  // so that the next solutions won't have the shared state to corrupt.\n  // The conflicts never change and can be carried over w/o cloning.\n  static clone(_ref) {\n    let {\n      grid,\n      moves,\n      moveIndex,\n      conflicts,\n      overlaps,\n      score\n    } = _ref;\n    return {\n      grid: LayoutEngineGrid.clone(grid),\n      moves: [...moves],\n      moveIndex,\n      conflicts,\n      overlaps: new Map([...overlaps]),\n      score\n    };\n  }\n}\n/**\n * Given a solution state finds a set of all possible moves each resolving a particular overlap.\n */\nexport function findNextSolutions(state) {\n  // For every overlap and direction found a move if exists that resolves the overlap.\n  // A pair of the given state and the overlap resolution move is a new solution to try.\n  const nextMoveSolutions = [];\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    for (const moveDirection of PRIORITY_DIRECTIONS) {\n      const move = getOverlapMove(state, overlapId, overlapIssuerId, moveDirection);\n      if (move !== null) {\n        nextMoveSolutions.push([MoveSolutionState.clone(state), move]);\n      }\n    }\n  }\n  return nextMoveSolutions;\n}\n// Returns an evaluated move to resolve the given overlap in the given direction or null if such move is not possible.\nfunction getOverlapMove(state, overlapId, overlapIssuerId, moveDirection) {\n  var _a;\n  const userItem = state.grid.getItem(state.moves[0].itemId);\n  const overlapItem = state.grid.getItem(overlapId);\n  const overlapIssuerItem = state.grid.getItem(overlapIssuerId);\n  const overlapMove = getMoveForDirection(overlapItem, overlapIssuerItem, moveDirection);\n  // The move position is outside the grid boundaries.\n  if (overlapMove.x < 0 || overlapMove.y < 0 || overlapMove.x + overlapMove.width > state.grid.width) {\n    return null;\n  }\n  // Subsequent item overlap moves in the opposite directions do not contribute to solution.\n  const prevOverlapMove = getLastSolutionMove(state, overlapItem.id);\n  if (prevOverlapMove && checkOppositeDirections(prevOverlapMove.direction, moveDirection)) {\n    return null;\n  }\n  const pathOverlaps = getPathOverlaps(state, overlapMove, overlapIssuerItem);\n  for (const overlap of pathOverlaps) {\n    // Not allowed to intersect with the user-controlled item.\n    if (overlap.id === userItem.id) {\n      return null;\n    }\n    // Not allowed to intersect with conflicting items.\n    if ((_a = state.conflicts) === null || _a === void 0 ? void 0 : _a.items.has(overlap.id)) {\n      return null;\n    }\n    // Intersecting with items having unresolved overlaps does not contribute to solution.\n    if (state.overlaps.has(overlap.id)) {\n      return null;\n    }\n  }\n  const lastIssuerMove = getLastSolutionMove(state, overlapIssuerItem.id);\n  if (!lastIssuerMove) {\n    throw new Error(\"Invariant violation: overlap issuer has no associated moves.\");\n  }\n  const issuerDirection = lastIssuerMove.direction;\n  const isSwap = checkIfSwap(overlapMove, lastIssuerMove);\n  const isDifferentIssuerDirection = moveDirection !== issuerDirection;\n  const isOppositeIssuerDirection = checkOppositeDirections(moveDirection, issuerDirection);\n  const userMoveBoundaries = getUserMoveBoundaries(state);\n  const moveVector = getSolutionMovesVector(state);\n  // Swap score penalizes non-swap overlap resolutions in case the direction does not match that of the issuer.\n  const swapPenalty = isSwap ? 0 : 20;\n  const differentDirectionPenalty = !isSwap && isDifferentIssuerDirection ? 10 : 0;\n  const oppositeDirectionPenalty = !isSwap && isOppositeIssuerDirection ? 500 : 0;\n  const swapScore = swapPenalty + differentDirectionPenalty + oppositeDirectionPenalty;\n  // Overlaps score penalizes moves that cause additional overlaps.\n  const overlapsScore = pathOverlaps.size * 50;\n  // Boundaries score penalize movements of items that are outside the area covered by the user move.\n  const moveOutsideUserTopPenalty = overlapItem.y + overlapItem.height - 1 < userMoveBoundaries.top ? 500 : 0;\n  const moveOutsideUserLeftPenalty = overlapItem.x + overlapItem.width - 1 < userMoveBoundaries.left ? 50 : 0;\n  const moveOutsideUserRightPenalty = overlapItem.x > userMoveBoundaries.right ? 50 : 0;\n  const boundariesScore = moveOutsideUserTopPenalty + moveOutsideUserLeftPenalty + moveOutsideUserRightPenalty;\n  // Move vector score penalize movements that are against the common move direction of other items.\n  const vectorXPenalty = overlapMove.distanceX * moveVector.x < 0 ? moveVector.x * 2 : 0;\n  const vectorYPenalty = overlapMove.distanceY * moveVector.y < 0 ? moveVector.y * 2 : 0;\n  const moveVectorScore = vectorXPenalty + vectorYPenalty;\n  // Score starts from 1 to avoid overlap moves having 0 score which breaks the solutions cache.\n  const score = 1 + swapScore + overlapsScore + moveVectorScore + boundariesScore;\n  return {\n    ...overlapMove,\n    score\n  };\n}\n// Retrieves the first possible move for the given direction to resolve the overlap.\nfunction getMoveForDirection(moveTarget, overlap, direction) {\n  switch (direction) {\n    case \"up\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: moveTarget.x,\n        y: overlap.y - moveTarget.height\n      }));\n    case \"down\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: moveTarget.x,\n        y: overlap.y + overlap.height\n      }));\n    case \"left\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: overlap.x - moveTarget.width,\n        y: moveTarget.y\n      }));\n    case \"right\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({\n        x: overlap.x + overlap.width,\n        y: moveTarget.y\n      }));\n  }\n}\n// Retrieves the last move if exists within the given solution.\nfunction getLastSolutionMove(state, itemId) {\n  let lastMove = null;\n  for (let i = state.moves.length - 1; i >= state.moveIndex; i--) {\n    if (state.moves[i].itemId === itemId) {\n      lastMove = state.moves[i];\n      break;\n    }\n  }\n  return lastMove;\n}\n// Calculates vector as the amount of cell movements to either direction.\n// All moves in one direction are summarized, the opposite moves cancel each other.\n// The vector show in which direction (left / right, up / down) the most overlaps were resolved.\nfunction getSolutionMovesVector(state) {\n  const vector = {\n    x: 0,\n    y: 0\n  };\n  for (let i = state.moveIndex; i < state.moves.length; i++) {\n    const move = state.moves[i];\n    if (move.type === \"OVERLAP\") {\n      vector.x += move.distanceX * move.height;\n      vector.y += move.distanceY * move.width;\n    }\n  }\n  return vector;\n}\n// Finds a rectangle within which the user-controlled item was moved (previous and current positions only).\n// The layout items outside the boundaries are not expected to be disturbed.\nfunction getUserMoveBoundaries(state) {\n  const firstUserMove = state.moves[0];\n  const lastUserMove = state.moves[state.moveIndex];\n  if (!firstUserMove || !lastUserMove || firstUserMove.itemId !== lastUserMove.itemId) {\n    throw new Error(\"Invariant violation: unexpected user move.\");\n  }\n  const original = getMoveOriginalRect(lastUserMove);\n  const current = getMoveRect(lastUserMove);\n  return {\n    top: Math.min(original.top, current.top),\n    right: Math.max(original.right, current.right),\n    bottom: Math.max(original.bottom, current.bottom),\n    left: Math.min(original.left, current.left)\n  };\n}\n// Finds all overlaps that the move will cause along its path not considering the original location and original overlap.\nfunction getPathOverlaps(state, move, overlapIssuerItem) {\n  const {\n    left,\n    right,\n    top,\n    bottom\n  } = getMoveOriginalRect(move);\n  const startX = move.distanceX <= 0 ? move.x : right + 1;\n  const endX = move.distanceX < 0 ? left - 1 : right + move.distanceX;\n  const startY = move.distanceY <= 0 ? move.y : bottom + 1;\n  const endY = move.distanceY < 0 ? top - 1 : bottom + move.distanceY;\n  const pathOverlaps = new Set(state.grid.getOverlaps({\n    id: move.itemId,\n    x: startX,\n    width: 1 + endX - startX,\n    y: startY,\n    height: 1 + endY - startY\n  }));\n  pathOverlaps.delete(overlapIssuerItem);\n  return pathOverlaps;\n}\n// Checks if the overlap move is a swap with the user-moved item.\nfunction checkIfSwap(overlapMove, lastIssuerMove) {\n  if (lastIssuerMove.type !== \"MOVE\") {\n    return false;\n  }\n  if (!checkOppositeDirections(overlapMove.direction, lastIssuerMove.direction)) {\n    return false;\n  }\n  const overlapRect = getMoveOriginalRect(overlapMove);\n  const issuerRect = getMoveRect(lastIssuerMove);\n  switch (lastIssuerMove.direction) {\n    case \"up\":\n      return overlapRect.top === issuerRect.top;\n    case \"right\":\n      return overlapRect.right === issuerRect.right;\n    case \"down\":\n      return overlapRect.bottom === issuerRect.bottom;\n    case \"left\":\n      return overlapRect.left === issuerRect.left;\n  }\n}","map":{"version":3,"names":["Position","LayoutEngineGrid","checkOppositeDirections","createMove","getMoveOriginalRect","getMoveRect","PRIORITY_DIRECTIONS","MoveSolutionState","constructor","grid","moves","conflicts","moveIndex","overlaps","Map","score","clone","length","_ref","findNextSolutions","state","nextMoveSolutions","overlapId","overlapIssuerId","moveDirection","move","getOverlapMove","push","userItem","getItem","itemId","overlapItem","overlapIssuerItem","overlapMove","getMoveForDirection","x","y","width","prevOverlapMove","getLastSolutionMove","id","direction","pathOverlaps","getPathOverlaps","overlap","_a","items","has","lastIssuerMove","Error","issuerDirection","isSwap","checkIfSwap","isDifferentIssuerDirection","isOppositeIssuerDirection","userMoveBoundaries","getUserMoveBoundaries","moveVector","getSolutionMovesVector","swapPenalty","differentDirectionPenalty","oppositeDirectionPenalty","swapScore","overlapsScore","size","moveOutsideUserTopPenalty","height","top","moveOutsideUserLeftPenalty","left","moveOutsideUserRightPenalty","right","boundariesScore","vectorXPenalty","distanceX","vectorYPenalty","distanceY","moveVectorScore","moveTarget","lastMove","i","vector","type","firstUserMove","lastUserMove","original","current","Math","min","max","bottom","startX","endX","startY","endY","Set","getOverlaps","delete","overlapRect","issuerRect"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/layout-engine/engine-solution.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Direction, GridLayoutItem, ItemId } from \"../interfaces\";\nimport { Position } from \"../utils/position\";\nimport { Conflicts } from \"./engine-state\";\nimport { LayoutEngineGrid, ReadonlyLayoutEngineGrid } from \"./grid\";\nimport { CommittedMove } from \"./interfaces\";\nimport { checkOppositeDirections, createMove, getMoveOriginalRect, getMoveRect } from \"./utils\";\n\n// All directions in which overlaps can be incrementally resolved.\nconst PRIORITY_DIRECTIONS: readonly Direction[] = [\"down\", \"right\", \"left\", \"up\"];\n\n// A valid but not yet attempted solution is a pair of the layout state so far and the next move to attempt.\n// The minimal solution score (in case the next move will resolve all overlaps) is state.score + nextMove.score.\nexport type MoveSolution = [state: MoveSolutionState, nextMove: CommittedMove];\n\n// The class represents an intermediate layout state used to find the next set of solutions for.\n// The solution is terminal when no overlaps are left and it can become the next layout state if its\n// score is smaller than that of the alternative solutions.\nexport class MoveSolutionState {\n  public grid: LayoutEngineGrid;\n  public moves: CommittedMove[];\n  public moveIndex = 0;\n  public conflicts: null | Conflicts;\n  public overlaps = new Map<ItemId, ItemId>();\n  public score = 0;\n\n  constructor(grid: ReadonlyLayoutEngineGrid, moves: readonly CommittedMove[], conflicts: null | Conflicts) {\n    this.grid = LayoutEngineGrid.clone(grid);\n    this.moves = [...moves];\n    this.moveIndex = moves.length;\n    this.conflicts = conflicts;\n  }\n\n  // The solution state needs to be cloned after the move is performed in case there are overlaps left\n  // so that the next solutions won't have the shared state to corrupt.\n  // The conflicts never change and can be carried over w/o cloning.\n  static clone({ grid, moves, moveIndex, conflicts, overlaps, score }: MoveSolutionState) {\n    return {\n      grid: LayoutEngineGrid.clone(grid),\n      moves: [...moves],\n      moveIndex,\n      conflicts,\n      overlaps: new Map([...overlaps]),\n      score,\n    };\n  }\n}\n\n/**\n * Given a solution state finds a set of all possible moves each resolving a particular overlap.\n */\nexport function findNextSolutions(state: MoveSolutionState): MoveSolution[] {\n  // For every overlap and direction found a move if exists that resolves the overlap.\n  // A pair of the given state and the overlap resolution move is a new solution to try.\n  const nextMoveSolutions: MoveSolution[] = [];\n  for (const [overlapId, overlapIssuerId] of state.overlaps) {\n    for (const moveDirection of PRIORITY_DIRECTIONS) {\n      const move = getOverlapMove(state, overlapId, overlapIssuerId, moveDirection);\n      if (move !== null) {\n        nextMoveSolutions.push([MoveSolutionState.clone(state), move]);\n      }\n    }\n  }\n  return nextMoveSolutions;\n}\n\n// Returns an evaluated move to resolve the given overlap in the given direction or null if such move is not possible.\nfunction getOverlapMove(\n  state: MoveSolutionState,\n  overlapId: ItemId,\n  overlapIssuerId: ItemId,\n  moveDirection: Direction,\n): null | CommittedMove {\n  const userItem = state.grid.getItem(state.moves[0].itemId);\n  const overlapItem = state.grid.getItem(overlapId);\n  const overlapIssuerItem = state.grid.getItem(overlapIssuerId);\n  const overlapMove = getMoveForDirection(overlapItem, overlapIssuerItem, moveDirection);\n\n  // The move position is outside the grid boundaries.\n  if (overlapMove.x < 0 || overlapMove.y < 0 || overlapMove.x + overlapMove.width > state.grid.width) {\n    return null;\n  }\n\n  // Subsequent item overlap moves in the opposite directions do not contribute to solution.\n  const prevOverlapMove = getLastSolutionMove(state, overlapItem.id);\n  if (prevOverlapMove && checkOppositeDirections(prevOverlapMove.direction, moveDirection)) {\n    return null;\n  }\n\n  const pathOverlaps = getPathOverlaps(state, overlapMove, overlapIssuerItem);\n  for (const overlap of pathOverlaps) {\n    // Not allowed to intersect with the user-controlled item.\n    if (overlap.id === userItem.id) {\n      return null;\n    }\n    // Not allowed to intersect with conflicting items.\n    if (state.conflicts?.items.has(overlap.id)) {\n      return null;\n    }\n    // Intersecting with items having unresolved overlaps does not contribute to solution.\n    if (state.overlaps.has(overlap.id)) {\n      return null;\n    }\n  }\n\n  const lastIssuerMove = getLastSolutionMove(state, overlapIssuerItem.id);\n  if (!lastIssuerMove) {\n    throw new Error(\"Invariant violation: overlap issuer has no associated moves.\");\n  }\n  const issuerDirection = lastIssuerMove.direction;\n\n  const isSwap = checkIfSwap(overlapMove, lastIssuerMove);\n  const isDifferentIssuerDirection = moveDirection !== issuerDirection;\n  const isOppositeIssuerDirection = checkOppositeDirections(moveDirection, issuerDirection);\n  const userMoveBoundaries = getUserMoveBoundaries(state);\n  const moveVector = getSolutionMovesVector(state);\n\n  // Swap score penalizes non-swap overlap resolutions in case the direction does not match that of the issuer.\n  const swapPenalty = isSwap ? 0 : 20;\n  const differentDirectionPenalty = !isSwap && isDifferentIssuerDirection ? 10 : 0;\n  const oppositeDirectionPenalty = !isSwap && isOppositeIssuerDirection ? 500 : 0;\n  const swapScore = swapPenalty + differentDirectionPenalty + oppositeDirectionPenalty;\n\n  // Overlaps score penalizes moves that cause additional overlaps.\n  const overlapsScore = pathOverlaps.size * 50;\n\n  // Boundaries score penalize movements of items that are outside the area covered by the user move.\n  const moveOutsideUserTopPenalty = overlapItem.y + overlapItem.height - 1 < userMoveBoundaries.top ? 500 : 0;\n  const moveOutsideUserLeftPenalty = overlapItem.x + overlapItem.width - 1 < userMoveBoundaries.left ? 50 : 0;\n  const moveOutsideUserRightPenalty = overlapItem.x > userMoveBoundaries.right ? 50 : 0;\n  const boundariesScore = moveOutsideUserTopPenalty + moveOutsideUserLeftPenalty + moveOutsideUserRightPenalty;\n\n  // Move vector score penalize movements that are against the common move direction of other items.\n  const vectorXPenalty = overlapMove.distanceX * moveVector.x < 0 ? moveVector.x * 2 : 0;\n  const vectorYPenalty = overlapMove.distanceY * moveVector.y < 0 ? moveVector.y * 2 : 0;\n  const moveVectorScore = vectorXPenalty + vectorYPenalty;\n\n  // Score starts from 1 to avoid overlap moves having 0 score which breaks the solutions cache.\n  const score = 1 + swapScore + overlapsScore + moveVectorScore + boundariesScore;\n\n  return { ...overlapMove, score };\n}\n\n// Retrieves the first possible move for the given direction to resolve the overlap.\nfunction getMoveForDirection(moveTarget: GridLayoutItem, overlap: GridLayoutItem, direction: Direction): CommittedMove {\n  switch (direction) {\n    case \"up\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y - moveTarget.height }));\n    case \"down\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: moveTarget.x, y: overlap.y + overlap.height }));\n    case \"left\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x - moveTarget.width, y: moveTarget.y }));\n    case \"right\":\n      return createMove(\"OVERLAP\", moveTarget, new Position({ x: overlap.x + overlap.width, y: moveTarget.y }));\n  }\n}\n\n// Retrieves the last move if exists within the given solution.\nfunction getLastSolutionMove(state: MoveSolutionState, itemId: ItemId): null | CommittedMove {\n  let lastMove: null | CommittedMove = null;\n  for (let i = state.moves.length - 1; i >= state.moveIndex; i--) {\n    if (state.moves[i].itemId === itemId) {\n      lastMove = state.moves[i];\n      break;\n    }\n  }\n  return lastMove;\n}\n\n// Calculates vector as the amount of cell movements to either direction.\n// All moves in one direction are summarized, the opposite moves cancel each other.\n// The vector show in which direction (left / right, up / down) the most overlaps were resolved.\nfunction getSolutionMovesVector(state: MoveSolutionState): { x: number; y: number } {\n  const vector = { x: 0, y: 0 };\n  for (let i = state.moveIndex; i < state.moves.length; i++) {\n    const move = state.moves[i];\n    if (move.type === \"OVERLAP\") {\n      vector.x += move.distanceX * move.height;\n      vector.y += move.distanceY * move.width;\n    }\n  }\n  return vector;\n}\n\n// Finds a rectangle within which the user-controlled item was moved (previous and current positions only).\n// The layout items outside the boundaries are not expected to be disturbed.\nfunction getUserMoveBoundaries(state: MoveSolutionState): { top: number; right: number; bottom: number; left: number } {\n  const firstUserMove = state.moves[0];\n  const lastUserMove = state.moves[state.moveIndex];\n  if (!firstUserMove || !lastUserMove || firstUserMove.itemId !== lastUserMove.itemId) {\n    throw new Error(\"Invariant violation: unexpected user move.\");\n  }\n  const original = getMoveOriginalRect(lastUserMove);\n  const current = getMoveRect(lastUserMove);\n  return {\n    top: Math.min(original.top, current.top),\n    right: Math.max(original.right, current.right),\n    bottom: Math.max(original.bottom, current.bottom),\n    left: Math.min(original.left, current.left),\n  };\n}\n\n// Finds all overlaps that the move will cause along its path not considering the original location and original overlap.\nfunction getPathOverlaps(\n  state: MoveSolutionState,\n  move: CommittedMove,\n  overlapIssuerItem: GridLayoutItem,\n): Set<GridLayoutItem> {\n  const { left, right, top, bottom } = getMoveOriginalRect(move);\n  const startX = move.distanceX <= 0 ? move.x : right + 1;\n  const endX = move.distanceX < 0 ? left - 1 : right + move.distanceX;\n  const startY = move.distanceY <= 0 ? move.y : bottom + 1;\n  const endY = move.distanceY < 0 ? top - 1 : bottom + move.distanceY;\n\n  const pathOverlaps = new Set(\n    state.grid.getOverlaps({\n      id: move.itemId,\n      x: startX,\n      width: 1 + endX - startX,\n      y: startY,\n      height: 1 + endY - startY,\n    }),\n  );\n  pathOverlaps.delete(overlapIssuerItem);\n\n  return pathOverlaps;\n}\n\n// Checks if the overlap move is a swap with the user-moved item.\nfunction checkIfSwap(overlapMove: CommittedMove, lastIssuerMove: CommittedMove): boolean {\n  if (lastIssuerMove.type !== \"MOVE\") {\n    return false;\n  }\n  if (!checkOppositeDirections(overlapMove.direction, lastIssuerMove.direction)) {\n    return false;\n  }\n  const overlapRect = getMoveOriginalRect(overlapMove);\n  const issuerRect = getMoveRect(lastIssuerMove);\n  switch (lastIssuerMove.direction) {\n    case \"up\":\n      return overlapRect.top === issuerRect.top;\n    case \"right\":\n      return overlapRect.right === issuerRect.right;\n    case \"down\":\n      return overlapRect.bottom === issuerRect.bottom;\n    case \"left\":\n      return overlapRect.left === issuerRect.left;\n  }\n}\n"],"mappings":"AAAA;AACA;AAGA,SAASA,QAAQ,QAAQ,mBAAmB;AAE5C,SAASC,gBAAgB,QAAkC,QAAQ;AAEnE,SAASC,uBAAuB,EAAEC,UAAU,EAAEC,mBAAmB,EAAEC,WAAW,QAAQ,SAAS;AAE/F;AACA,MAAMC,mBAAmB,GAAyB,CAAC,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC;AAMjF;AACA;AACA;AACA,OAAM,MAAOC,iBAAiB;EAQ5BC,YAAYC,IAA8B,EAAEC,KAA+B,EAAEC,SAA2B;IALjG,KAAAC,SAAS,GAAG,CAAC;IAEb,KAAAC,QAAQ,GAAG,IAAIC,GAAG,EAAkB;IACpC,KAAAC,KAAK,GAAG,CAAC;IAGd,IAAI,CAACN,IAAI,GAAGR,gBAAgB,CAACe,KAAK,CAACP,IAAI,CAAC;IACxC,IAAI,CAACC,KAAK,GAAG,CAAC,GAAGA,KAAK,CAAC;IACvB,IAAI,CAACE,SAAS,GAAGF,KAAK,CAACO,MAAM;IAC7B,IAAI,CAACN,SAAS,GAAGA,SAAS;EAC5B;EAEA;EACA;EACA;EACA,OAAOK,KAAKA,CAAAE,IAAA,EAA0E;IAAA,IAAzE;MAAET,IAAI;MAAEC,KAAK;MAAEE,SAAS;MAAED,SAAS;MAAEE,QAAQ;MAAEE;IAAK,CAAqB,GAAAG,IAAA;IACpF,OAAO;MACLT,IAAI,EAAER,gBAAgB,CAACe,KAAK,CAACP,IAAI,CAAC;MAClCC,KAAK,EAAE,CAAC,GAAGA,KAAK,CAAC;MACjBE,SAAS;MACTD,SAAS;MACTE,QAAQ,EAAE,IAAIC,GAAG,CAAC,CAAC,GAAGD,QAAQ,CAAC,CAAC;MAChCE;KACD;EACH;;AAGF;;;AAGA,OAAM,SAAUI,iBAAiBA,CAACC,KAAwB;EACxD;EACA;EACA,MAAMC,iBAAiB,GAAmB,EAAE;EAC5C,KAAK,MAAM,CAACC,SAAS,EAAEC,eAAe,CAAC,IAAIH,KAAK,CAACP,QAAQ,EAAE;IACzD,KAAK,MAAMW,aAAa,IAAIlB,mBAAmB,EAAE;MAC/C,MAAMmB,IAAI,GAAGC,cAAc,CAACN,KAAK,EAAEE,SAAS,EAAEC,eAAe,EAAEC,aAAa,CAAC;MAC7E,IAAIC,IAAI,KAAK,IAAI,EAAE;QACjBJ,iBAAiB,CAACM,IAAI,CAAC,CAACpB,iBAAiB,CAACS,KAAK,CAACI,KAAK,CAAC,EAAEK,IAAI,CAAC,CAAC;;;;EAIpE,OAAOJ,iBAAiB;AAC1B;AAEA;AACA,SAASK,cAAcA,CACrBN,KAAwB,EACxBE,SAAiB,EACjBC,eAAuB,EACvBC,aAAwB;;EAExB,MAAMI,QAAQ,GAAGR,KAAK,CAACX,IAAI,CAACoB,OAAO,CAACT,KAAK,CAACV,KAAK,CAAC,CAAC,CAAC,CAACoB,MAAM,CAAC;EAC1D,MAAMC,WAAW,GAAGX,KAAK,CAACX,IAAI,CAACoB,OAAO,CAACP,SAAS,CAAC;EACjD,MAAMU,iBAAiB,GAAGZ,KAAK,CAACX,IAAI,CAACoB,OAAO,CAACN,eAAe,CAAC;EAC7D,MAAMU,WAAW,GAAGC,mBAAmB,CAACH,WAAW,EAAEC,iBAAiB,EAAER,aAAa,CAAC;EAEtF;EACA,IAAIS,WAAW,CAACE,CAAC,GAAG,CAAC,IAAIF,WAAW,CAACG,CAAC,GAAG,CAAC,IAAIH,WAAW,CAACE,CAAC,GAAGF,WAAW,CAACI,KAAK,GAAGjB,KAAK,CAACX,IAAI,CAAC4B,KAAK,EAAE;IAClG,OAAO,IAAI;;EAGb;EACA,MAAMC,eAAe,GAAGC,mBAAmB,CAACnB,KAAK,EAAEW,WAAW,CAACS,EAAE,CAAC;EAClE,IAAIF,eAAe,IAAIpC,uBAAuB,CAACoC,eAAe,CAACG,SAAS,EAAEjB,aAAa,CAAC,EAAE;IACxF,OAAO,IAAI;;EAGb,MAAMkB,YAAY,GAAGC,eAAe,CAACvB,KAAK,EAAEa,WAAW,EAAED,iBAAiB,CAAC;EAC3E,KAAK,MAAMY,OAAO,IAAIF,YAAY,EAAE;IAClC;IACA,IAAIE,OAAO,CAACJ,EAAE,KAAKZ,QAAQ,CAACY,EAAE,EAAE;MAC9B,OAAO,IAAI;;IAEb;IACA,IAAI,CAAAK,EAAA,GAAAzB,KAAK,CAACT,SAAS,cAAAkC,EAAA,uBAAAA,EAAA,CAAEC,KAAK,CAACC,GAAG,CAACH,OAAO,CAACJ,EAAE,CAAC,EAAE;MAC1C,OAAO,IAAI;;IAEb;IACA,IAAIpB,KAAK,CAACP,QAAQ,CAACkC,GAAG,CAACH,OAAO,CAACJ,EAAE,CAAC,EAAE;MAClC,OAAO,IAAI;;;EAIf,MAAMQ,cAAc,GAAGT,mBAAmB,CAACnB,KAAK,EAAEY,iBAAiB,CAACQ,EAAE,CAAC;EACvE,IAAI,CAACQ,cAAc,EAAE;IACnB,MAAM,IAAIC,KAAK,CAAC,8DAA8D,CAAC;;EAEjF,MAAMC,eAAe,GAAGF,cAAc,CAACP,SAAS;EAEhD,MAAMU,MAAM,GAAGC,WAAW,CAACnB,WAAW,EAAEe,cAAc,CAAC;EACvD,MAAMK,0BAA0B,GAAG7B,aAAa,KAAK0B,eAAe;EACpE,MAAMI,yBAAyB,GAAGpD,uBAAuB,CAACsB,aAAa,EAAE0B,eAAe,CAAC;EACzF,MAAMK,kBAAkB,GAAGC,qBAAqB,CAACpC,KAAK,CAAC;EACvD,MAAMqC,UAAU,GAAGC,sBAAsB,CAACtC,KAAK,CAAC;EAEhD;EACA,MAAMuC,WAAW,GAAGR,MAAM,GAAG,CAAC,GAAG,EAAE;EACnC,MAAMS,yBAAyB,GAAG,CAACT,MAAM,IAAIE,0BAA0B,GAAG,EAAE,GAAG,CAAC;EAChF,MAAMQ,wBAAwB,GAAG,CAACV,MAAM,IAAIG,yBAAyB,GAAG,GAAG,GAAG,CAAC;EAC/E,MAAMQ,SAAS,GAAGH,WAAW,GAAGC,yBAAyB,GAAGC,wBAAwB;EAEpF;EACA,MAAME,aAAa,GAAGrB,YAAY,CAACsB,IAAI,GAAG,EAAE;EAE5C;EACA,MAAMC,yBAAyB,GAAGlC,WAAW,CAACK,CAAC,GAAGL,WAAW,CAACmC,MAAM,GAAG,CAAC,GAAGX,kBAAkB,CAACY,GAAG,GAAG,GAAG,GAAG,CAAC;EAC3G,MAAMC,0BAA0B,GAAGrC,WAAW,CAACI,CAAC,GAAGJ,WAAW,CAACM,KAAK,GAAG,CAAC,GAAGkB,kBAAkB,CAACc,IAAI,GAAG,EAAE,GAAG,CAAC;EAC3G,MAAMC,2BAA2B,GAAGvC,WAAW,CAACI,CAAC,GAAGoB,kBAAkB,CAACgB,KAAK,GAAG,EAAE,GAAG,CAAC;EACrF,MAAMC,eAAe,GAAGP,yBAAyB,GAAGG,0BAA0B,GAAGE,2BAA2B;EAE5G;EACA,MAAMG,cAAc,GAAGxC,WAAW,CAACyC,SAAS,GAAGjB,UAAU,CAACtB,CAAC,GAAG,CAAC,GAAGsB,UAAU,CAACtB,CAAC,GAAG,CAAC,GAAG,CAAC;EACtF,MAAMwC,cAAc,GAAG1C,WAAW,CAAC2C,SAAS,GAAGnB,UAAU,CAACrB,CAAC,GAAG,CAAC,GAAGqB,UAAU,CAACrB,CAAC,GAAG,CAAC,GAAG,CAAC;EACtF,MAAMyC,eAAe,GAAGJ,cAAc,GAAGE,cAAc;EAEvD;EACA,MAAM5D,KAAK,GAAG,CAAC,GAAG+C,SAAS,GAAGC,aAAa,GAAGc,eAAe,GAAGL,eAAe;EAE/E,OAAO;IAAE,GAAGvC,WAAW;IAAElB;EAAK,CAAE;AAClC;AAEA;AACA,SAASmB,mBAAmBA,CAAC4C,UAA0B,EAAElC,OAAuB,EAAEH,SAAoB;EACpG,QAAQA,SAAS;IACf,KAAK,IAAI;MACP,OAAOtC,UAAU,CAAC,SAAS,EAAE2E,UAAU,EAAE,IAAI9E,QAAQ,CAAC;QAAEmC,CAAC,EAAE2C,UAAU,CAAC3C,CAAC;QAAEC,CAAC,EAAEQ,OAAO,CAACR,CAAC,GAAG0C,UAAU,CAACZ;MAAM,CAAE,CAAC,CAAC;IAC/G,KAAK,MAAM;MACT,OAAO/D,UAAU,CAAC,SAAS,EAAE2E,UAAU,EAAE,IAAI9E,QAAQ,CAAC;QAAEmC,CAAC,EAAE2C,UAAU,CAAC3C,CAAC;QAAEC,CAAC,EAAEQ,OAAO,CAACR,CAAC,GAAGQ,OAAO,CAACsB;MAAM,CAAE,CAAC,CAAC;IAC5G,KAAK,MAAM;MACT,OAAO/D,UAAU,CAAC,SAAS,EAAE2E,UAAU,EAAE,IAAI9E,QAAQ,CAAC;QAAEmC,CAAC,EAAES,OAAO,CAACT,CAAC,GAAG2C,UAAU,CAACzC,KAAK;QAAED,CAAC,EAAE0C,UAAU,CAAC1C;MAAC,CAAE,CAAC,CAAC;IAC9G,KAAK,OAAO;MACV,OAAOjC,UAAU,CAAC,SAAS,EAAE2E,UAAU,EAAE,IAAI9E,QAAQ,CAAC;QAAEmC,CAAC,EAAES,OAAO,CAACT,CAAC,GAAGS,OAAO,CAACP,KAAK;QAAED,CAAC,EAAE0C,UAAU,CAAC1C;MAAC,CAAE,CAAC,CAAC;;AAE/G;AAEA;AACA,SAASG,mBAAmBA,CAACnB,KAAwB,EAAEU,MAAc;EACnE,IAAIiD,QAAQ,GAAyB,IAAI;EACzC,KAAK,IAAIC,CAAC,GAAG5D,KAAK,CAACV,KAAK,CAACO,MAAM,GAAG,CAAC,EAAE+D,CAAC,IAAI5D,KAAK,CAACR,SAAS,EAAEoE,CAAC,EAAE,EAAE;IAC9D,IAAI5D,KAAK,CAACV,KAAK,CAACsE,CAAC,CAAC,CAAClD,MAAM,KAAKA,MAAM,EAAE;MACpCiD,QAAQ,GAAG3D,KAAK,CAACV,KAAK,CAACsE,CAAC,CAAC;MACzB;;;EAGJ,OAAOD,QAAQ;AACjB;AAEA;AACA;AACA;AACA,SAASrB,sBAAsBA,CAACtC,KAAwB;EACtD,MAAM6D,MAAM,GAAG;IAAE9C,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAC,CAAE;EAC7B,KAAK,IAAI4C,CAAC,GAAG5D,KAAK,CAACR,SAAS,EAAEoE,CAAC,GAAG5D,KAAK,CAACV,KAAK,CAACO,MAAM,EAAE+D,CAAC,EAAE,EAAE;IACzD,MAAMvD,IAAI,GAAGL,KAAK,CAACV,KAAK,CAACsE,CAAC,CAAC;IAC3B,IAAIvD,IAAI,CAACyD,IAAI,KAAK,SAAS,EAAE;MAC3BD,MAAM,CAAC9C,CAAC,IAAIV,IAAI,CAACiD,SAAS,GAAGjD,IAAI,CAACyC,MAAM;MACxCe,MAAM,CAAC7C,CAAC,IAAIX,IAAI,CAACmD,SAAS,GAAGnD,IAAI,CAACY,KAAK;;;EAG3C,OAAO4C,MAAM;AACf;AAEA;AACA;AACA,SAASzB,qBAAqBA,CAACpC,KAAwB;EACrD,MAAM+D,aAAa,GAAG/D,KAAK,CAACV,KAAK,CAAC,CAAC,CAAC;EACpC,MAAM0E,YAAY,GAAGhE,KAAK,CAACV,KAAK,CAACU,KAAK,CAACR,SAAS,CAAC;EACjD,IAAI,CAACuE,aAAa,IAAI,CAACC,YAAY,IAAID,aAAa,CAACrD,MAAM,KAAKsD,YAAY,CAACtD,MAAM,EAAE;IACnF,MAAM,IAAImB,KAAK,CAAC,4CAA4C,CAAC;;EAE/D,MAAMoC,QAAQ,GAAGjF,mBAAmB,CAACgF,YAAY,CAAC;EAClD,MAAME,OAAO,GAAGjF,WAAW,CAAC+E,YAAY,CAAC;EACzC,OAAO;IACLjB,GAAG,EAAEoB,IAAI,CAACC,GAAG,CAACH,QAAQ,CAAClB,GAAG,EAAEmB,OAAO,CAACnB,GAAG,CAAC;IACxCI,KAAK,EAAEgB,IAAI,CAACE,GAAG,CAACJ,QAAQ,CAACd,KAAK,EAAEe,OAAO,CAACf,KAAK,CAAC;IAC9CmB,MAAM,EAAEH,IAAI,CAACE,GAAG,CAACJ,QAAQ,CAACK,MAAM,EAAEJ,OAAO,CAACI,MAAM,CAAC;IACjDrB,IAAI,EAAEkB,IAAI,CAACC,GAAG,CAACH,QAAQ,CAAChB,IAAI,EAAEiB,OAAO,CAACjB,IAAI;GAC3C;AACH;AAEA;AACA,SAAS1B,eAAeA,CACtBvB,KAAwB,EACxBK,IAAmB,EACnBO,iBAAiC;EAEjC,MAAM;IAAEqC,IAAI;IAAEE,KAAK;IAAEJ,GAAG;IAAEuB;EAAM,CAAE,GAAGtF,mBAAmB,CAACqB,IAAI,CAAC;EAC9D,MAAMkE,MAAM,GAAGlE,IAAI,CAACiD,SAAS,IAAI,CAAC,GAAGjD,IAAI,CAACU,CAAC,GAAGoC,KAAK,GAAG,CAAC;EACvD,MAAMqB,IAAI,GAAGnE,IAAI,CAACiD,SAAS,GAAG,CAAC,GAAGL,IAAI,GAAG,CAAC,GAAGE,KAAK,GAAG9C,IAAI,CAACiD,SAAS;EACnE,MAAMmB,MAAM,GAAGpE,IAAI,CAACmD,SAAS,IAAI,CAAC,GAAGnD,IAAI,CAACW,CAAC,GAAGsD,MAAM,GAAG,CAAC;EACxD,MAAMI,IAAI,GAAGrE,IAAI,CAACmD,SAAS,GAAG,CAAC,GAAGT,GAAG,GAAG,CAAC,GAAGuB,MAAM,GAAGjE,IAAI,CAACmD,SAAS;EAEnE,MAAMlC,YAAY,GAAG,IAAIqD,GAAG,CAC1B3E,KAAK,CAACX,IAAI,CAACuF,WAAW,CAAC;IACrBxD,EAAE,EAAEf,IAAI,CAACK,MAAM;IACfK,CAAC,EAAEwD,MAAM;IACTtD,KAAK,EAAE,CAAC,GAAGuD,IAAI,GAAGD,MAAM;IACxBvD,CAAC,EAAEyD,MAAM;IACT3B,MAAM,EAAE,CAAC,GAAG4B,IAAI,GAAGD;GACpB,CAAC,CACH;EACDnD,YAAY,CAACuD,MAAM,CAACjE,iBAAiB,CAAC;EAEtC,OAAOU,YAAY;AACrB;AAEA;AACA,SAASU,WAAWA,CAACnB,WAA0B,EAAEe,cAA6B;EAC5E,IAAIA,cAAc,CAACkC,IAAI,KAAK,MAAM,EAAE;IAClC,OAAO,KAAK;;EAEd,IAAI,CAAChF,uBAAuB,CAAC+B,WAAW,CAACQ,SAAS,EAAEO,cAAc,CAACP,SAAS,CAAC,EAAE;IAC7E,OAAO,KAAK;;EAEd,MAAMyD,WAAW,GAAG9F,mBAAmB,CAAC6B,WAAW,CAAC;EACpD,MAAMkE,UAAU,GAAG9F,WAAW,CAAC2C,cAAc,CAAC;EAC9C,QAAQA,cAAc,CAACP,SAAS;IAC9B,KAAK,IAAI;MACP,OAAOyD,WAAW,CAAC/B,GAAG,KAAKgC,UAAU,CAAChC,GAAG;IAC3C,KAAK,OAAO;MACV,OAAO+B,WAAW,CAAC3B,KAAK,KAAK4B,UAAU,CAAC5B,KAAK;IAC/C,KAAK,MAAM;MACT,OAAO2B,WAAW,CAACR,MAAM,KAAKS,UAAU,CAACT,MAAM;IACjD,KAAK,MAAM;MACT,OAAOQ,WAAW,CAAC7B,IAAI,KAAK8B,UAAU,CAAC9B,IAAI;;AAEjD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}