{"ast":null,"code":"/**\n * Name: react-virtual\n * Version: 2.10.4\n * License: MIT\n * Private: false\n * Description: Hooks for virtualizing scrollable elements in React\n * Repository: undefined\n * Homepage: https://github.com/tannerlinsley/react-virtual#readme\n * Author: tannerlinsley\n * License Copyright:\n * ===\n *\n * MIT License\n *\n * Copyright (c) 2019 Tanner Linsley\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport React from 'react';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n  if (b === void 0) {\n    b = {};\n  }\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nfunction useRect(nodeRef, initialRect) {\n  if (initialRect === void 0) {\n    initialRect = {\n      width: 0,\n      height: 0\n    };\n  }\n  var _React$useState = React.useState(nodeRef.current),\n    element = _React$useState[0],\n    setElement = _React$useState[1];\n  var _React$useReducer = React.useReducer(rectReducer, initialRect),\n    rect = _React$useReducer[0],\n    dispatch = _React$useReducer[1];\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n      var _rect = element.getBoundingClientRect();\n      dispatch({\n        rect: _rect\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    if (!element) {\n      return;\n    }\n    var observer = observeRect(element, function (rect) {\n      dispatch({\n        rect: rect\n      });\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\nfunction rectReducer(state, action) {\n  var rect = action.rect;\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect;\n  }\n  return state;\n}\nvar defaultEstimateSize = function defaultEstimateSize() {\n  return 50;\n};\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\nvar defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n  var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n  return el[key];\n};\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.start - range.overscan, 0);\n  var end = Math.min(range.end + range.overscan, range.size - 1);\n  var arr = [];\n  for (var i = start; i <= end; i++) {\n    arr.push(i);\n  }\n  return arr;\n};\nfunction useVirtual(_ref) {\n  var _measurements;\n  var _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 0 : _ref$size,\n    _ref$estimateSize = _ref.estimateSize,\n    estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n    _ref$overscan = _ref.overscan,\n    overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,\n    _ref$paddingStart = _ref.paddingStart,\n    paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n    _ref$paddingEnd = _ref.paddingEnd,\n    paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n    parentRef = _ref.parentRef,\n    horizontal = _ref.horizontal,\n    scrollToFn = _ref.scrollToFn,\n    useObserver = _ref.useObserver,\n    initialRect = _ref.initialRect,\n    onScrollElement = _ref.onScrollElement,\n    scrollOffsetFn = _ref.scrollOffsetFn,\n    _ref$keyExtractor = _ref.keyExtractor,\n    keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,\n    _ref$measureSize = _ref.measureSize,\n    measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,\n    _ref$rangeExtractor = _ref.rangeExtractor,\n    rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;\n  var sizeKey = horizontal ? 'width' : 'height';\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n  var latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: []\n  });\n  var _React$useState = React.useState(0),\n    scrollOffset = _React$useState[0],\n    setScrollOffset = _React$useState[1];\n  latestRef.current.scrollOffset = scrollOffset;\n  var useMeasureParent = useObserver || useRect;\n  var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n    outerSize = _useMeasureParent[sizeKey];\n  latestRef.current.outerSize = outerSize;\n  var defaultScrollToFn = React.useCallback(function (offset) {\n    if (parentRef.current) {\n      parentRef.current[scrollKey] = offset;\n    }\n  }, [parentRef, scrollKey]);\n  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n  scrollToFn = React.useCallback(function (offset) {\n    resolvedScrollToFn(offset, defaultScrollToFn);\n  }, [defaultScrollToFn, resolvedScrollToFn]);\n  var _React$useState2 = React.useState({}),\n    measuredCache = _React$useState2[0],\n    setMeasuredCache = _React$useState2[1];\n  var measure = React.useCallback(function () {\n    return setMeasuredCache({});\n  }, []);\n  var pendingMeasuredCacheIndexesRef = React.useRef([]);\n  var measurements = React.useMemo(function () {\n    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n    pendingMeasuredCacheIndexesRef.current = [];\n    var measurements = latestRef.current.measurements.slice(0, min);\n    for (var i = min; i < size; i++) {\n      var key = keyExtractor(i);\n      var measuredSize = measuredCache[key];\n      var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n      var _end = _start + _size;\n      measurements[i] = {\n        index: i,\n        start: _start,\n        size: _size,\n        end: _end,\n        key: key\n      };\n    }\n    return measurements;\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;\n  latestRef.current.measurements = measurements;\n  latestRef.current.totalSize = totalSize;\n  var element = onScrollElement ? onScrollElement.current : parentRef.current;\n  var scrollOffsetFnRef = React.useRef(scrollOffsetFn);\n  scrollOffsetFnRef.current = scrollOffsetFn;\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      setScrollOffset(0);\n      return;\n    }\n    var onScroll = function onScroll(event) {\n      var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];\n      setScrollOffset(offset);\n    };\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey]);\n  var _calculateRange = calculateRange(latestRef.current),\n    start = _calculateRange.start,\n    end = _calculateRange.end;\n  var indexes = React.useMemo(function () {\n    return rangeExtractor({\n      start: start,\n      end: end,\n      overscan: overscan,\n      size: measurements.length\n    });\n  }, [start, end, overscan, measurements.length, rangeExtractor]);\n  var measureSizeRef = React.useRef(measureSize);\n  measureSizeRef.current = measureSize;\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n    var _loop = function _loop(k, len) {\n      var i = indexes[k];\n      var measurement = measurements[i];\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          if (el) {\n            var measuredSize = measureSizeRef.current(el, horizontal);\n            if (measuredSize !== item.size) {\n              var _scrollOffset = latestRef.current.scrollOffset;\n              if (item.start < _scrollOffset) {\n                defaultScrollToFn(_scrollOffset + (measuredSize - item.size));\n              }\n              pendingMeasuredCacheIndexesRef.current.push(i);\n              setMeasuredCache(function (old) {\n                var _extends2;\n                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n              });\n            }\n          }\n        }\n      });\n      virtualItems.push(item);\n    };\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      _loop(k);\n    }\n    return virtualItems;\n  }, [indexes, defaultScrollToFn, horizontal, measurements]);\n  var mountedRef = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      setMeasuredCache({});\n    }\n    mountedRef.current = true;\n  }, [estimateSize]);\n  var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n      _ref2$align = _ref2.align,\n      align = _ref2$align === void 0 ? 'start' : _ref2$align;\n    var _latestRef$current = latestRef.current,\n      scrollOffset = _latestRef$current.scrollOffset,\n      outerSize = _latestRef$current.outerSize;\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start';\n      } else if (toOffset >= scrollOffset + outerSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n    if (align === 'start') {\n      scrollToFn(toOffset);\n    } else if (align === 'end') {\n      scrollToFn(toOffset - outerSize);\n    } else if (align === 'center') {\n      scrollToFn(toOffset - outerSize / 2);\n    }\n  }, [scrollToFn]);\n  var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n      _ref3$align = _ref3.align,\n      align = _ref3$align === void 0 ? 'auto' : _ref3$align,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"align\"]);\n    var _latestRef$current2 = latestRef.current,\n      measurements = _latestRef$current2.measurements,\n      scrollOffset = _latestRef$current2.scrollOffset,\n      outerSize = _latestRef$current2.outerSize;\n    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n    if (!measurement) {\n      return;\n    }\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffset + outerSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(toOffset, _extends({\n      align: align\n    }, rest));\n  }, [scrollToOffset, size]);\n  var scrollToIndex = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // We do a double request here because of\n    // dynamic sizes which can cause offset shift\n    // and end up in the wrong spot. Unfortunately,\n    // we can't know about those dynamic sizes until\n    // we try and render them. So double down!\n    tryScrollToIndex.apply(void 0, args);\n    requestAnimationFrame(function () {\n      tryScrollToIndex.apply(void 0, args);\n    });\n  }, [tryScrollToIndex]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex,\n    measure: measure\n  };\n}\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\nfunction calculateRange(_ref4) {\n  var measurements = _ref4.measurements,\n    outerSize = _ref4.outerSize,\n    scrollOffset = _ref4.scrollOffset;\n  var size = measurements.length - 1;\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n  var end = start;\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++;\n  }\n  return {\n    start: start,\n    end: end\n  };\n}\nexport { useVirtual };","map":{"version":3,"names":["React","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","props","rectChanged","a","b","some","prop","observedNodes","Map","rafId","run","changedStates","forEach","state","node","newRect","getBoundingClientRect","rect","push","callbacks","cb","window","requestAnimationFrame","observeRect","observe","wasEmpty","size","has","get","set","undefined","hasRectChanged","unobserve","index","splice","cancelAnimationFrame","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useRect","nodeRef","initialRect","width","height","_React$useState","useState","current","element","setElement","_React$useReducer","useReducer","rectReducer","dispatch","initialRectSet","useRef","_rect","observer","action","defaultEstimateSize","defaultKeyExtractor","defaultMeasureSize","el","horizontal","defaultRangeExtractor","range","start","Math","max","overscan","end","min","arr","useVirtual","_ref","_measurements","_ref$size","_ref$estimateSize","estimateSize","_ref$overscan","_ref$paddingStart","paddingStart","_ref$paddingEnd","paddingEnd","parentRef","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","_ref$keyExtractor","keyExtractor","_ref$measureSize","measureSize","_ref$rangeExtractor","rangeExtractor","sizeKey","scrollKey","latestRef","scrollOffset","measurements","setScrollOffset","useMeasureParent","_useMeasureParent","outerSize","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","_React$useState2","measuredCache","setMeasuredCache","measure","pendingMeasuredCacheIndexesRef","useMemo","slice","measuredSize","_start","_size","_end","totalSize","scrollOffsetFnRef","onScroll","event","addEventListener","capture","passive","removeEventListener","_calculateRange","calculateRange","indexes","measureSizeRef","virtualItems","_loop","k","len","measurement","item","measureRef","_scrollOffset","old","_extends2","mountedRef","scrollToOffset","toOffset","_temp","_ref2","_ref2$align","align","_latestRef$current","tryScrollToIndex","_temp2","_ref3","_ref3$align","rest","_latestRef$current2","scrollToIndex","_len","args","Array","_key","findNearestBinarySearch","low","high","getCurrentValue","value","middle","currentValue","_ref4","getOffset"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/@cloudscape-design/components/internal/vendor/react-virtual.js"],"sourcesContent":["/**\n * Name: react-virtual\n * Version: 2.10.4\n * License: MIT\n * Private: false\n * Description: Hooks for virtualizing scrollable elements in React\n * Repository: undefined\n * Homepage: https://github.com/tannerlinsley/react-virtual#readme\n * Author: tannerlinsley\n * License Copyright:\n * ===\n *\n * MIT License\n *\n * Copyright (c) 2019 Tanner Linsley\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nimport React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\nfunction useRect(nodeRef, initialRect) {\n  if (initialRect === void 0) {\n    initialRect = {\n      width: 0,\n      height: 0\n    };\n  }\n\n  var _React$useState = React.useState(nodeRef.current),\n      element = _React$useState[0],\n      setElement = _React$useState[1];\n\n  var _React$useReducer = React.useReducer(rectReducer, initialRect),\n      rect = _React$useReducer[0],\n      dispatch = _React$useReducer[1];\n\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n\n      var _rect = element.getBoundingClientRect();\n\n      dispatch({\n        rect: _rect\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    if (!element) {\n      return;\n    }\n\n    var observer = observeRect(element, function (rect) {\n      dispatch({\n        rect: rect\n      });\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\n\nfunction rectReducer(state, action) {\n  var rect = action.rect;\n\n  if (state.height !== rect.height || state.width !== rect.width) {\n    return rect;\n  }\n\n  return state;\n}\n\nvar defaultEstimateSize = function defaultEstimateSize() {\n  return 50;\n};\n\nvar defaultKeyExtractor = function defaultKeyExtractor(index) {\n  return index;\n};\n\nvar defaultMeasureSize = function defaultMeasureSize(el, horizontal) {\n  var key = horizontal ? 'offsetWidth' : 'offsetHeight';\n  return el[key];\n};\n\nvar defaultRangeExtractor = function defaultRangeExtractor(range) {\n  var start = Math.max(range.start - range.overscan, 0);\n  var end = Math.min(range.end + range.overscan, range.size - 1);\n  var arr = [];\n\n  for (var i = start; i <= end; i++) {\n    arr.push(i);\n  }\n\n  return arr;\n};\nfunction useVirtual(_ref) {\n  var _measurements;\n\n  var _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0 : _ref$size,\n      _ref$estimateSize = _ref.estimateSize,\n      estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n      _ref$overscan = _ref.overscan,\n      overscan = _ref$overscan === void 0 ? 1 : _ref$overscan,\n      _ref$paddingStart = _ref.paddingStart,\n      paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n      _ref$paddingEnd = _ref.paddingEnd,\n      paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n      parentRef = _ref.parentRef,\n      horizontal = _ref.horizontal,\n      scrollToFn = _ref.scrollToFn,\n      useObserver = _ref.useObserver,\n      initialRect = _ref.initialRect,\n      onScrollElement = _ref.onScrollElement,\n      scrollOffsetFn = _ref.scrollOffsetFn,\n      _ref$keyExtractor = _ref.keyExtractor,\n      keyExtractor = _ref$keyExtractor === void 0 ? defaultKeyExtractor : _ref$keyExtractor,\n      _ref$measureSize = _ref.measureSize,\n      measureSize = _ref$measureSize === void 0 ? defaultMeasureSize : _ref$measureSize,\n      _ref$rangeExtractor = _ref.rangeExtractor,\n      rangeExtractor = _ref$rangeExtractor === void 0 ? defaultRangeExtractor : _ref$rangeExtractor;\n  var sizeKey = horizontal ? 'width' : 'height';\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n  var latestRef = React.useRef({\n    scrollOffset: 0,\n    measurements: []\n  });\n\n  var _React$useState = React.useState(0),\n      scrollOffset = _React$useState[0],\n      setScrollOffset = _React$useState[1];\n\n  latestRef.current.scrollOffset = scrollOffset;\n  var useMeasureParent = useObserver || useRect;\n\n  var _useMeasureParent = useMeasureParent(parentRef, initialRect),\n      outerSize = _useMeasureParent[sizeKey];\n\n  latestRef.current.outerSize = outerSize;\n  var defaultScrollToFn = React.useCallback(function (offset) {\n    if (parentRef.current) {\n      parentRef.current[scrollKey] = offset;\n    }\n  }, [parentRef, scrollKey]);\n  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n  scrollToFn = React.useCallback(function (offset) {\n    resolvedScrollToFn(offset, defaultScrollToFn);\n  }, [defaultScrollToFn, resolvedScrollToFn]);\n\n  var _React$useState2 = React.useState({}),\n      measuredCache = _React$useState2[0],\n      setMeasuredCache = _React$useState2[1];\n\n  var measure = React.useCallback(function () {\n    return setMeasuredCache({});\n  }, []);\n  var pendingMeasuredCacheIndexesRef = React.useRef([]);\n  var measurements = React.useMemo(function () {\n    var min = pendingMeasuredCacheIndexesRef.current.length > 0 ? Math.min.apply(Math, pendingMeasuredCacheIndexesRef.current) : 0;\n    pendingMeasuredCacheIndexesRef.current = [];\n    var measurements = latestRef.current.measurements.slice(0, min);\n\n    for (var i = min; i < size; i++) {\n      var key = keyExtractor(i);\n      var measuredSize = measuredCache[key];\n\n      var _start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n\n      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n\n      var _end = _start + _size;\n\n      measurements[i] = {\n        index: i,\n        start: _start,\n        size: _size,\n        end: _end,\n        key: key\n      };\n    }\n\n    return measurements;\n  }, [estimateSize, measuredCache, paddingStart, size, keyExtractor]);\n  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || paddingStart) + paddingEnd;\n  latestRef.current.measurements = measurements;\n  latestRef.current.totalSize = totalSize;\n  var element = onScrollElement ? onScrollElement.current : parentRef.current;\n  var scrollOffsetFnRef = React.useRef(scrollOffsetFn);\n  scrollOffsetFnRef.current = scrollOffsetFn;\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      setScrollOffset(0);\n      return;\n    }\n\n    var onScroll = function onScroll(event) {\n      var offset = scrollOffsetFnRef.current ? scrollOffsetFnRef.current(event) : element[scrollKey];\n      setScrollOffset(offset);\n    };\n\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey]);\n\n  var _calculateRange = calculateRange(latestRef.current),\n      start = _calculateRange.start,\n      end = _calculateRange.end;\n\n  var indexes = React.useMemo(function () {\n    return rangeExtractor({\n      start: start,\n      end: end,\n      overscan: overscan,\n      size: measurements.length\n    });\n  }, [start, end, overscan, measurements.length, rangeExtractor]);\n  var measureSizeRef = React.useRef(measureSize);\n  measureSizeRef.current = measureSize;\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n\n    var _loop = function _loop(k, len) {\n      var i = indexes[k];\n      var measurement = measurements[i];\n\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          if (el) {\n            var measuredSize = measureSizeRef.current(el, horizontal);\n\n            if (measuredSize !== item.size) {\n              var _scrollOffset = latestRef.current.scrollOffset;\n\n              if (item.start < _scrollOffset) {\n                defaultScrollToFn(_scrollOffset + (measuredSize - item.size));\n              }\n\n              pendingMeasuredCacheIndexesRef.current.push(i);\n              setMeasuredCache(function (old) {\n                var _extends2;\n\n                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[item.key] = measuredSize, _extends2));\n              });\n            }\n          }\n        }\n      });\n\n      virtualItems.push(item);\n    };\n\n    for (var k = 0, len = indexes.length; k < len; k++) {\n      _loop(k);\n    }\n\n    return virtualItems;\n  }, [indexes, defaultScrollToFn, horizontal, measurements]);\n  var mountedRef = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      setMeasuredCache({});\n    }\n\n    mountedRef.current = true;\n  }, [estimateSize]);\n  var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        _ref2$align = _ref2.align,\n        align = _ref2$align === void 0 ? 'start' : _ref2$align;\n\n    var _latestRef$current = latestRef.current,\n        scrollOffset = _latestRef$current.scrollOffset,\n        outerSize = _latestRef$current.outerSize;\n\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start';\n      } else if (toOffset >= scrollOffset + outerSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n\n    if (align === 'start') {\n      scrollToFn(toOffset);\n    } else if (align === 'end') {\n      scrollToFn(toOffset - outerSize);\n    } else if (align === 'center') {\n      scrollToFn(toOffset - outerSize / 2);\n    }\n  }, [scrollToFn]);\n  var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref3 = _temp2 === void 0 ? {} : _temp2,\n        _ref3$align = _ref3.align,\n        align = _ref3$align === void 0 ? 'auto' : _ref3$align,\n        rest = _objectWithoutPropertiesLoose(_ref3, [\"align\"]);\n\n    var _latestRef$current2 = latestRef.current,\n        measurements = _latestRef$current2.measurements,\n        scrollOffset = _latestRef$current2.scrollOffset,\n        outerSize = _latestRef$current2.outerSize;\n    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n\n    if (!measurement) {\n      return;\n    }\n\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffset + outerSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n\n    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(toOffset, _extends({\n      align: align\n    }, rest));\n  }, [scrollToOffset, size]);\n  var scrollToIndex = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // We do a double request here because of\n    // dynamic sizes which can cause offset shift\n    // and end up in the wrong spot. Unfortunately,\n    // we can't know about those dynamic sizes until\n    // we try and render them. So double down!\n    tryScrollToIndex.apply(void 0, args);\n    requestAnimationFrame(function () {\n      tryScrollToIndex.apply(void 0, args);\n    });\n  }, [tryScrollToIndex]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex,\n    measure: measure\n  };\n}\n\nvar findNearestBinarySearch = function findNearestBinarySearch(low, high, getCurrentValue, value) {\n  while (low <= high) {\n    var middle = (low + high) / 2 | 0;\n    var currentValue = getCurrentValue(middle);\n\n    if (currentValue < value) {\n      low = middle + 1;\n    } else if (currentValue > value) {\n      high = middle - 1;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nfunction calculateRange(_ref4) {\n  var measurements = _ref4.measurements,\n      outerSize = _ref4.outerSize,\n      scrollOffset = _ref4.scrollOffset;\n  var size = measurements.length - 1;\n\n  var getOffset = function getOffset(index) {\n    return measurements[index].start;\n  };\n\n  var start = findNearestBinarySearch(0, size, getOffset, scrollOffset);\n  var end = start;\n\n  while (end < size && measurements[end].end < scrollOffset + outerSize) {\n    end++;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nexport { useVirtual };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}