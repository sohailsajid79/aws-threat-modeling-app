{"ast":null,"code":"import { isXThreshold, isYThreshold } from './utils';\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries(allSeries, xScale, yScale) {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = x => (xScale.d3Scale(x) || 0) + xOffset;\n  const scaleY = y => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n  function mergeLineSeriesPointsWithXThresholds(scaledPoints, xThresholdSeries, xThresholdSeriesColor) {\n    var _a, _b;\n    const x = scaleX(xThresholdSeries.x);\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = ((_a = scaledPoints[bisectIndex].datum) === null || _a === void 0 ? void 0 : _a.y) || 0;\n      const nextY = ((_b = scaledPoints[bisectIndex + 1].datum) === null || _b === void 0 ? void 0 : _b.y) || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: {\n          x: xThresholdSeries.x,\n          y: NaN\n        },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor\n      });\n    }\n  }\n  const scaledSeriesX = allSeries.map(_ref => {\n    let {\n      series,\n      color\n    } = _ref;\n    const scaledPoints = [];\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data) {\n        scaledPoints.push({\n          x: scaleX(datum.x),\n          y: scaleY(datum.y),\n          datum,\n          series,\n          color\n        });\n      }\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({\n          x: scaleX(x),\n          y: scaleY(series.y),\n          datum: {\n            x,\n            y: series.y\n          },\n          series,\n          color\n        });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({\n          x: NaN,\n          y: scaleY(series.y),\n          series,\n          color\n        });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({\n        x: scaleX(series.x),\n        y: NaN,\n        datum: {\n          x: series.x,\n          y: NaN\n        },\n        series,\n        color\n      });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n/** Collect unique x values from all data series. */\nfunction getAllX(series) {\n  const addDataXSet = new Set();\n  for (const {\n    series: s\n  } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n  return allDataX;\n}\nfunction flatten(arrays) {\n  const merged = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}","map":{"version":3,"names":["isXThreshold","isYThreshold","makeScaledSeries","allSeries","xScale","yScale","xOffset","isCategorical","Math","max","d3Scale","bandwidth","scaleX","x","scaleY","y","allX","getAllX","mergeLineSeriesPointsWithXThresholds","scaledPoints","xThresholdSeries","xThresholdSeriesColor","bisectIndex","i","length","prevY","_a","datum","nextY","_b","averageY","push","NaN","series","color","scaledSeriesX","map","_ref","type","data","sort","s1","s2","otherSeries","flatten","addDataXSet","Set","s","d","add","allDataX","forEach","arrays","merged","array","item"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/make-scaled-series.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { isXThreshold, isYThreshold } from './utils';\n\nexport interface ScaledPoint<T> {\n  x: number;\n  y: number;\n  color: string;\n  datum?: MixedLineBarChartProps.Datum<T> | undefined;\n  series: MixedLineBarChartProps.ChartSeries<T>;\n}\n\n/** Combine all line series into an array of scaled data points with the given scales. */\nexport default function makeScaledSeries<T extends ChartDataTypes>(\n  allSeries: ReadonlyArray<InternalChartSeries<T>>,\n  xScale: ChartScale,\n  yScale: NumericChartScale\n): readonly ScaledPoint<T>[] {\n  const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n  const scaleX = (x: T) => (xScale.d3Scale(x as any) || 0) + xOffset;\n  const scaleY = (y: number) => yScale.d3Scale(y) || 0;\n  const allX = getAllX(allSeries);\n\n  function mergeLineSeriesPointsWithXThresholds(\n    scaledPoints: ScaledPoint<T>[],\n    xThresholdSeries: MixedLineBarChartProps.ThresholdSeries<T> & { x: T },\n    xThresholdSeriesColor: string\n  ) {\n    const x = scaleX(xThresholdSeries.x);\n\n    // Locate a point the x-threshold can be inserted after (if such exists).\n    let bisectIndex = -1;\n    for (let i = 0; i < scaledPoints.length - 1; i++) {\n      if (scaledPoints[i].x < x && x < scaledPoints[i + 1].x) {\n        bisectIndex = i;\n        break;\n      }\n    }\n\n    // Insert x-threshold point into the given series using extrapolated Y value.\n    // The extrapolated value is only used to render highlighted point on the chart plot.\n    if (bisectIndex !== -1) {\n      const prevY = scaledPoints[bisectIndex].datum?.y || 0;\n      const nextY = scaledPoints[bisectIndex + 1].datum?.y || 0;\n      const averageY = (prevY + nextY) / 2;\n      scaledPoints.push({\n        x: x,\n        y: scaleY(averageY),\n        datum: { x: xThresholdSeries.x, y: NaN },\n        series: scaledPoints[bisectIndex].series,\n        color: xThresholdSeriesColor,\n      });\n    }\n  }\n\n  const scaledSeriesX = allSeries.map(({ series, color }) => {\n    const scaledPoints: ScaledPoint<T>[] = [];\n\n    // Scale and add all line series data points.\n    if (series.type === 'line') {\n      for (const datum of series.data as MixedLineBarChartProps.Datum<T>[]) {\n        scaledPoints.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum, series, color });\n      }\n\n      // Sort scaled points to ensure correct x-thresholds insertion.\n      scaledPoints.sort((s1, s2) => s1.x - s2.x);\n\n      // Merge x-thresholds into series if they don't have a shared coordinate.\n      for (const otherSeries of allSeries) {\n        if (isXThreshold(otherSeries.series)) {\n          mergeLineSeriesPointsWithXThresholds(scaledPoints, otherSeries.series, otherSeries.color);\n        }\n      }\n    }\n    // Y-thresholds only have Y. To make thresholds navigable they are mapped to all defined X values.\n    else if (isYThreshold(series)) {\n      for (const x of allX) {\n        scaledPoints.push({ x: scaleX(x), y: scaleY(series.y), datum: { x, y: series.y }, series, color });\n      }\n      // Support threshold-only setup.\n      if (allX.length === 0) {\n        scaledPoints.push({ x: NaN, y: scaleY(series.y), series, color });\n      }\n    }\n    // X-thresholds only have X. The y value is taken as NaN which means there is no associated point - only vertical marker.\n    else if (isXThreshold(series)) {\n      scaledPoints.push({ x: scaleX(series.x), y: NaN, datum: { x: series.x, y: NaN }, series, color });\n    }\n    // Bar series are handled separately.\n    return scaledPoints;\n  });\n\n  // Sort scaled points by x to ensure their order matches visual order in the chart to support navigation.\n  return flatten(scaledSeriesX).sort((s1, s2) => s1.x - s2.x);\n}\n\n/** Collect unique x values from all data series. */\nfunction getAllX<T>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const addDataXSet = new Set<T>();\n  for (const { series: s } of series) {\n    switch (s.type) {\n      // Add all X values from data series.\n      case 'bar':\n      case 'line':\n        for (const d of s.data) {\n          addDataXSet.add(d.x);\n        }\n        break;\n\n      case 'threshold':\n        // X-thresholds have a single X value.\n        if (isXThreshold(s)) {\n          addDataXSet.add(s.x);\n        }\n        // Thresholds don't have X values.\n        break;\n    }\n  }\n  const allDataX: T[] = [];\n  addDataXSet.forEach(x => allDataX.push(x));\n\n  return allDataX;\n}\n\nfunction flatten<T>(arrays: T[][]): T[] {\n  const merged: T[] = [];\n  for (const array of arrays) {\n    for (const item of array) {\n      merged.push(item);\n    }\n  }\n  return merged;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}