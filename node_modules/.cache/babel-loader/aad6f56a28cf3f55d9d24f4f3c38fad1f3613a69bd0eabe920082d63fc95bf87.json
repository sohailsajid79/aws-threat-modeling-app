{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef {import('../matters.js').Info} Info\n * @typedef {import('../matters.js').Matter} Matter\n * @typedef {import('../matters.js').Options} Options\n */\n\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\nimport { matters } from '../matters.js';\n\n/**\n * Create an extension for `micromark` to enable frontmatter syntax.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable frontmatter syntax.\n */\nexport function frontmatter(options) {\n  const listOfMatters = matters(options);\n  /** @type {ConstructRecord} */\n  const flow = {};\n  let index = -1;\n  while (++index < listOfMatters.length) {\n    const matter = listOfMatters[index];\n    const code = fence(matter, 'open').charCodeAt(0);\n    const construct = createConstruct(matter);\n    const existing = flow[code];\n    if (Array.isArray(existing)) {\n      existing.push(construct);\n    } else {\n      // Never a single object, always an array.\n      flow[code] = [construct];\n    }\n  }\n  return {\n    flow\n  };\n}\n\n/**\n * @param {Matter} matter\n * @returns {Construct}\n */\nfunction createConstruct(matter) {\n  const anywhere = matter.anywhere;\n  const frontmatterType = /** @type {TokenType} */matter.type;\n  const fenceType = /** @type {TokenType} */frontmatterType + 'Fence';\n  const sequenceType = /** @type {TokenType} */fenceType + 'Sequence';\n  const valueType = /** @type {TokenType} */frontmatterType + 'Value';\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n\n  /**\n   * Fence to look for.\n   *\n   * @type {string}\n   */\n  let buffer;\n  let bufferIndex = 0;\n  return {\n    tokenize: tokenizeFrontmatter,\n    concrete: true\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFrontmatter(effects, ok, nok) {\n    const self = this;\n    return start;\n\n    /**\n     * Start of frontmatter.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      const position = self.now();\n      if (\n      // Indent not allowed.\n      position.column === 1 && (\n      // Normally, only allowed in first line.\n      position.line === 1 || anywhere)) {\n        buffer = fence(matter, 'open');\n        bufferIndex = 0;\n        if (code === buffer.charCodeAt(bufferIndex)) {\n          effects.enter(frontmatterType);\n          effects.enter(fenceType);\n          effects.enter(sequenceType);\n          return openSequence(code);\n        }\n      }\n      return nok(code);\n    }\n\n    /**\n     * In open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType);\n        if (markdownSpace(code)) {\n          effects.enter('whitespace');\n          return openSequenceWhitespace(code);\n        }\n        return openAfter(code);\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code);\n        return openSequence;\n      }\n      return nok(code);\n    }\n\n    /**\n     * In whitespace after open sequence.\n     *\n     * ```markdown\n     * > | ---␠\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return openSequenceWhitespace;\n      }\n      effects.exit('whitespace');\n      return openAfter(code);\n    }\n\n    /**\n     * After open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openAfter(code) {\n      if (markdownLineEnding(code)) {\n        effects.exit(fenceType);\n        effects.enter('lineEnding');\n        effects.consume(code);\n        effects.exit('lineEnding');\n        // Get ready for closing fence.\n        buffer = fence(matter, 'close');\n        bufferIndex = 0;\n        return effects.attempt(closingFenceConstruct, after, contentStart);\n      }\n\n      // EOF is not okay.\n      return nok(code);\n    }\n\n    /**\n     * Start of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentStart(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return contentEnd(code);\n      }\n      effects.enter(valueType);\n      return contentInside(code);\n    }\n\n    /**\n     * In content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentInside(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(valueType);\n        return contentEnd(code);\n      }\n      effects.consume(code);\n      return contentInside;\n    }\n\n    /**\n     * End of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *                   ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentEnd(code) {\n      // Require a closing fence.\n      if (code === null) {\n        return nok(code);\n      }\n\n      // Can only be an eol.\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      return effects.attempt(closingFenceConstruct, after, contentStart);\n    }\n\n    /**\n     * After frontmatter.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      // `code` must be eol/eof.\n      effects.exit(frontmatterType);\n      return ok(code);\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let bufferIndex = 0;\n    return closeStart;\n\n    /**\n     * Start of close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeStart(code) {\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.enter(fenceType);\n        effects.enter(sequenceType);\n        return closeSequence(code);\n      }\n      return nok(code);\n    }\n\n    /**\n     * In close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType);\n        if (markdownSpace(code)) {\n          effects.enter('whitespace');\n          return closeSequenceWhitespace(code);\n        }\n        return closeAfter(code);\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code);\n        return closeSequence;\n      }\n      return nok(code);\n    }\n\n    /**\n     * In whitespace after close sequence.\n     *\n     * ```markdown\n     * > | ---\n     *   | title: \"Venus\"\n     *   | ---␠\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return closeSequenceWhitespace;\n      }\n      effects.exit('whitespace');\n      return closeAfter(code);\n    }\n\n    /**\n     * After close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(fenceType);\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @param {Matter} matter\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction fence(matter, prop) {\n  return matter.marker ? pick(matter.marker, prop).repeat(3) :\n  // @ts-expect-error: They’re mutually exclusive.\n  pick(matter.fence, prop);\n}\n\n/**\n * @param {Info | string} schema\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop];\n}","map":{"version":3,"names":["markdownLineEnding","markdownSpace","matters","frontmatter","options","listOfMatters","flow","index","length","matter","code","fence","charCodeAt","construct","createConstruct","existing","Array","isArray","push","anywhere","frontmatterType","type","fenceType","sequenceType","valueType","closingFenceConstruct","tokenize","tokenizeClosingFence","partial","buffer","bufferIndex","tokenizeFrontmatter","concrete","effects","ok","nok","self","start","position","now","column","line","enter","openSequence","exit","openSequenceWhitespace","openAfter","consume","attempt","after","contentStart","contentEnd","contentInside","closeStart","closeSequence","closeSequenceWhitespace","closeAfter","prop","marker","pick","repeat","schema"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/micromark-extension-frontmatter/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef {import('../matters.js').Info} Info\n * @typedef {import('../matters.js').Matter} Matter\n * @typedef {import('../matters.js').Options} Options\n */\n\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {matters} from '../matters.js'\n\n/**\n * Create an extension for `micromark` to enable frontmatter syntax.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable frontmatter syntax.\n */\nexport function frontmatter(options) {\n  const listOfMatters = matters(options)\n  /** @type {ConstructRecord} */\n  const flow = {}\n  let index = -1\n  while (++index < listOfMatters.length) {\n    const matter = listOfMatters[index]\n    const code = fence(matter, 'open').charCodeAt(0)\n    const construct = createConstruct(matter)\n    const existing = flow[code]\n    if (Array.isArray(existing)) {\n      existing.push(construct)\n    } else {\n      // Never a single object, always an array.\n      flow[code] = [construct]\n    }\n  }\n  return {\n    flow\n  }\n}\n\n/**\n * @param {Matter} matter\n * @returns {Construct}\n */\nfunction createConstruct(matter) {\n  const anywhere = matter.anywhere\n  const frontmatterType = /** @type {TokenType} */ matter.type\n  const fenceType = /** @type {TokenType} */ frontmatterType + 'Fence'\n  const sequenceType = /** @type {TokenType} */ fenceType + 'Sequence'\n  const valueType = /** @type {TokenType} */ frontmatterType + 'Value'\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n\n  /**\n   * Fence to look for.\n   *\n   * @type {string}\n   */\n  let buffer\n  let bufferIndex = 0\n  return {\n    tokenize: tokenizeFrontmatter,\n    concrete: true\n  }\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFrontmatter(effects, ok, nok) {\n    const self = this\n    return start\n\n    /**\n     * Start of frontmatter.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      const position = self.now()\n      if (\n        // Indent not allowed.\n        position.column === 1 &&\n        // Normally, only allowed in first line.\n        (position.line === 1 || anywhere)\n      ) {\n        buffer = fence(matter, 'open')\n        bufferIndex = 0\n        if (code === buffer.charCodeAt(bufferIndex)) {\n          effects.enter(frontmatterType)\n          effects.enter(fenceType)\n          effects.enter(sequenceType)\n          return openSequence(code)\n        }\n      }\n      return nok(code)\n    }\n\n    /**\n     * In open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType)\n        if (markdownSpace(code)) {\n          effects.enter('whitespace')\n          return openSequenceWhitespace(code)\n        }\n        return openAfter(code)\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code)\n        return openSequence\n      }\n      return nok(code)\n    }\n\n    /**\n     * In whitespace after open sequence.\n     *\n     * ```markdown\n     * > | ---␠\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code)\n        return openSequenceWhitespace\n      }\n      effects.exit('whitespace')\n      return openAfter(code)\n    }\n\n    /**\n     * After open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openAfter(code) {\n      if (markdownLineEnding(code)) {\n        effects.exit(fenceType)\n        effects.enter('lineEnding')\n        effects.consume(code)\n        effects.exit('lineEnding')\n        // Get ready for closing fence.\n        buffer = fence(matter, 'close')\n        bufferIndex = 0\n        return effects.attempt(closingFenceConstruct, after, contentStart)\n      }\n\n      // EOF is not okay.\n      return nok(code)\n    }\n\n    /**\n     * Start of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentStart(code) {\n      if (code === null || markdownLineEnding(code)) {\n        return contentEnd(code)\n      }\n      effects.enter(valueType)\n      return contentInside(code)\n    }\n\n    /**\n     * In content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentInside(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(valueType)\n        return contentEnd(code)\n      }\n      effects.consume(code)\n      return contentInside\n    }\n\n    /**\n     * End of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *                   ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentEnd(code) {\n      // Require a closing fence.\n      if (code === null) {\n        return nok(code)\n      }\n\n      // Can only be an eol.\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return effects.attempt(closingFenceConstruct, after, contentStart)\n    }\n\n    /**\n     * After frontmatter.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      // `code` must be eol/eof.\n      effects.exit(frontmatterType)\n      return ok(code)\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let bufferIndex = 0\n    return closeStart\n\n    /**\n     * Start of close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeStart(code) {\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.enter(fenceType)\n        effects.enter(sequenceType)\n        return closeSequence(code)\n      }\n      return nok(code)\n    }\n\n    /**\n     * In close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType)\n        if (markdownSpace(code)) {\n          effects.enter('whitespace')\n          return closeSequenceWhitespace(code)\n        }\n        return closeAfter(code)\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code)\n        return closeSequence\n      }\n      return nok(code)\n    }\n\n    /**\n     * In whitespace after close sequence.\n     *\n     * ```markdown\n     * > | ---\n     *   | title: \"Venus\"\n     *   | ---␠\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code)\n        return closeSequenceWhitespace\n      }\n      effects.exit('whitespace')\n      return closeAfter(code)\n    }\n\n    /**\n     * After close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeAfter(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit(fenceType)\n        return ok(code)\n      }\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @param {Matter} matter\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction fence(matter, prop) {\n  return matter.marker\n    ? pick(matter.marker, prop).repeat(3)\n    : // @ts-expect-error: They’re mutually exclusive.\n      pick(matter.fence, prop)\n}\n\n/**\n * @param {Info | string} schema\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}