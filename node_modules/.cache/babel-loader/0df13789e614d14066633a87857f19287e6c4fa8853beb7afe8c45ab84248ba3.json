{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\nexport function useNavigation(_ref) {\n  let {\n    series,\n    visibleSeries,\n    scaledSeries,\n    barGroups,\n    xScale,\n    yScale,\n    highlightedPoint,\n    highlightedGroupIndex,\n    highlightedSeries,\n    isHandlersDisabled,\n    pinPopover,\n    highlightSeries,\n    highlightGroup,\n    highlightPoint,\n    highlightX,\n    verticalMarkerX,\n    isRtl,\n    horizontalBars\n  } = _ref;\n  const [targetX, setTargetX] = useState(null);\n  const [xIndex, setXIndex] = useState(0);\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(_ref2 => {\n    let {\n      series\n    } = _ref2;\n    return series.type === 'bar';\n  }), [visibleSeries]);\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const {\n    navigableSeries\n  } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;\n    setTargetX(xScale.domain[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n  const onLineFocus = () => {\n    var _a;\n    if (verticalMarkerX === null) {\n      const index = !isRtl ? 0 : allUniqueX.length - 1;\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(index);\n      } else {\n        moveBetweenSeries(0, (_a = allUniqueX[index].datum) === null || _a === void 0 ? void 0 : _a.x);\n      }\n    }\n  };\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({\n          scaledX: point.x,\n          datum: point.datum\n        });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n  const moveBetweenSeries = useCallback((direction, startFrom) => {\n    var _a, _b, _c, _d, _e;\n    if (isGroupNavigation) {\n      return;\n    }\n    const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n    const MAX_SERIES_INDEX = navigableSeries.length - 1;\n    // Find the index of the currently highlighted series (if any)\n    let previousSeriesIndex = -1;\n    if (highlightedSeries) {\n      previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n    }\n    // Move forwards or backwards to the new series\n    // If index === -1, show all data points from all series at the given X instead of one single series\n    const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n    let nextSeriesIndex = 0;\n    if (previousSeriesIndex !== null) {\n      nextSeriesIndex = previousSeriesIndex + direction;\n      if (nextSeriesIndex > MAX_SERIES_INDEX) {\n        nextSeriesIndex = firstPossibleIndex;\n      } else if (nextSeriesIndex < firstPossibleIndex) {\n        nextSeriesIndex = MAX_SERIES_INDEX;\n      }\n    }\n    if (nextSeriesIndex === -1) {\n      highlightSeries(null);\n      highlightPoint(null);\n      return;\n    }\n    const nextSeries = navigableSeries[nextSeriesIndex];\n    const nextInternalSeries = series.filter(_ref3 => {\n      let {\n        series\n      } = _ref3;\n      return series === nextSeries;\n    })[0];\n    const actualTargetX = (_a = targetX !== null && targetX !== void 0 ? targetX : startFrom) !== null && _a !== void 0 ? _a : null;\n    // 2. Find point in the next series\n    let targetXPoint = ((_b = xScale.d3Scale(actualTargetX)) !== null && _b !== void 0 ? _b : NaN) + xOffset;\n    if (!isFinite(targetXPoint)) {\n      targetXPoint = 0;\n    }\n    if (nextSeries.type === 'line') {\n      const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n      const closestNextSeriesPoint = nextScaledSeries.reduce((prev, curr) => Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev, {\n        x: -Infinity,\n        y: -Infinity\n      });\n      highlightPoint(Object.assign(Object.assign({}, closestNextSeriesPoint), {\n        color: nextInternalSeries.color,\n        series: nextSeries\n      }));\n    } else if (isYThreshold(nextSeries)) {\n      const scaledTargetIndex = scaledSeries.map(it => {\n        var _a;\n        return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null;\n      }).indexOf(actualTargetX);\n      highlightPoint({\n        x: targetXPoint,\n        y: (_c = yScale.d3Scale(nextSeries.y)) !== null && _c !== void 0 ? _c : NaN,\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: (_d = scaledSeries[scaledTargetIndex]) === null || _d === void 0 ? void 0 : _d.datum\n      });\n    } else if (isXThreshold(nextSeries)) {\n      highlightPoint({\n        x: (_e = xScale.d3Scale(nextSeries.x)) !== null && _e !== void 0 ? _e : NaN,\n        y: yScale.d3Scale.range()[0],\n        color: nextInternalSeries.color,\n        series: nextSeries,\n        datum: {\n          x: nextSeries.x,\n          y: NaN\n        }\n      });\n    }\n  }, [isGroupNavigation, xScale, navigableSeries, highlightedSeries, containsMultipleSeries, highlightSeries, highlightPoint, series, targetX, scaledSeries, yScale]);\n  const moveWithinSeries = useCallback(direction => {\n    var _a;\n    const series = highlightedSeries || visibleSeries[0].series;\n    if (series.type === 'line' || isYThreshold(series)) {\n      const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n      const previousPoint = highlightedPoint || targetScaledSeries[0];\n      const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n      const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n      const nextPoint = targetScaledSeries[nextPointIndex];\n      setTargetX(((_a = nextPoint.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n      setXIndex(nextPointIndex);\n      highlightPoint(nextPoint);\n    } else if (series.type === 'bar') {\n      const xDomain = xScale.domain;\n      const MAX_GROUP_INDEX = xDomain.length - 1;\n      let nextGroupIndex = 0;\n      if (highlightedGroupIndex !== null) {\n        if (isRtl && !horizontalBars) {\n          direction = -direction;\n        }\n        // find next group\n        nextGroupIndex = highlightedGroupIndex + direction;\n        if (nextGroupIndex > MAX_GROUP_INDEX) {\n          nextGroupIndex = 0;\n        } else if (nextGroupIndex < 0) {\n          nextGroupIndex = MAX_GROUP_INDEX;\n        }\n      }\n      const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n      setTargetX(xDomain[nextDomainIndex]);\n      highlightGroup(nextDomainIndex);\n    }\n  }, [highlightedSeries, visibleSeries, scaledSeries, highlightedPoint, highlightPoint, xScale.domain, highlightedGroupIndex, barGroups, highlightGroup, isRtl, horizontalBars]);\n  const moveToLineGroupIndex = useCallback(index => {\n    var _a, _b, _c, _d;\n    const point = allUniqueX[index];\n    setXIndex(index);\n    setTargetX(((_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) || null);\n    highlightX({\n      scaledX: (_b = point === null || point === void 0 ? void 0 : point.scaledX) !== null && _b !== void 0 ? _b : null,\n      label: (_d = (_c = point.datum) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : null\n    });\n  }, [allUniqueX, highlightX]);\n  const moveWithinXAxis = useCallback(direction => {\n    if (highlightedSeries || isGroupNavigation) {\n      moveWithinSeries(direction);\n    } else {\n      const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n      moveToLineGroupIndex(nextPointGroupIndex);\n    }\n  }, [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]);\n  const onKeyDown = useCallback(event => {\n    const keyCode = event.keyCode;\n    if (keyCode !== KeyCode.up && keyCode !== KeyCode.right && keyCode !== KeyCode.down && keyCode !== KeyCode.left && keyCode !== KeyCode.space && keyCode !== KeyCode.enter) {\n      return;\n    }\n    event.preventDefault();\n    if (isHandlersDisabled) {\n      return;\n    }\n    if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n      moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n    } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n      moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n    } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n      pinPopover();\n    }\n  }, [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]);\n  return {\n    isGroupNavigation,\n    onFocus,\n    onKeyDown,\n    xIndex\n  };\n}","map":{"version":3,"names":["useCallback","useMemo","useState","KeyCode","circleIndex","findNavigableSeries","isXThreshold","isYThreshold","nextValidDomainIndex","useNavigation","_ref","series","visibleSeries","scaledSeries","barGroups","xScale","yScale","highlightedPoint","highlightedGroupIndex","highlightedSeries","isHandlersDisabled","pinPopover","highlightSeries","highlightGroup","highlightPoint","highlightX","verticalMarkerX","isRtl","horizontalBars","targetX","setTargetX","xIndex","setXIndex","isGroupNavigation","some","_ref2","type","navigableSeries","containsMultipleSeries","length","onBarGroupFocus","groupIndex","domain","onLineFocus","index","allUniqueX","moveToLineGroupIndex","moveBetweenSeries","_a","datum","x","onFocus","result","i","point","undefined","scaledX","push","direction","startFrom","xOffset","isCategorical","Math","max","d3Scale","bandwidth","MAX_SERIES_INDEX","previousSeriesIndex","indexOf","firstPossibleIndex","nextSeriesIndex","nextSeries","nextInternalSeries","filter","_ref3","actualTargetX","targetXPoint","_b","NaN","isFinite","nextScaledSeries","it","closestNextSeriesPoint","reduce","prev","curr","abs","Infinity","y","Object","assign","color","scaledTargetIndex","map","_c","_d","_e","range","moveWithinSeries","targetScaledSeries","previousPoint","indexOfPreviousPoint","nextPointIndex","nextPoint","xDomain","MAX_GROUP_INDEX","nextGroupIndex","nextDomainIndex","label","moveWithinXAxis","nextPointGroupIndex","onKeyDown","event","keyCode","up","right","down","left","space","enter","preventDefault"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/hooks/use-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useMemo, useState } from 'react';\n\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { KeyCode } from '../../internal/keycode';\nimport { circleIndex } from '../../internal/utils/circle-index';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps, VerticalMarkerX } from '../interfaces';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { findNavigableSeries, isXThreshold, isYThreshold, nextValidDomainIndex } from '../utils';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n  clearHighlightedSeries(): void;\n  verticalMarkerX: VerticalMarkerX<T> | null;\n\n  isRtl?: boolean;\n  horizontalBars: boolean;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n  highlightX,\n  verticalMarkerX,\n  isRtl,\n  horizontalBars,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n  const [xIndex, setXIndex] = useState(0);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = useMemo(() => visibleSeries.some(({ series }) => series.type === 'bar'), [visibleSeries]);\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n  const containsMultipleSeries = navigableSeries.length > 1;\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineFocus = () => {\n    if (verticalMarkerX === null) {\n      const index = !isRtl ? 0 : allUniqueX.length - 1;\n      if (containsMultipleSeries) {\n        moveToLineGroupIndex(index);\n      } else {\n        moveBetweenSeries(0, allUniqueX[index].datum?.x);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineFocus();\n    }\n  };\n\n  // Returns all the unique X coordinates in scaledSeries.\n  // Assumes scaledSeries is sorted by `x`.\n  const allUniqueX = useMemo(() => {\n    const result = [];\n    for (let i = 0; i < scaledSeries.length; i += 1) {\n      const point = scaledSeries[i];\n      if (point !== undefined && (!result.length || result[result.length - 1].scaledX !== point.x)) {\n        result.push({ scaledX: point.x, datum: point.datum });\n      }\n    }\n    return result;\n  }, [scaledSeries]);\n\n  const moveBetweenSeries = useCallback(\n    (direction: number, startFrom?: T) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      // If index === -1, show all data points from all series at the given X instead of one single series\n      const firstPossibleIndex = containsMultipleSeries ? -1 : 0;\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== null) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = firstPossibleIndex;\n        } else if (nextSeriesIndex < firstPossibleIndex) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n      if (nextSeriesIndex === -1) {\n        highlightSeries(null);\n        highlightPoint(null);\n        return;\n      }\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      const actualTargetX = targetX ?? startFrom ?? null;\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(actualTargetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextScaledSeries = scaledSeries.filter(it => it.series === nextSeries);\n        const closestNextSeriesPoint = nextScaledSeries.reduce(\n          (prev, curr) => (Math.abs(curr.x - targetXPoint) < Math.abs(prev.x - targetXPoint) ? curr : prev),\n          { x: -Infinity, y: -Infinity }\n        );\n        highlightPoint({ ...closestNextSeriesPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (isYThreshold(nextSeries)) {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(actualTargetX);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      } else if (isXThreshold(nextSeries)) {\n        highlightPoint({\n          x: xScale.d3Scale(nextSeries.x as any) ?? NaN,\n          y: yScale.d3Scale.range()[0],\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: { x: nextSeries.x, y: NaN },\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      containsMultipleSeries,\n      highlightSeries,\n      highlightPoint,\n      series,\n      targetX,\n      scaledSeries,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n\n      if (series.type === 'line' || isYThreshold(series)) {\n        const targetScaledSeries = scaledSeries.filter(it => it.series === series);\n        const previousPoint = highlightedPoint || targetScaledSeries[0];\n        const indexOfPreviousPoint = targetScaledSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, targetScaledSeries.length - 1]);\n        const nextPoint = targetScaledSeries[nextPointIndex];\n\n        setTargetX(nextPoint.datum?.x || null);\n        setXIndex(nextPointIndex);\n        highlightPoint(nextPoint);\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          if (isRtl && !horizontalBars) {\n            direction = -direction;\n          }\n\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      scaledSeries,\n      highlightedPoint,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n      isRtl,\n      horizontalBars,\n    ]\n  );\n\n  const moveToLineGroupIndex = useCallback(\n    (index: number) => {\n      const point = allUniqueX[index];\n      setXIndex(index);\n      setTargetX(point.datum?.x || null);\n      highlightX({ scaledX: point?.scaledX ?? null, label: point.datum?.x ?? null });\n    },\n    [allUniqueX, highlightX]\n  );\n\n  const moveWithinXAxis = useCallback(\n    (direction: number) => {\n      if (highlightedSeries || isGroupNavigation) {\n        moveWithinSeries(direction);\n      } else {\n        const nextPointGroupIndex = circleIndex(xIndex + direction, [0, allUniqueX.length - 1]);\n        moveToLineGroupIndex(nextPointGroupIndex);\n      }\n    },\n    [highlightedSeries, isGroupNavigation, moveWithinSeries, xIndex, allUniqueX.length, moveToLineGroupIndex]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinXAxis(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [isHandlersDisabled, moveBetweenSeries, moveWithinXAxis, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown, xIndex };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}