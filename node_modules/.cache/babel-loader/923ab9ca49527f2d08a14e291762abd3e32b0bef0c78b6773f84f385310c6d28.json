{"ast":null,"code":"/** *******************************************************************************************************************\n  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n ******************************************************************************************************************** */\n\nimport { threatFieldTypeMapping } from '../../customTypes';\nimport threatFieldData from '../../data/threatFieldData';\nimport threatStatementFormat from '../../data/threatStatementFormat';\nimport calculateFieldCombination from '../calculateFieldCombination';\nimport getFieldContentByToken from '../getFieldContentByToken';\nimport parseThreatStatement from '../parseThreatStatement';\nconst threatStatementFormatKeys = Object.keys(threatStatementFormat);\nexport const PLACEHOLDER = '<placeholder>';\nconst renderThreatStatement = statement => {\n  var _format, _format2;\n  const {\n    fieldCombination,\n    filledField\n  } = calculateFieldCombination(statement);\n\n  // No field is filled\n  if (fieldCombination === 0) {\n    return {\n      statement: '',\n      displayedStatement: [],\n      suggestions: []\n    };\n  }\n  const suggestions = [];\n  ['prerequisites', 'threat_action', 'threat_impact'].forEach(token => {\n    const content = statement[threatFieldTypeMapping[token]];\n    if (content !== '' && typeof content === 'string' && content.split(' ').length === 1) {\n      suggestions.push(`[${token}] Looks like your ${token} is a single word, consider being more descriptive`);\n    }\n  });\n\n  // Only one field is filled\n  if (filledField.length === 1) {\n    let prefix = '...',\n      suffix = '...';\n    if (threatFieldData[filledField[0]].fieldPosition === 1) {\n      prefix = '';\n      suffix = '...';\n    } else if (threatFieldData[filledField[0]].fieldPosition === Object.keys(threatFieldData).length) {\n      prefix = '...';\n      suffix = '';\n    }\n    return {\n      statement: `${prefix}${getFieldContentByToken(filledField[0], statement)}${suffix}`,\n      suggestions\n    };\n  }\n\n  // Multiple fields are filled\n  if (!statement.threatSource) {\n    suggestions.push('[threat_source] Consider specifying who or what is the source of the threat');\n  }\n  if (!statement.prerequisites) {\n    suggestions.push('[prerequisites] Consider what conditions or requirement that must be met in order for a threat sources actions to be viable');\n    suggestions.push('[prerequisites] No prerequisites this is often a sign you can decompose into multiple threat statements that have different prerequisites');\n  }\n  if (!statement.threatAction) {\n    suggestions.push('[threat_action] Consider what actions are being performed by, or related to the threat source. Knowing this is required in order to mitigate the threat');\n  }\n  const updatedStatement = {\n    ...statement,\n    threatSource: statement.threatSource || 'threat source',\n    prerequisites: statement.prerequisites || PLACEHOLDER,\n    threatAction: statement.threatAction || 'perform a threat action'\n  };\n  const {\n    fieldCombination: updatedFieldCombination\n  } = calculateFieldCombination(updatedStatement);\n  let format = null;\n  if (threatStatementFormatKeys.includes(updatedFieldCombination.toString())) {\n    format = threatStatementFormat[updatedFieldCombination];\n  }\n  suggestions.push(...(((_format = format) === null || _format === void 0 ? void 0 : _format.suggestions) || []));\n  const outputProcessor = (token, content, before, _filled) => {\n    var _threatFieldData$toke, _threatFieldData$toke2;\n    const output = [];\n    output.push({\n      stringOutput: before,\n      displayOutput: before\n    });\n    const updatedContent = token === 'prerequisites' && content === PLACEHOLDER ? '' : content;\n    const displayedOutput = token === 'threat_action' ? {\n      type: 'b',\n      content: updatedContent,\n      tooltip: (_threatFieldData$toke = threatFieldData[token]) === null || _threatFieldData$toke === void 0 ? void 0 : _threatFieldData$toke.tooltip\n    } : {\n      type: 'span',\n      content: updatedContent,\n      tooltip: (_threatFieldData$toke2 = threatFieldData[token]) === null || _threatFieldData$toke2 === void 0 ? void 0 : _threatFieldData$toke2.tooltip\n    };\n    output.push({\n      stringOutput: updatedContent,\n      displayOutput: displayedOutput\n    });\n    return output;\n  };\n  const parseOutput = parseThreatStatement({\n    statement: updatedStatement,\n    template: statement.customTemplate || ((_format2 = format) === null || _format2 === void 0 ? void 0 : _format2.template) || '',\n    outputProcessor: outputProcessor\n  });\n  return {\n    statement: parseOutput.map(x => x.stringOutput).join(' ').replace(/\\s\\s+/g, ' ').replace(/ ,/g, ','),\n    displayedStatement: parseOutput.map(x => x.displayOutput),\n    suggestions: suggestions.sort()\n  };\n};\nexport default renderThreatStatement;","map":{"version":3,"names":["threatFieldTypeMapping","threatFieldData","threatStatementFormat","calculateFieldCombination","getFieldContentByToken","parseThreatStatement","threatStatementFormatKeys","Object","keys","PLACEHOLDER","renderThreatStatement","statement","_format","_format2","fieldCombination","filledField","displayedStatement","suggestions","forEach","token","content","split","length","push","prefix","suffix","fieldPosition","threatSource","prerequisites","threatAction","updatedStatement","updatedFieldCombination","format","includes","toString","outputProcessor","before","_filled","_threatFieldData$toke","_threatFieldData$toke2","output","stringOutput","displayOutput","updatedContent","displayedOutput","type","tooltip","parseOutput","template","customTemplate","map","x","join","replace","sort"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/src/utils/renderThreatStatement/index.ts"],"sourcesContent":["/** *******************************************************************************************************************\n  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n ******************************************************************************************************************** */\n\nimport { TemplateThreatStatement, threatFieldTypeMapping, ThreatFieldTypes, ThreatStatementDisplayToken } from '../../customTypes';\nimport threatFieldData from '../../data/threatFieldData';\nimport threatStatementFormat from '../../data/threatStatementFormat';\nimport calculateFieldCombination from '../calculateFieldCombination';\nimport getFieldContentByToken from '../getFieldContentByToken';\nimport parseThreatStatement from '../parseThreatStatement';\n\nconst threatStatementFormatKeys = Object.keys(threatStatementFormat);\n\nexport const PLACEHOLDER = '<placeholder>';\n\nconst renderThreatStatement = (statement: TemplateThreatStatement): {\n  statement: string;\n  displayedStatement?: (ThreatStatementDisplayToken | string)[];\n  suggestions: string[];\n} => {\n  const { fieldCombination, filledField } = calculateFieldCombination(statement);\n\n  // No field is filled\n  if (fieldCombination === 0) {\n    return {\n      statement: '',\n      displayedStatement: [],\n      suggestions: [],\n    };\n  }\n\n  const suggestions: string[] = [];\n\n  (['prerequisites', 'threat_action', 'threat_impact'] as ThreatFieldTypes[]).forEach((token) => {\n    const content = statement[threatFieldTypeMapping[token]];\n    if (content !== '' && typeof content === 'string' && content.split(' ').length === 1) {\n      suggestions.push(\n        `[${token}] Looks like your ${token} is a single word, consider being more descriptive`,\n      );\n    }\n  });\n\n  // Only one field is filled\n  if (filledField.length === 1) {\n    let prefix = '...', suffix = '...';\n    if (threatFieldData[filledField[0]].fieldPosition === 1) {\n      prefix = '';\n      suffix = '...';\n    } else if (threatFieldData[filledField[0]].fieldPosition === Object.keys(threatFieldData).length) {\n      prefix = '...';\n      suffix = '';\n    }\n\n    return {\n      statement: `${prefix}${getFieldContentByToken(filledField[0] as ThreatFieldTypes, statement)}${suffix}`,\n      suggestions,\n    };\n  }\n\n  // Multiple fields are filled\n  if (!statement.threatSource) {\n    suggestions.push(\n      '[threat_source] Consider specifying who or what is the source of the threat',\n    );\n  }\n\n  if (!statement.prerequisites) {\n    suggestions.push(\n      '[prerequisites] Consider what conditions or requirement that must be met in order for a threat sources actions to be viable',\n    );\n    suggestions.push(\n      '[prerequisites] No prerequisites this is often a sign you can decompose into multiple threat statements that have different prerequisites',\n    );\n  }\n\n  if (!statement.threatAction) {\n    suggestions.push(\n      '[threat_action] Consider what actions are being performed by, or related to the threat source. Knowing this is required in order to mitigate the threat',\n    );\n  }\n\n  const updatedStatement: TemplateThreatStatement = {\n    ...statement,\n    threatSource: statement.threatSource || 'threat source',\n    prerequisites: statement.prerequisites || PLACEHOLDER,\n    threatAction: statement.threatAction || 'perform a threat action',\n  };\n\n  const { fieldCombination: updatedFieldCombination } = calculateFieldCombination(updatedStatement);\n\n  let format = null as any;\n\n  if (threatStatementFormatKeys.includes(updatedFieldCombination.toString())) {\n    format = threatStatementFormat[updatedFieldCombination];\n  }\n\n  suggestions.push(...format?.suggestions || []);\n\n  const outputProcessor = (token: string, content: string, before: string, _filled: boolean) => {\n    const output: {\n      stringOutput: string;\n      displayOutput: string | ThreatStatementDisplayToken;\n    }[] = [];\n\n    output.push({\n      stringOutput: before,\n      displayOutput: before,\n    });\n\n    const updatedContent = token === 'prerequisites' && content === PLACEHOLDER ? '' : content;\n\n    const displayedOutput = token === 'threat_action' ? {\n      type: 'b',\n      content: updatedContent,\n      tooltip: threatFieldData[token]?.tooltip,\n    } : {\n      type: 'span',\n      content: updatedContent,\n      tooltip: threatFieldData[token]?.tooltip,\n    };\n\n    output.push({\n      stringOutput: updatedContent,\n      displayOutput: displayedOutput as ThreatStatementDisplayToken,\n    });\n\n    return output;\n  };\n\n  const parseOutput = parseThreatStatement({\n    statement: updatedStatement,\n    template: statement.customTemplate || format?.template || '',\n    outputProcessor: outputProcessor,\n  });\n\n  return {\n    statement: parseOutput.map(x => x.stringOutput).join(' ').replace(/\\s\\s+/g, ' ').replace(/ ,/g, ','),\n    displayedStatement: parseOutput.map(x => x.displayOutput),\n    suggestions: suggestions.sort(),\n  };\n};\n\nexport default renderThreatStatement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}