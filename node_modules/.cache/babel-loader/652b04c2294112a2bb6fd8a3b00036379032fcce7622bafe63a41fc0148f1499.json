{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\nimport clsx from 'clsx';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { createOneSideRoundedRectPath } from './create-one-side-rounded-rect-path';\nimport { getKeyValue, matchesX } from './utils';\nimport styles from './styles.css.js';\nexport default function BarSeries({\n  axis,\n  series,\n  color,\n  xScale,\n  yScale,\n  highlighted,\n  dimmed,\n  highlightedGroupIndex,\n  totalSeriesCount,\n  seriesIndex,\n  plotSize,\n  chartAreaClipPath,\n  stackedBarValues,\n  isRtl\n}) {\n  const isRefresh = useVisualRefresh();\n  const isStacked = !!stackedBarValues;\n  const isVertical = axis === 'x';\n  const xCoordinates = (() => {\n    var _a;\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n    const yContinuosScale = yScale.d3Scale;\n    const xPoints = series.data.map(({\n      x\n    }) => xScale.d3Scale(x) || NaN);\n    const zeroY = (_a = yScale.d3Scale(0)) !== null && _a !== void 0 ? _a : NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n    let barWidth = xScale.d3Scale.bandwidth();\n    const PADDING = 4;\n    const MINWIDTH = 4;\n    if (!isStacked && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n    return xPoints.map((x, i) => {\n      var _a, _b, _c, _d;\n      const d = series.data[i];\n      const key = getKeyValue(d.x);\n      let barX = x;\n      let yValue = d.y;\n      let isRoundedStart = !isStacked;\n      let isRoundedEnd = !isStacked;\n      // Stacked bars\n      if (isStacked) {\n        const allXValues = (_a = stackedBarValues.get(key)) !== null && _a !== void 0 ? _a : new Map();\n        yValue = (_b = allXValues.get(seriesIndex)) !== null && _b !== void 0 ? _b : 0;\n        const allXValuesSorted = Array.from(allXValues.values()).sort((a, b) => a - b);\n        isRoundedStart = yValue === allXValuesSorted[0];\n        isRoundedEnd = yValue === allXValuesSorted[allXValuesSorted.length - 1];\n      }\n      // Regular grouped bars\n      else if (totalSeriesCount > 1) {\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n      return {\n        x: barX,\n        y: (_c = yContinuosScale(yValue)) !== null && _c !== void 0 ? _c : NaN,\n        width: barWidth,\n        height: Math.abs(((_d = yContinuosScale(d.y)) !== null && _d !== void 0 ? _d : NaN) - baseY),\n        isRoundedStart,\n        isRoundedEnd\n      };\n    });\n  })();\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n  return React.createElement(\"g\", {\n    \"aria-label\": series.title,\n    clipPath: `url(#${chartAreaClipPath})`,\n    className: clsx(styles.series, styles['series--bar'], {\n      [styles['series--highlighted']]: highlighted,\n      [styles['series--dimmed']]: dimmed\n    })\n  }, xCoordinates.map(({\n    x,\n    y,\n    width,\n    height,\n    isRoundedStart,\n    isRoundedEnd\n  }, i) => {\n    if (!isFinite(x) || !isFinite(height)) {\n      return;\n    }\n    // Create margins between stacked series but only when series data is not too small.\n    const baseHeightOffset = isStacked ? 3 : 0;\n    const isSmallBar = height < 4;\n    const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n    const widthOffset = 2;\n    const rx = isRefresh ? isSmallBar ? 2 : 4 : 0;\n    const placement = isVertical ? {\n      x: x + widthOffset / 2,\n      y: y + heightOffset / 2,\n      width: width - widthOffset,\n      height: height - heightOffset\n    } : {\n      x: y - (!isRtl ? height : 0) + heightOffset / 2,\n      y: x + widthOffset / 2,\n      width: height - heightOffset,\n      height: width - widthOffset\n    };\n    const className = clsx(styles.series__rect, {\n      [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x)\n    });\n    const styleProps = {\n      fill: color,\n      className\n    };\n    let side = 'none';\n    if (isRoundedStart && isRoundedEnd) {\n      side = 'all';\n    } else if (!isRoundedStart && !isRoundedEnd) {\n      side = 'none';\n    } else if (isVertical) {\n      side = isRoundedStart ? 'bottom' : 'top';\n    } else if (!isRtl) {\n      side = isRoundedStart ? 'left' : 'right';\n    } else {\n      side = isRoundedStart ? 'right' : 'left';\n    }\n    if (side === 'all') {\n      return React.createElement(\"rect\", Object.assign({\n        key: i\n      }, placement, styleProps, {\n        rx: rx\n      }));\n    }\n    if (side === 'none') {\n      return React.createElement(\"rect\", Object.assign({\n        key: i\n      }, placement, styleProps, {\n        rx: 0\n      }));\n    }\n    return React.createElement(\"path\", Object.assign({\n      key: i,\n      d: createOneSideRoundedRectPath(placement, rx, side)\n    }, styleProps));\n  }));\n}","map":{"version":3,"names":["React","clsx","useVisualRefresh","createOneSideRoundedRectPath","getKeyValue","matchesX","styles","BarSeries","axis","series","color","xScale","yScale","highlighted","dimmed","highlightedGroupIndex","totalSeriesCount","seriesIndex","plotSize","chartAreaClipPath","stackedBarValues","isRtl","isRefresh","isStacked","isVertical","xCoordinates","type","isCategorical","yContinuosScale","d3Scale","xPoints","data","map","x","NaN","zeroY","_a","baseY","isFinite","Math","min","barWidth","bandwidth","PADDING","MINWIDTH","max","i","d","key","barX","yValue","y","isRoundedStart","isRoundedEnd","allXValues","get","Map","_b","allXValuesSorted","Array","from","values","sort","a","b","length","_c","width","height","abs","_d","highlightedXValue","domain","createElement","title","clipPath","className","baseHeightOffset","isSmallBar","heightOffset","widthOffset","rx","placement","series__rect","styleProps","fill","side","Object","assign"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/bar-series.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\nimport clsx from 'clsx';\n\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { ScaleContinuousNumeric, ScaleTime } from '../internal/vendor/d3-scale';\nimport { createOneSideRoundedRectPath } from './create-one-side-rounded-rect-path';\nimport { ChartDataTypes, MixedLineBarChartProps } from './interfaces';\nimport { getKeyValue, matchesX, StackedBarValues } from './utils';\n\nimport styles from './styles.css.js';\n\nexport interface BarSeriesProps<T> {\n  axis: 'x' | 'y';\n\n  series: MixedLineBarChartProps.BarDataSeries<T>;\n\n  color: string;\n  totalSeriesCount: number;\n  seriesIndex: number;\n\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n\n  plotSize: number;\n  chartAreaClipPath: string;\n\n  highlighted: boolean;\n  dimmed: boolean;\n  highlightedGroupIndex: number | null;\n\n  // Contains values to be used for stacked bars.\n  stackedBarValues?: StackedBarValues;\n\n  isRtl?: boolean;\n}\n\nexport default function BarSeries<T extends ChartDataTypes>({\n  axis,\n  series,\n  color,\n  xScale,\n  yScale,\n  highlighted,\n  dimmed,\n  highlightedGroupIndex,\n  totalSeriesCount,\n  seriesIndex,\n  plotSize,\n  chartAreaClipPath,\n  stackedBarValues,\n  isRtl,\n}: BarSeriesProps<T>) {\n  const isRefresh = useVisualRefresh();\n  const isStacked = !!stackedBarValues;\n  const isVertical = axis === 'x';\n\n  const xCoordinates = (() => {\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n\n    const yContinuosScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number> = yScale.d3Scale;\n    const xPoints = (series.data as ReadonlyArray<MixedLineBarChartProps.Datum<ChartDataTypes>>).map(\n      ({ x }) => xScale.d3Scale(x) || NaN\n    );\n\n    const zeroY = yScale.d3Scale(0) ?? NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n\n    let barWidth = xScale.d3Scale.bandwidth();\n\n    const PADDING = 4;\n    const MINWIDTH = 4;\n\n    if (!isStacked && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n\n    return xPoints.map((x, i) => {\n      const d = series.data[i];\n      const key = getKeyValue(d.x);\n      let barX = x;\n      let yValue = d.y;\n      let isRoundedStart = !isStacked;\n      let isRoundedEnd = !isStacked;\n\n      // Stacked bars\n      if (isStacked) {\n        const allXValues = stackedBarValues.get(key) ?? new Map();\n        yValue = allXValues.get(seriesIndex) ?? 0;\n        const allXValuesSorted = Array.from(allXValues.values()).sort((a, b) => a - b);\n        isRoundedStart = yValue === allXValuesSorted[0];\n        isRoundedEnd = yValue === allXValuesSorted[allXValuesSorted.length - 1];\n      }\n      // Regular grouped bars\n      else if (totalSeriesCount > 1) {\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n\n      return {\n        x: barX,\n        y: yContinuosScale(yValue) ?? NaN,\n        width: barWidth,\n        height: Math.abs((yContinuosScale(d.y) ?? NaN) - baseY),\n        isRoundedStart,\n        isRoundedEnd,\n      };\n    });\n  })();\n\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n\n  return (\n    <g\n      aria-label={series.title}\n      clipPath={`url(#${chartAreaClipPath})`}\n      className={clsx(styles.series, styles['series--bar'], {\n        [styles['series--highlighted']]: highlighted,\n        [styles['series--dimmed']]: dimmed,\n      })}\n    >\n      {xCoordinates.map(({ x, y, width, height, isRoundedStart, isRoundedEnd }, i) => {\n        if (!isFinite(x) || !isFinite(height)) {\n          return;\n        }\n\n        // Create margins between stacked series but only when series data is not too small.\n        const baseHeightOffset = isStacked ? 3 : 0;\n        const isSmallBar = height < 4;\n        const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n        const widthOffset = 2;\n\n        const rx = isRefresh ? (isSmallBar ? 2 : 4) : 0;\n        const placement = isVertical\n          ? {\n              x: x + widthOffset / 2,\n              y: y + heightOffset / 2,\n              width: width - widthOffset,\n              height: height - heightOffset,\n            }\n          : {\n              x: y - (!isRtl ? height : 0) + heightOffset / 2,\n              y: x + widthOffset / 2,\n              width: height - heightOffset,\n              height: width - widthOffset,\n            };\n\n        const className = clsx(styles.series__rect, {\n          [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x),\n        });\n        const styleProps = { fill: color, className };\n\n        let side: 'left' | 'right' | 'top' | 'bottom' | 'all' | 'none' = 'none';\n        if (isRoundedStart && isRoundedEnd) {\n          side = 'all';\n        } else if (!isRoundedStart && !isRoundedEnd) {\n          side = 'none';\n        } else if (isVertical) {\n          side = isRoundedStart ? 'bottom' : 'top';\n        } else if (!isRtl) {\n          side = isRoundedStart ? 'left' : 'right';\n        } else {\n          side = isRoundedStart ? 'right' : 'left';\n        }\n\n        if (side === 'all') {\n          return <rect key={i} {...placement} {...styleProps} rx={rx} />;\n        }\n        if (side === 'none') {\n          return <rect key={i} {...placement} {...styleProps} rx={0} />;\n        }\n        return <path key={i} d={createOneSideRoundedRectPath(placement, rx, side)} {...styleProps} />;\n      })}\n    </g>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}