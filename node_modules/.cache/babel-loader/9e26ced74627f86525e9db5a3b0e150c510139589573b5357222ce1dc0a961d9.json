{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { calculateScroll, getFirstScrollableParent, scrollRectangleIntoView } from '../internal/utils/scrollable-containers';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\nexport default function usePopoverPosition(_ref) {\n  let {\n    popoverRef,\n    bodyRef,\n    arrowRef,\n    trackRef,\n    contentRef,\n    allowScrollToFit,\n    allowVerticalOverflow,\n    preferredPosition,\n    renderWithPortal,\n    keepPosition,\n    hideOnOverscroll\n  } = _ref;\n  const previousInternalPositionRef = useRef(null);\n  const [popoverStyle, setPopoverStyle] = useState({});\n  const [internalPosition, setInternalPosition] = useState(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef(() => {});\n  const scrollableContainerRectRef = useRef(null);\n  const updatePositionHandler = useCallback(function () {\n    let onContentResize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var _a;\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    const track = trackRef.current;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    const {\n      offsetWidth,\n      offsetHeight\n    } = getOffsetDimensions(popover);\n    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevInsetBlockStart = popover.style.insetBlockStart;\n    const prevInsetInlineStart = popover.style.insetInlineStart;\n    popover.style.insetBlockStart = '0';\n    popover.style.insetInlineStart = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxBlockSize = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView);\n    const trackRect = getLogicalBoundingClientRect(track);\n    const arrowRect = getDimensions(arrow);\n    const containingBlock = getContainingBlock(popover);\n    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = getLogicalBoundingClientRect(contentRef.current);\n    const contentBoundingBox = {\n      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n      blockSize: contentRect.blockSize + 2 * bodyBorderWidth\n    };\n    // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n    // we maintain the previously defined internal position,\n    // but we still call calculatePosition to know if the popover should be scrollable.\n    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : undefined;\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      rect\n    } = calculatePosition({\n      preferredPosition,\n      fixedInternalPosition,\n      trigger: trackRect,\n      arrow: arrowRect,\n      body: contentBoundingBox,\n      container: containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewport: viewportRect,\n      renderWithPortal,\n      allowVerticalOverflow\n    });\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(rect, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.insetBlockStart = prevInsetBlockStart;\n    popover.style.insetInlineStart = prevInsetInlineStart;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxBlockSize = rect.blockSize + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Remember the internal position in case we want to keep it later.\n    previousInternalPositionRef.current = newInternalPosition;\n    setInternalPosition(newInternalPosition);\n    const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n    // Position the popover\n    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;\n    setPopoverStyle({\n      insetBlockStart,\n      insetInlineStart: popoverOffset.insetInlineStart\n    });\n    // Scroll if necessary\n    if (shouldScroll) {\n      const scrollableParent = getFirstScrollableParent(popover);\n      scrollRectangleIntoView(rect, scrollableParent);\n    }\n    if (hideOnOverscroll && trackRef.current instanceof HTMLElement) {\n      const scrollableContainer = getFirstScrollableParent(trackRef.current);\n      if (scrollableContainer) {\n        scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n      }\n    }\n    positionHandlerRef.current = () => {\n      const trackRect = getLogicalBoundingClientRect(track);\n      const newTrackOffset = toRelativePosition(trackRect, containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);\n      setPopoverStyle({\n        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart\n      });\n      if (hideOnOverscroll && scrollableContainerRectRef.current) {\n        // Assuming the arrow tip is at the vertical center of the popover trigger.\n        // This is good enough for disabled reason tooltip in select and multiselect.\n        // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n        setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n      }\n    };\n  }, [trackRef, popoverRef, bodyRef, contentRef, arrowRef, keepPosition, preferredPosition, renderWithPortal, allowVerticalOverflow, allowScrollToFit, hideOnOverscroll]);\n  return {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef,\n    isOverscrolling\n  };\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart\n  };\n}\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  var _a, _b, _c, _d;\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: (_b = (_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window.innerWidth,\n    blockSize: (_d = (_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  const {\n    insetBlockStart,\n    insetInlineStart\n  } = getLogicalBoundingClientRect(document.documentElement);\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"names":["useCallback","useRef","useState","nodeContains","getLogicalBoundingClientRect","getContainingBlock","calculateScroll","getFirstScrollableParent","scrollRectangleIntoView","calculatePosition","getDimensions","getOffsetDimensions","isCenterOutside","usePopoverPosition","_ref","popoverRef","bodyRef","arrowRef","trackRef","contentRef","allowScrollToFit","allowVerticalOverflow","preferredPosition","renderWithPortal","keepPosition","hideOnOverscroll","previousInternalPositionRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","isOverscrolling","setIsOverscrolling","positionHandlerRef","scrollableContainerRectRef","updatePositionHandler","onContentResize","arguments","length","undefined","current","popover","body","arrow","document","ownerDocument","track","offsetWidth","offsetHeight","prevInsetBlockStart","style","insetBlockStart","prevInsetInlineStart","insetInlineStart","maxBlockSize","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","arrowRect","containingBlock","containingBlockRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","inlineSize","blockSize","shouldKeepPosition","fixedInternalPosition","_a","scrollable","newInternalPosition","rect","trigger","container","getDocumentRect","viewport","popoverOffset","toRelativePosition","trackRelativeOffset","shouldScroll","scrollableParent","HTMLElement","scrollableContainer","newTrackOffset","element","parseInt","getComputedStyle","borderWidth","parent","window","_b","visualViewport","width","innerWidth","_d","_c","height","innerHeight","documentElement","scrollWidth","scrollHeight"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/popover/use-popover-position.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getContainingBlock } from '../internal/utils/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps, Rect } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions, isCenterOutside } from './utils/positions';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n  hideOnOverscroll,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<HTMLElement | SVGElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n  hideOnOverscroll?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n  const [isOverscrolling, setIsOverscrolling] = useState(false);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const scrollableContainerRectRef = useRef<Rect | null>(null);\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      if (hideOnOverscroll && trackRef.current instanceof HTMLElement) {\n        const scrollableContainer = getFirstScrollableParent(trackRef.current);\n        if (scrollableContainer) {\n          scrollableContainerRectRef.current = getLogicalBoundingClientRect(scrollableContainer);\n        }\n      }\n\n      positionHandlerRef.current = () => {\n        const trackRect = getLogicalBoundingClientRect(track);\n\n        const newTrackOffset = toRelativePosition(\n          trackRect,\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n\n        if (hideOnOverscroll && scrollableContainerRectRef.current) {\n          // Assuming the arrow tip is at the vertical center of the popover trigger.\n          // This is good enough for disabled reason tooltip in select and multiselect.\n          // Can be further refined to take the exact arrow position into account if hideOnOverscroll is to be used in other cases.\n          setIsOverscrolling(isCenterOutside(trackRect, scrollableContainerRectRef.current));\n        }\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n      allowScrollToFit,\n      hideOnOverscroll,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.visualViewport?.width ?? window.innerWidth,\n    blockSize: window.visualViewport?.height ?? window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}