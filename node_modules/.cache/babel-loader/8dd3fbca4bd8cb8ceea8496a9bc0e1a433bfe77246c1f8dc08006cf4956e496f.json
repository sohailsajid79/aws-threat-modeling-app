{"ast":null,"code":"import { Position } from \"../../internal/utils/position\";\n/**\n * The insertion operation is similar to reorder yet the first path entry is treated differently.\n * The normalization removes leading path entries if on the same edge to optimize UX.\n */\nexport function normalizeInsertionPath(path, insertionDirection, columns, rows) {\n  let edgeIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    switch (insertionDirection) {\n      case \"left\":\n        {\n          if (path[i].x === 0) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"right\":\n        {\n          if (path[i].x === columns - 1) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"up\":\n        {\n          if (path[i].y === 0) {\n            edgeIndex = i;\n          }\n          break;\n        }\n      case \"down\":\n        {\n          if (path[i].y === rows - 1) {\n            edgeIndex = i;\n          }\n          break;\n        }\n    }\n  }\n  return path.slice(edgeIndex);\n}\nexport function appendMovePath(prevPath, collisionRect) {\n  return appendPath(prevPath, new Position({\n    x: collisionRect.left,\n    y: collisionRect.top\n  }));\n}\nexport function appendResizePath(prevPath, collisionRect) {\n  return appendPath(prevPath, new Position({\n    x: collisionRect.right,\n    y: collisionRect.bottom\n  }));\n}\n/**\n * The operation path must be strictly incremental (each dx + dy == 1). However, the actual collisions\n * data can have gaps due to pointer events throttling or other factors.\n *\n * The function produces next path from previous path and the target position by incrementally adding steps.\n */\nfunction appendPath(prevPath, nextPosition) {\n  const path = [...prevPath];\n  const lastPosition = prevPath[prevPath.length - 1];\n  if (!lastPosition) {\n    return [nextPosition];\n  }\n  const vx = Math.sign(nextPosition.x - lastPosition.x);\n  const vy = Math.sign(nextPosition.y - lastPosition.y);\n  let {\n    x,\n    y\n  } = lastPosition;\n  let safetyCounter = 0;\n  while (x !== nextPosition.x || y !== nextPosition.y) {\n    if (++safetyCounter === 100) {\n      throw new Error(\"Infinite loop in appendPath.\");\n    }\n    if (x !== nextPosition.x) {\n      x += vx;\n    } else {\n      y += vy;\n    }\n    path.push(new Position({\n      x,\n      y\n    }));\n  }\n  return path;\n}","map":{"version":3,"names":["Position","normalizeInsertionPath","path","insertionDirection","columns","rows","edgeIndex","i","length","x","y","slice","appendMovePath","prevPath","collisionRect","appendPath","left","top","appendResizePath","right","bottom","nextPosition","lastPosition","vx","Math","sign","vy","safetyCounter","Error","push"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/board/utils/path.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Direction } from \"../../internal/interfaces\";\nimport { Rect } from \"../../internal/interfaces\";\nimport { Position } from \"../../internal/utils/position\";\n\n/**\n * The insertion operation is similar to reorder yet the first path entry is treated differently.\n * The normalization removes leading path entries if on the same edge to optimize UX.\n */\nexport function normalizeInsertionPath(\n  path: readonly Position[],\n  insertionDirection: Direction,\n  columns: number,\n  rows: number,\n): Position[] {\n  let edgeIndex = -1;\n  for (let i = 0; i < path.length; i++) {\n    switch (insertionDirection) {\n      case \"left\": {\n        if (path[i].x === 0) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"right\": {\n        if (path[i].x === columns - 1) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"up\": {\n        if (path[i].y === 0) {\n          edgeIndex = i;\n        }\n        break;\n      }\n      case \"down\": {\n        if (path[i].y === rows - 1) {\n          edgeIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  return path.slice(edgeIndex);\n}\n\nexport function appendMovePath(prevPath: readonly Position[], collisionRect: Rect): Position[] {\n  return appendPath(prevPath, new Position({ x: collisionRect.left, y: collisionRect.top }));\n}\n\nexport function appendResizePath(prevPath: readonly Position[], collisionRect: Rect): Position[] {\n  return appendPath(prevPath, new Position({ x: collisionRect.right, y: collisionRect.bottom }));\n}\n\n/**\n * The operation path must be strictly incremental (each dx + dy == 1). However, the actual collisions\n * data can have gaps due to pointer events throttling or other factors.\n *\n * The function produces next path from previous path and the target position by incrementally adding steps.\n */\nfunction appendPath(prevPath: readonly Position[], nextPosition: Position): Position[] {\n  const path: Array<Position> = [...prevPath];\n  const lastPosition = prevPath[prevPath.length - 1];\n\n  if (!lastPosition) {\n    return [nextPosition];\n  }\n\n  const vx = Math.sign(nextPosition.x - lastPosition.x);\n  const vy = Math.sign(nextPosition.y - lastPosition.y);\n\n  let { x, y } = lastPosition;\n  let safetyCounter = 0;\n\n  while (x !== nextPosition.x || y !== nextPosition.y) {\n    if (++safetyCounter === 100) {\n      throw new Error(\"Infinite loop in appendPath.\");\n    }\n    if (x !== nextPosition.x) {\n      x += vx;\n    } else {\n      y += vy;\n    }\n    path.push(new Position({ x, y }));\n  }\n\n  return path;\n}\n"],"mappings":"AAIA,SAASA,QAAQ,QAAQ,+BAA+B;AAExD;;;;AAIA,OAAM,SAAUC,sBAAsBA,CACpCC,IAAyB,EACzBC,kBAA6B,EAC7BC,OAAe,EACfC,IAAY;EAEZ,IAAIC,SAAS,GAAG,CAAC,CAAC;EAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,IAAI,CAACM,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,QAAQJ,kBAAkB;MACxB,KAAK,MAAM;QAAE;UACX,IAAID,IAAI,CAACK,CAAC,CAAC,CAACE,CAAC,KAAK,CAAC,EAAE;YACnBH,SAAS,GAAGC,CAAC;;UAEf;;MAEF,KAAK,OAAO;QAAE;UACZ,IAAIL,IAAI,CAACK,CAAC,CAAC,CAACE,CAAC,KAAKL,OAAO,GAAG,CAAC,EAAE;YAC7BE,SAAS,GAAGC,CAAC;;UAEf;;MAEF,KAAK,IAAI;QAAE;UACT,IAAIL,IAAI,CAACK,CAAC,CAAC,CAACG,CAAC,KAAK,CAAC,EAAE;YACnBJ,SAAS,GAAGC,CAAC;;UAEf;;MAEF,KAAK,MAAM;QAAE;UACX,IAAIL,IAAI,CAACK,CAAC,CAAC,CAACG,CAAC,KAAKL,IAAI,GAAG,CAAC,EAAE;YAC1BC,SAAS,GAAGC,CAAC;;UAEf;;;;EAIN,OAAOL,IAAI,CAACS,KAAK,CAACL,SAAS,CAAC;AAC9B;AAEA,OAAM,SAAUM,cAAcA,CAACC,QAA6B,EAAEC,aAAmB;EAC/E,OAAOC,UAAU,CAACF,QAAQ,EAAE,IAAIb,QAAQ,CAAC;IAAES,CAAC,EAAEK,aAAa,CAACE,IAAI;IAAEN,CAAC,EAAEI,aAAa,CAACG;EAAG,CAAE,CAAC,CAAC;AAC5F;AAEA,OAAM,SAAUC,gBAAgBA,CAACL,QAA6B,EAAEC,aAAmB;EACjF,OAAOC,UAAU,CAACF,QAAQ,EAAE,IAAIb,QAAQ,CAAC;IAAES,CAAC,EAAEK,aAAa,CAACK,KAAK;IAAET,CAAC,EAAEI,aAAa,CAACM;EAAM,CAAE,CAAC,CAAC;AAChG;AAEA;;;;;;AAMA,SAASL,UAAUA,CAACF,QAA6B,EAAEQ,YAAsB;EACvE,MAAMnB,IAAI,GAAoB,CAAC,GAAGW,QAAQ,CAAC;EAC3C,MAAMS,YAAY,GAAGT,QAAQ,CAACA,QAAQ,CAACL,MAAM,GAAG,CAAC,CAAC;EAElD,IAAI,CAACc,YAAY,EAAE;IACjB,OAAO,CAACD,YAAY,CAAC;;EAGvB,MAAME,EAAE,GAAGC,IAAI,CAACC,IAAI,CAACJ,YAAY,CAACZ,CAAC,GAAGa,YAAY,CAACb,CAAC,CAAC;EACrD,MAAMiB,EAAE,GAAGF,IAAI,CAACC,IAAI,CAACJ,YAAY,CAACX,CAAC,GAAGY,YAAY,CAACZ,CAAC,CAAC;EAErD,IAAI;IAAED,CAAC;IAAEC;EAAC,CAAE,GAAGY,YAAY;EAC3B,IAAIK,aAAa,GAAG,CAAC;EAErB,OAAOlB,CAAC,KAAKY,YAAY,CAACZ,CAAC,IAAIC,CAAC,KAAKW,YAAY,CAACX,CAAC,EAAE;IACnD,IAAI,EAAEiB,aAAa,KAAK,GAAG,EAAE;MAC3B,MAAM,IAAIC,KAAK,CAAC,8BAA8B,CAAC;;IAEjD,IAAInB,CAAC,KAAKY,YAAY,CAACZ,CAAC,EAAE;MACxBA,CAAC,IAAIc,EAAE;KACR,MAAM;MACLb,CAAC,IAAIgB,EAAE;;IAETxB,IAAI,CAAC2B,IAAI,CAAC,IAAI7B,QAAQ,CAAC;MAAES,CAAC;MAAEC;IAAC,CAAE,CAAC,CAAC;;EAGnC,OAAOR,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}