{"ast":null,"code":"export const chartLegendMap = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed'\n};\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = function (nextGroupIndex, barGroups) {\n  let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let index = nextGroupIndex;\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries(series) {\n  const navigableSeries = [];\n  let navigableBarSeriesIndex = -1;\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return {\n    navigableSeries,\n    navigableBarSeriesIndex\n  };\n}\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = (x1, x2) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n// Unlike for regular bars, stacked bar series values depend on the predecessors.\n// The function computes all stacked values grouped by X and series index.\nexport function calculateStackedBarValues(dataBySeries) {\n  var _a, _b, _c, _d;\n  const negativeValues = new Map();\n  const positiveValues = new Map();\n  const values = new Map();\n  for (let seriesIndex = 0; seriesIndex < dataBySeries.length; seriesIndex++) {\n    for (const datum of dataBySeries[seriesIndex]) {\n      const key = getKeyValue(datum.x);\n      if (datum.y < 0) {\n        negativeValues.set(key, ((_a = negativeValues.get(key)) !== null && _a !== void 0 ? _a : 0) + datum.y);\n      } else {\n        positiveValues.set(key, ((_b = positiveValues.get(key)) !== null && _b !== void 0 ? _b : 0) + datum.y);\n      }\n      const seriesValue = (_c = datum.y < 0 ? negativeValues.get(key) : positiveValues.get(key)) !== null && _c !== void 0 ? _c : 0;\n      const valuesByIndex = (_d = values.get(key)) !== null && _d !== void 0 ? _d : new Map();\n      valuesByIndex.set(seriesIndex, seriesValue);\n      values.set(key, valuesByIndex);\n    }\n  }\n  return values;\n}\n/** Returns string or number value for ChartDataTypes key */\nexport const getKeyValue = key => key instanceof Date ? key.getTime() : key;\nexport function isYThreshold(series) {\n  return series.type === 'threshold' && 'y' in series;\n}\nexport function isXThreshold(series) {\n  return series.type === 'threshold' && 'x' in series;\n}\nexport function isDataSeries(series) {\n  return series.type === 'line' || series.type === 'bar';\n}","map":{"version":3,"names":["chartLegendMap","line","bar","threshold","nextValidDomainIndex","nextGroupIndex","barGroups","direction","arguments","length","undefined","index","isValid","hasData","findNavigableSeries","series","navigableSeries","navigableBarSeriesIndex","forEach","internalSeries","type","push","matchesX","x1","x2","Date","getTime","calculateStackedBarValues","dataBySeries","negativeValues","Map","positiveValues","values","seriesIndex","datum","key","getKeyValue","x","y","set","_a","get","_b","seriesValue","_c","valuesByIndex","_d","isYThreshold","isXThreshold","isDataSeries"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartSeriesMarkerType } from '../internal/components/chart-series-marker';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ScaledBarGroup } from './make-scaled-bar-groups';\n\nexport const chartLegendMap: Record<string, ChartSeriesMarkerType> = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed',\n};\n\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = <T>(nextGroupIndex: number, barGroups: ScaledBarGroup<T>[], direction = 1) => {\n  let index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries<T extends ChartDataTypes>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const navigableSeries: Array<MixedLineBarChartProps.ChartSeries<T>> = [];\n  let navigableBarSeriesIndex = -1;\n\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return { navigableSeries, navigableBarSeriesIndex };\n}\n\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = <T>(x1: T, x2: T) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n\nexport type StackedBarValues = Map<string | number, Map<number, number>>;\n\n// Unlike for regular bars, stacked bar series values depend on the predecessors.\n// The function computes all stacked values grouped by X and series index.\nexport function calculateStackedBarValues(\n  dataBySeries: Array<readonly MixedLineBarChartProps.Datum<ChartDataTypes>[]>\n): StackedBarValues {\n  const negativeValues = new Map<string | number, number>();\n  const positiveValues = new Map<string | number, number>();\n  const values = new Map<string | number, Map<number, number>>();\n  for (let seriesIndex = 0; seriesIndex < dataBySeries.length; seriesIndex++) {\n    for (const datum of dataBySeries[seriesIndex]) {\n      const key = getKeyValue(datum.x);\n      if (datum.y < 0) {\n        negativeValues.set(key, (negativeValues.get(key) ?? 0) + datum.y);\n      } else {\n        positiveValues.set(key, (positiveValues.get(key) ?? 0) + datum.y);\n      }\n      const seriesValue = (datum.y < 0 ? negativeValues.get(key) : positiveValues.get(key)) ?? 0;\n      const valuesByIndex = values.get(key) ?? new Map<number, number>();\n      valuesByIndex.set(seriesIndex, seriesValue);\n      values.set(key, valuesByIndex);\n    }\n  }\n  return values;\n}\n\n/** Returns string or number value for ChartDataTypes key */\nexport const getKeyValue = (key: ChartDataTypes) => (key instanceof Date ? key.getTime() : key);\n\nexport function isYThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.YThresholdSeries {\n  return series.type === 'threshold' && 'y' in series;\n}\n\nexport function isXThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.XThresholdSeries<T> {\n  return series.type === 'threshold' && 'x' in series;\n}\n\nexport function isDataSeries<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.DataSeries<T> {\n  return series.type === 'line' || series.type === 'bar';\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}