{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useLayoutEffect, useRef } from 'react';\nimport clsx from 'clsx';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport usePopoverPosition from './use-popover-position.js';\nimport styles from './styles.css.js';\nexport default function PopoverContainer({\n  position,\n  trackRef,\n  trackKey,\n  arrow,\n  children,\n  zIndex,\n  renderWithPortal,\n  size,\n  fixedWidth,\n  variant,\n  keepPosition,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  hideOnOverscroll\n}) {\n  const bodyRef = useRef(null);\n  const contentRef = useRef(null);\n  const popoverRef = useRef(null);\n  const arrowRef = useRef(null);\n  const isRefresh = useVisualRefresh();\n  // Updates the position handler.\n  const {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef,\n    isOverscrolling\n  } = usePopoverPosition({\n    popoverRef,\n    bodyRef,\n    arrowRef,\n    trackRef,\n    contentRef,\n    allowScrollToFit,\n    allowVerticalOverflow,\n    preferredPosition: position,\n    renderWithPortal,\n    keepPosition,\n    hideOnOverscroll\n  });\n  // Recalculate position when properties change.\n  useLayoutEffect(() => {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey]);\n  // Recalculate position when content size changes.\n  useResizeObserver(contentRef, () => {\n    updatePositionHandler(true);\n  });\n  // Recalculate position on DOM events.\n  useLayoutEffect(() => {\n    /*\n    This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n    and by tracking the click event we can adapt the popover's position to the new layout.\n         TODO: extend this to Enter and Spacebar?\n    */\n    const onClick = event => {\n      if (\n      // Do not update position if keepPosition is true.\n      keepPosition ||\n      // If the click was on the trigger, this will make the popover appear or disappear,\n      // so no need to update its position either in this case.\n      nodeContains(trackRef.current, event.target)) {\n        return;\n      }\n      requestAnimationFrame(() => {\n        updatePositionHandler();\n      });\n    };\n    const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());\n    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());\n    window.addEventListener('click', onClick);\n    window.addEventListener('resize', updatePositionOnResize);\n    window.addEventListener('scroll', refreshPosition, true);\n    return () => {\n      window.removeEventListener('click', onClick);\n      window.removeEventListener('resize', updatePositionOnResize);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [hideOnOverscroll, keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);\n  return isOverscrolling ? null : React.createElement(\"div\", {\n    ref: popoverRef,\n    style: Object.assign(Object.assign({}, popoverStyle), {\n      zIndex\n    }),\n    className: clsx(styles.container, isRefresh && styles.refresh)\n  }, React.createElement(\"div\", {\n    ref: arrowRef,\n    className: clsx(styles[`container-arrow`], styles[`container-arrow-position-${internalPosition}`]),\n    \"aria-hidden\": true\n  }, arrow(internalPosition)), React.createElement(\"div\", {\n    ref: bodyRef,\n    className: clsx(styles['container-body'], styles[`container-body-size-${size}`], {\n      [styles['fixed-width']]: fixedWidth,\n      [styles[`container-body-variant-${variant}`]]: variant\n    })\n  }, React.createElement(\"div\", {\n    ref: contentRef\n  }, children)));\n}","map":{"version":3,"names":["React","useLayoutEffect","useRef","clsx","nodeContains","useResizeObserver","useVisualRefresh","usePopoverPosition","styles","PopoverContainer","position","trackRef","trackKey","arrow","children","zIndex","renderWithPortal","size","fixedWidth","variant","keepPosition","allowScrollToFit","allowVerticalOverflow","hideOnOverscroll","bodyRef","contentRef","popoverRef","arrowRef","isRefresh","updatePositionHandler","popoverStyle","internalPosition","positionHandlerRef","isOverscrolling","preferredPosition","onClick","event","current","target","requestAnimationFrame","updatePositionOnResize","refreshPosition","window","addEventListener","removeEventListener","createElement","ref","style","Object","assign","className","container","refresh"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/popover/container.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useLayoutEffect, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\n\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { InternalPosition, PopoverProps } from './interfaces';\nimport usePopoverPosition from './use-popover-position.js';\n\nimport styles from './styles.css.js';\n\nexport interface PopoverContainerProps {\n  /** References the element the container is positioned against. */\n  trackRef: React.RefObject<HTMLElement | SVGElement>;\n  /**\n    Used to update the container position in case track or track position changes:\n    \n    const trackRef = useRef<Element>(null)\n    return (<>\n      <Track style={getPosition(selectedItemId)} ref={trackRef} />\n      <PopoverContainer trackRef={trackRef} trackKey={selectedItemId} .../>\n    </>)\n  */\n  trackKey?: string | number;\n  position: PopoverProps.Position;\n  zIndex?: React.CSSProperties['zIndex'];\n  arrow: (position: InternalPosition | null) => React.ReactNode;\n  children: React.ReactNode;\n  renderWithPortal?: boolean;\n  size: PopoverProps.Size | 'content';\n  fixedWidth: boolean;\n  variant?: 'annotation';\n  // When keepPosition is true, the popover will not recalculate its position when it resizes nor when it receives clicks.\n  keepPosition?: boolean;\n  // When allowScrollToFit is true, we will scroll to the the popover if it overflows the viewport even when choosing the best possible position for it.\n  // Do not use this if the popover is open on hover, in order to avoid unexpected movement.\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  // Whether the popover should be hidden when the trigger is scrolled away.\n  hideOnOverscroll?: boolean;\n}\n\nexport default function PopoverContainer({\n  position,\n  trackRef,\n  trackKey,\n  arrow,\n  children,\n  zIndex,\n  renderWithPortal,\n  size,\n  fixedWidth,\n  variant,\n  keepPosition,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  hideOnOverscroll,\n}: PopoverContainerProps) {\n  const bodyRef = useRef<HTMLDivElement | null>(null);\n  const contentRef = useRef<HTMLDivElement | null>(null);\n  const popoverRef = useRef<HTMLDivElement | null>(null);\n  const arrowRef = useRef<HTMLDivElement | null>(null);\n\n  const isRefresh = useVisualRefresh();\n\n  // Updates the position handler.\n  const { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef, isOverscrolling } =\n    usePopoverPosition({\n      popoverRef,\n      bodyRef,\n      arrowRef,\n      trackRef,\n      contentRef,\n      allowScrollToFit,\n      allowVerticalOverflow,\n      preferredPosition: position,\n      renderWithPortal,\n      keepPosition,\n      hideOnOverscroll,\n    });\n\n  // Recalculate position when properties change.\n  useLayoutEffect(() => {\n    updatePositionHandler();\n  }, [updatePositionHandler, trackKey]);\n\n  // Recalculate position when content size changes.\n  useResizeObserver(contentRef, () => {\n    updatePositionHandler(true);\n  });\n\n  // Recalculate position on DOM events.\n  useLayoutEffect(() => {\n    /*\n    This is a heuristic. Some layout changes are caused by user clicks (e.g. toggling the tools panel, submitting a form),\n    and by tracking the click event we can adapt the popover's position to the new layout.\n\n    TODO: extend this to Enter and Spacebar?\n    */\n\n    const onClick = (event: UIEvent | KeyboardEvent) => {\n      if (\n        // Do not update position if keepPosition is true.\n        keepPosition ||\n        // If the click was on the trigger, this will make the popover appear or disappear,\n        // so no need to update its position either in this case.\n        nodeContains(trackRef.current, event.target)\n      ) {\n        return;\n      }\n\n      requestAnimationFrame(() => {\n        updatePositionHandler();\n      });\n    };\n\n    const updatePositionOnResize = () => requestAnimationFrame(() => updatePositionHandler());\n    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());\n\n    window.addEventListener('click', onClick);\n    window.addEventListener('resize', updatePositionOnResize);\n    window.addEventListener('scroll', refreshPosition, true);\n\n    return () => {\n      window.removeEventListener('click', onClick);\n      window.removeEventListener('resize', updatePositionOnResize);\n      window.removeEventListener('scroll', refreshPosition, true);\n    };\n  }, [hideOnOverscroll, keepPosition, positionHandlerRef, trackRef, updatePositionHandler]);\n\n  return isOverscrolling ? null : (\n    <div\n      ref={popoverRef}\n      style={{ ...popoverStyle, zIndex }}\n      className={clsx(styles.container, isRefresh && styles.refresh)}\n    >\n      <div\n        ref={arrowRef}\n        className={clsx(styles[`container-arrow`], styles[`container-arrow-position-${internalPosition}`])}\n        aria-hidden={true}\n      >\n        {arrow(internalPosition)}\n      </div>\n\n      <div\n        ref={bodyRef}\n        className={clsx(styles['container-body'], styles[`container-body-size-${size}`], {\n          [styles['fixed-width']]: fixedWidth,\n          [styles[`container-body-variant-${variant}`]]: variant,\n        })}\n      >\n        <div ref={contentRef}>{children}</div>\n      </div>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}