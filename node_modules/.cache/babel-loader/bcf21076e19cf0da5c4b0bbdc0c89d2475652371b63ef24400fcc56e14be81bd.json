{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nimport lodashIsEmpty from 'lodash/isEmpty';\nimport get from 'lodash/get';\nvar isEmptyValue = function isEmptyValue(value) {\n  if (value instanceof Date) {\n    return isNaN(value.getTime());\n  }\n  return typeof value === 'number' || value === true ? false : lodashIsEmpty(value);\n};\nvar fieldCondition = function fieldCondition(value, config) {\n  if (config.isNotEmpty) {\n    return !isEmptyValue(value);\n  }\n  if (config.isEmpty) {\n    return isEmptyValue(value);\n  }\n  if (config.pattern) {\n    var regExpPattern = RegExp(config.pattern, config.flags);\n    return config.notMatch ? !regExpPattern.test(value) : regExpPattern.test(value);\n  }\n  if (typeof config.is === 'function') {\n    return config.is(value, config);\n  }\n  if (Object.prototype.hasOwnProperty.call(config, 'greaterThan')) {\n    return value > config.greaterThan;\n  }\n  if (Object.prototype.hasOwnProperty.call(config, 'greaterThanOrEqualTo')) {\n    return value >= config.greaterThanOrEqualTo;\n  }\n  if (Object.prototype.hasOwnProperty.call(config, 'lessThan')) {\n    return value < config.lessThan;\n  }\n  if (Object.prototype.hasOwnProperty.call(config, 'lessThanOrEqualTo')) {\n    return value <= config.lessThanOrEqualTo;\n  }\n  var isMatched = Array.isArray(config.is) ? !!config.is.includes(value) : value === config.is;\n  return config.notMatch ? !isMatched : isMatched;\n};\nvar allowedMappedAttributes = ['when', 'is'];\nexport var unpackMappedCondition = function unpackMappedCondition(condition, conditionMapper) {\n  if (_typeof(condition.mappedAttributes) !== 'object') {\n    return condition;\n  }\n  var mappedAttributes = condition.mappedAttributes;\n  var internalCondition = _objectSpread(_objectSpread({}, condition), {}, {\n    mappedAttributes: undefined\n  });\n  Object.entries(mappedAttributes).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      value = _ref2[1];\n    if (!allowedMappedAttributes.includes(key)) {\n      console.error(\"Mapped condition attribute \".concat(key, \" is not allowed! Allowed attributes are: \").concat(allowedMappedAttributes.join(', ')));\n      return;\n    }\n    if (conditionMapper[value === null || value === void 0 ? void 0 : value[0]]) {\n      var _value = _toArray(value),\n        fnName = _value[0],\n        args = _value.slice(1);\n      var fn = conditionMapper[fnName];\n      internalCondition[key] = fn.apply(void 0, _toConsumableArray(args));\n    } else {\n      console.error(\"Missing conditionMapper entry for \".concat(value, \"!\"));\n    }\n  });\n  return internalCondition;\n};\nexport var parseCondition = function parseCondition(condition, values, field) {\n  var conditionMapper = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var positiveResult = _objectSpread(_objectSpread({\n    visible: true\n  }, condition.then), {}, {\n    result: true\n  });\n  var negativeResult = _objectSpread(_objectSpread({\n    visible: false\n  }, condition[\"else\"]), {}, {\n    result: false\n  });\n  if (Array.isArray(condition)) {\n    return !condition.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref3) {\n      var result = _ref3.result;\n      return result === false;\n    }) ? positiveResult : negativeResult;\n  }\n  var conditionInternal = unpackMappedCondition(condition, conditionMapper);\n  if (conditionInternal.and) {\n    return !conditionInternal.and.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref4) {\n      var result = _ref4.result;\n      return result === false;\n    }) ? positiveResult : negativeResult;\n  }\n  if (conditionInternal.sequence) {\n    return conditionInternal.sequence.reduce(function (acc, curr) {\n      var result = parseCondition(curr, values, field, conditionMapper);\n      return {\n        sets: [].concat(_toConsumableArray(acc.sets), _toConsumableArray(result.set ? [result.set] : [])),\n        visible: acc.visible || result.visible,\n        result: acc.result || result.result\n      };\n    }, _objectSpread(_objectSpread({}, negativeResult), {}, {\n      sets: []\n    }));\n  }\n  if (conditionInternal.or) {\n    return conditionInternal.or.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref5) {\n      var result = _ref5.result;\n      return result === true;\n    }) ? positiveResult : negativeResult;\n  }\n  if (conditionInternal.not) {\n    return !parseCondition(conditionInternal.not, values, field, conditionMapper).result ? positiveResult : negativeResult;\n  }\n  var finalWhen = typeof conditionInternal.when === 'function' ? conditionInternal.when(field) : conditionInternal.when;\n  if (typeof finalWhen === 'string') {\n    return fieldCondition(get(values, finalWhen), conditionInternal) ? positiveResult : negativeResult;\n  }\n  if (Array.isArray(finalWhen)) {\n    return finalWhen.map(function (fieldName) {\n      return fieldCondition(get(values, typeof fieldName === 'function' ? fieldName(field) : fieldName), conditionInternal);\n    }).find(function (condition) {\n      return !!condition;\n    }) ? positiveResult : negativeResult;\n  }\n  return negativeResult;\n};\nexport default parseCondition;","map":{"version":3,"names":["_toConsumableArray","_toArray","_slicedToArray","_defineProperty","_typeof","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","lodashIsEmpty","get","isEmptyValue","value","Date","isNaN","getTime","fieldCondition","config","isNotEmpty","isEmpty","pattern","regExpPattern","RegExp","flags","notMatch","test","is","prototype","hasOwnProperty","call","greaterThan","greaterThanOrEqualTo","lessThan","lessThanOrEqualTo","isMatched","Array","isArray","includes","allowedMappedAttributes","unpackMappedCondition","condition","conditionMapper","mappedAttributes","internalCondition","undefined","entries","_ref","_ref2","console","error","concat","join","_value","fnName","args","slice","fn","parseCondition","values","field","positiveResult","visible","then","result","negativeResult","map","some","_ref3","conditionInternal","and","_ref4","sequence","reduce","acc","curr","sets","set","or","_ref5","not","finalWhen","when","fieldName","find"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/@data-driven-forms/react-form-renderer/esm/parse-condition/parse-condition.js"],"sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _toArray from \"@babel/runtime/helpers/toArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _typeof from \"@babel/runtime/helpers/typeof\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport lodashIsEmpty from 'lodash/isEmpty';\nimport get from 'lodash/get';\n\nvar isEmptyValue = function isEmptyValue(value) {\n  if (value instanceof Date) {\n    return isNaN(value.getTime());\n  }\n\n  return typeof value === 'number' || value === true ? false : lodashIsEmpty(value);\n};\n\nvar fieldCondition = function fieldCondition(value, config) {\n  if (config.isNotEmpty) {\n    return !isEmptyValue(value);\n  }\n\n  if (config.isEmpty) {\n    return isEmptyValue(value);\n  }\n\n  if (config.pattern) {\n    var regExpPattern = RegExp(config.pattern, config.flags);\n    return config.notMatch ? !regExpPattern.test(value) : regExpPattern.test(value);\n  }\n\n  if (typeof config.is === 'function') {\n    return config.is(value, config);\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'greaterThan')) {\n    return value > config.greaterThan;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'greaterThanOrEqualTo')) {\n    return value >= config.greaterThanOrEqualTo;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'lessThan')) {\n    return value < config.lessThan;\n  }\n\n  if (Object.prototype.hasOwnProperty.call(config, 'lessThanOrEqualTo')) {\n    return value <= config.lessThanOrEqualTo;\n  }\n\n  var isMatched = Array.isArray(config.is) ? !!config.is.includes(value) : value === config.is;\n  return config.notMatch ? !isMatched : isMatched;\n};\n\nvar allowedMappedAttributes = ['when', 'is'];\nexport var unpackMappedCondition = function unpackMappedCondition(condition, conditionMapper) {\n  if (_typeof(condition.mappedAttributes) !== 'object') {\n    return condition;\n  }\n\n  var mappedAttributes = condition.mappedAttributes;\n\n  var internalCondition = _objectSpread(_objectSpread({}, condition), {}, {\n    mappedAttributes: undefined\n  });\n\n  Object.entries(mappedAttributes).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    if (!allowedMappedAttributes.includes(key)) {\n      console.error(\"Mapped condition attribute \".concat(key, \" is not allowed! Allowed attributes are: \").concat(allowedMappedAttributes.join(', ')));\n      return;\n    }\n\n    if (conditionMapper[value === null || value === void 0 ? void 0 : value[0]]) {\n      var _value = _toArray(value),\n          fnName = _value[0],\n          args = _value.slice(1);\n\n      var fn = conditionMapper[fnName];\n      internalCondition[key] = fn.apply(void 0, _toConsumableArray(args));\n    } else {\n      console.error(\"Missing conditionMapper entry for \".concat(value, \"!\"));\n    }\n  });\n  return internalCondition;\n};\nexport var parseCondition = function parseCondition(condition, values, field) {\n  var conditionMapper = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n  var positiveResult = _objectSpread(_objectSpread({\n    visible: true\n  }, condition.then), {}, {\n    result: true\n  });\n\n  var negativeResult = _objectSpread(_objectSpread({\n    visible: false\n  }, condition[\"else\"]), {}, {\n    result: false\n  });\n\n  if (Array.isArray(condition)) {\n    return !condition.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref3) {\n      var result = _ref3.result;\n      return result === false;\n    }) ? positiveResult : negativeResult;\n  }\n\n  var conditionInternal = unpackMappedCondition(condition, conditionMapper);\n\n  if (conditionInternal.and) {\n    return !conditionInternal.and.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref4) {\n      var result = _ref4.result;\n      return result === false;\n    }) ? positiveResult : negativeResult;\n  }\n\n  if (conditionInternal.sequence) {\n    return conditionInternal.sequence.reduce(function (acc, curr) {\n      var result = parseCondition(curr, values, field, conditionMapper);\n      return {\n        sets: [].concat(_toConsumableArray(acc.sets), _toConsumableArray(result.set ? [result.set] : [])),\n        visible: acc.visible || result.visible,\n        result: acc.result || result.result\n      };\n    }, _objectSpread(_objectSpread({}, negativeResult), {}, {\n      sets: []\n    }));\n  }\n\n  if (conditionInternal.or) {\n    return conditionInternal.or.map(function (condition) {\n      return parseCondition(condition, values, field, conditionMapper);\n    }).some(function (_ref5) {\n      var result = _ref5.result;\n      return result === true;\n    }) ? positiveResult : negativeResult;\n  }\n\n  if (conditionInternal.not) {\n    return !parseCondition(conditionInternal.not, values, field, conditionMapper).result ? positiveResult : negativeResult;\n  }\n\n  var finalWhen = typeof conditionInternal.when === 'function' ? conditionInternal.when(field) : conditionInternal.when;\n\n  if (typeof finalWhen === 'string') {\n    return fieldCondition(get(values, finalWhen), conditionInternal) ? positiveResult : negativeResult;\n  }\n\n  if (Array.isArray(finalWhen)) {\n    return finalWhen.map(function (fieldName) {\n      return fieldCondition(get(values, typeof fieldName === 'function' ? fieldName(field) : fieldName), conditionInternal);\n    }).find(function (condition) {\n      return !!condition;\n    }) ? positiveResult : negativeResult;\n  }\n\n  return negativeResult;\n};\nexport default parseCondition;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}