{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\nconst isBrowser = typeof window !== 'undefined';\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy(_ref) {\n  let {\n    hrefs,\n    scrollSpyOffset,\n    activeHref\n  } = _ref;\n  const [currentHref, setCurrentHref] = useState(activeHref);\n  const [lastAnchorExists, setLastAnchorExists] = useState(false);\n  useEffect(() => {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n  useEffect(() => {\n    var _a;\n    setLastAnchorExists(isBrowser && !!document.getElementById((_a = hrefs[hrefs.length - 1]) === null || _a === void 0 ? void 0 : _a.slice(1)));\n  }, [hrefs]);\n  // Get the bounding rectangle of an element by href\n  const getRectByHref = useCallback(href => {\n    var _a;\n    return (_a = document.getElementById(href.slice(1))) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect();\n  }, []);\n  // Check if we're scrolled to the bottom of the page\n  const isPageBottom = useCallback(() => {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n  // Find the first href for which the element is within the viewport\n  const findHrefInView = useCallback(() => {\n    return hrefs.find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n  // Find the last href where its element is above or within the viewport\n  const findLastHrefInView = useCallback(() => {\n    return [...hrefs].reverse().find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n  // Scroll event handler\n  const handleScroll = useCallback(() => {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n    const {\n      scrollY\n    } = window;\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n  useEffect(() => {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, {\n        passive: true\n      });\n      return () => {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n  return currentHref;\n}","map":{"version":3,"names":["useCallback","useEffect","useState","isBrowser","window","useScrollSpy","_ref","hrefs","scrollSpyOffset","activeHref","currentHref","setCurrentHref","lastAnchorExists","setLastAnchorExists","document","getElementById","_a","length","slice","getRectByHref","href","getBoundingClientRect","isPageBottom","Math","ceil","scrollY","floor","body","scrollHeight","innerHeight","findHrefInView","find","rect","bottom","top","findLastHrefInView","reverse","handleScroll","undefined","addEventListener","passive","removeEventListener"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/anchor-navigation/use-scroll-spy.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useState } from 'react';\n\nconst isBrowser = typeof window !== 'undefined';\n\n/**\n * Hook to implement scroll-spy functionality.\n *\n * @param hrefs An array of href strings that correspond to the IDs of the target elements on the page.\n * The hrefs should be sorted in the order they appear on the page for accurate scroll-spy behavior.\n * @param scrollSpyOffset The number of pixels to offset from the top of the document when activating anchors.\n * Useful for accommodating fixed or sticky headers.\n * @param activeHref The currently active href. If provided, the hook will operate in a controlled manner,\n * and the scroll-spy logic will be disabled.\n *\n * @returns {string | undefined} - The href of the currently active element as per scroll position, or undefined if none is active.\n */\nexport default function useScrollSpy({\n  hrefs,\n  scrollSpyOffset,\n  activeHref,\n}: {\n  hrefs: string[];\n  scrollSpyOffset: number;\n  activeHref?: string;\n}): string | undefined {\n  const [currentHref, setCurrentHref] = useState<string | undefined>(activeHref);\n  const [lastAnchorExists, setLastAnchorExists] = useState(false);\n\n  useEffect(() => {\n    setCurrentHref(activeHref);\n  }, [activeHref]);\n\n  useEffect(() => {\n    setLastAnchorExists(isBrowser && !!document.getElementById(hrefs[hrefs.length - 1]?.slice(1)));\n  }, [hrefs]);\n\n  // Get the bounding rectangle of an element by href\n  const getRectByHref = useCallback((href: string) => {\n    return document.getElementById(href.slice(1))?.getBoundingClientRect();\n  }, []);\n\n  // Check if we're scrolled to the bottom of the page\n  const isPageBottom = useCallback(() => {\n    return lastAnchorExists && Math.ceil(window.scrollY) >= Math.floor(document.body.scrollHeight - window.innerHeight);\n  }, [lastAnchorExists]);\n\n  // Find the first href for which the element is within the viewport\n  const findHrefInView = useCallback(() => {\n    return hrefs.find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight && rect.top >= scrollSpyOffset;\n    });\n  }, [getRectByHref, scrollSpyOffset, hrefs]);\n\n  // Find the last href where its element is above or within the viewport\n  const findLastHrefInView = useCallback(() => {\n    return [...hrefs].reverse().find(href => {\n      const rect = getRectByHref(href);\n      return rect && rect.bottom <= window.innerHeight;\n    });\n  }, [getRectByHref, hrefs]);\n\n  // Scroll event handler\n  const handleScroll = useCallback(() => {\n    if (activeHref || !isBrowser) {\n      return;\n    }\n\n    const { scrollY } = window;\n\n    if (document.body.scrollHeight > window.innerHeight && isPageBottom()) {\n      setCurrentHref(hrefs[hrefs.length - 1]);\n    } else {\n      setCurrentHref(findHrefInView() || (scrollY > 0 ? findLastHrefInView() : undefined));\n    }\n  }, [activeHref, isPageBottom, findHrefInView, findLastHrefInView, hrefs]);\n\n  useEffect(() => {\n    if (isBrowser) {\n      handleScroll();\n      window.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        window.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [handleScroll]);\n\n  return currentHref;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}