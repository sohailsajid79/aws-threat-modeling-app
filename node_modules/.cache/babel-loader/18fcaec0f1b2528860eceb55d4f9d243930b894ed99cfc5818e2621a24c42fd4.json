{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useReducer } from \"react\";\nimport { getLogicalBoundingClientRect } from \"@cloudscape-design/component-toolkit/internal\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\nexport function useTransition(_ref) {\n  let {\n    isRtl\n  } = _ref;\n  return useReducer(createTransitionReducer({\n    isRtl\n  }), {\n    transition: null,\n    removeTransition: null,\n    announcement: null\n  });\n}\nexport function selectTransitionRows(state) {\n  return state.transition ? getLayoutRows(state.transition) : 0;\n}\nfunction createTransitionReducer(_ref2) {\n  let {\n    isRtl\n  } = _ref2;\n  return function transitionReducer(state, action) {\n    switch (action.type) {\n      case \"init\":\n        return initTransition(action);\n      case \"init-remove\":\n        return initRemoveTransition(action);\n      case \"submit\":\n        return submitTransition(state);\n      case \"discard\":\n        return discardTransition(state);\n      case \"update-with-pointer\":\n        return updateTransitionWithPointerEvent(state, action);\n      case \"update-with-keyboard\":\n        return updateTransitionWithKeyboardEvent(state, action, {\n          isRtl\n        });\n      case \"acquire-item\":\n        return acquireTransitionItem(state, action);\n    }\n  };\n}\nfunction initTransition(_ref3) {\n  let {\n    operation,\n    interactionType,\n    itemsLayout,\n    draggableItem,\n    draggableRect,\n    collisionIds\n  } = _ref3;\n  const transition = {\n    operation,\n    interactionType,\n    itemsLayout,\n    layoutEngine: new LayoutEngine(itemsLayout),\n    insertionDirection: null,\n    draggableItem,\n    draggableRect,\n    acquiredItem: null,\n    collisionIds: new Set(),\n    layoutShift: null,\n    path: []\n  };\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const layoutItem = itemsLayout.items.find(it => it.id === draggableItem.id);\n  let path = [];\n  if (interactionType === \"pointer\" || operation === \"insert\") {\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n    path = layoutItem ? appendPath([], collisionRect) : [];\n  } else if (layoutItem) {\n    path = operation === \"resize\" ? [new Position({\n      x: layoutItem.x + layoutItem.width,\n      y: layoutItem.y + layoutItem.height\n    })] : [new Position({\n      x: layoutItem.x,\n      y: layoutItem.y\n    })];\n  }\n  return {\n    transition: {\n      ...transition,\n      path\n    },\n    removeTransition: null,\n    announcement: layoutItem ? {\n      type: \"dnd-started\",\n      item: draggableItem,\n      operation\n    } : null\n  };\n}\nfunction initRemoveTransition(_ref4) {\n  let {\n    items,\n    removedItem,\n    itemsLayout\n  } = _ref4;\n  const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n  const removeTransition = {\n    items,\n    removedItem,\n    layoutShift\n  };\n  return {\n    transition: null,\n    removeTransition,\n    announcement: null\n  };\n}\nfunction submitTransition(state) {\n  var _a;\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    const disturbed = new Set(removeTransition.layoutShift.moves.map(move => move.itemId));\n    disturbed.delete(removeTransition.removedItem.id);\n    return {\n      transition: null,\n      removeTransition: null,\n      announcement: {\n        type: \"item-removed\",\n        item: removeTransition.removedItem,\n        disturbed\n      }\n    };\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return ((_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.conflicts.length) === 0 ? {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-committed\",\n      item,\n      operation\n    } : null\n  } : {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction discardTransition(state) {\n  const {\n    transition,\n    removeTransition\n  } = state;\n  if (removeTransition) {\n    throw new Error(\"Can't discard remove transition.\");\n  }\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    operation,\n    itemsLayout,\n    draggableItem: item,\n    acquiredItem\n  } = transition;\n  const itemBelongsToBoard = item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) || itemsLayout.items.some(it => it.id === item.id);\n  return {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? {\n      type: \"dnd-discarded\",\n      item,\n      operation\n    } : null\n  };\n}\nfunction updateTransitionWithPointerEvent(state, _ref5) {\n  let {\n    collisionIds,\n    positionOffset,\n    draggableRect\n  } = _ref5;\n  var _a, _b, _c;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n  const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n  const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n  const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n  const itemSize = itemWidth * itemHeight;\n  const isOutOfBoundaries = transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n  if (isOutOfBoundaries) {\n    return {\n      transition: {\n        ...transition,\n        draggableRect,\n        collisionIds: new Set(),\n        layoutShift: null,\n        insertionDirection: null\n      },\n      removeTransition: null,\n      announcement: null\n    };\n  }\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n  const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n  const path = appendPath(transition.path, collisionRect);\n  const insertionDirection = (_c = transition.insertionDirection) !== null && _c !== void 0 ? _c : getInsertionDirection(positionOffset);\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  return {\n    transition: {\n      ...transition,\n      draggableRect,\n      collisionIds: new Set(collisionIds),\n      layoutShift,\n      path,\n      insertionDirection\n    },\n    removeTransition: null,\n    announcement: null\n  };\n}\nfunction updateTransitionWithKeyboardEvent(state, _ref6, _ref7) {\n  let {\n    direction\n  } = _ref6;\n  let {\n    isRtl\n  } = _ref7;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const updateManualItemTransition = (transition, direction) => {\n    var _a, _b;\n    const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n    const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n    const lastPosition = transition.path[transition.path.length - 1];\n    const nextPosition = new Position({\n      x: lastPosition.x + xDelta,\n      y: lastPosition.y + yDelta\n    });\n    const nextPath = [...transition.path, nextPosition];\n    // Check resizing below min size.\n    const layout = (_b = (_a = transition.layoutShift) === null || _a === void 0 ? void 0 : _a.next) !== null && _b !== void 0 ? _b : transition.itemsLayout;\n    const layoutItem = layout.items.find(it => it.id === transition.draggableItem.id);\n    const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n    const minHeight = getMinRowSpan(transition.draggableItem);\n    if (transition.operation === \"resize\" && layoutItem && (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)) {\n      return state;\n    }\n    try {\n      const layoutShift = getLayoutShift(transition, nextPath);\n      const nextTransition = {\n        ...transition,\n        layoutShift,\n        path: nextPath\n      };\n      return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, direction)\n      };\n    } catch (e) {\n      // Can't create next layout because the next path is out of bounds.\n      return state;\n    }\n  };\n  switch (direction) {\n    case \"left\":\n      return updateManualItemTransition(transition, !isRtl() ? \"left\" : \"right\");\n    case \"right\":\n      return updateManualItemTransition(transition, !isRtl() ? \"right\" : \"left\");\n    case \"up\":\n      return updateManualItemTransition(transition, \"up\");\n    case \"down\":\n      return updateManualItemTransition(transition, \"down\");\n  }\n}\nfunction acquireTransitionItem(state, _ref8) {\n  let {\n    position,\n    layoutElement,\n    acquiredItemElement\n  } = _ref8;\n  const {\n    transition\n  } = state;\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n  const {\n    columns\n  } = transition.itemsLayout;\n  const layoutRect = getLogicalBoundingClientRect(layoutElement);\n  const itemRect = transition.draggableRect;\n  const coordinatesX = itemRect.left - layoutRect.insetInlineStart;\n  const offset = new Coordinates({\n    x: coordinatesX,\n    y: itemRect.top - layoutRect.insetBlockStart\n  });\n  const insertionDirection = getInsertionDirection(offset);\n  // Update original insertion position if the item can't fit into the layout by width.\n  const width = getDefaultColumnSpan(transition.draggableItem, columns);\n  position = new Position({\n    x: Math.min(columns - width, position.x),\n    y: position.y\n  });\n  const path = [...transition.path, position];\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n  // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n  const acquiredItem = {\n    ...transition.draggableItem,\n    columnOffset: 0,\n    columnSpan: 1,\n    rowSpan: 1\n  };\n  const nextTransition = {\n    ...transition,\n    collisionIds: new Set(),\n    layoutShift,\n    path,\n    acquiredItem,\n    acquiredItemElement\n  };\n  return {\n    transition: nextTransition,\n    removeTransition: null,\n    announcement: createOperationAnnouncement(nextTransition, null)\n  };\n}","map":{"version":3,"names":["useReducer","getLogicalBoundingClientRect","LayoutEngine","Coordinates","getDefaultColumnSpan","getDefaultRowSpan","getMinColumnSpan","getMinRowSpan","Position","createOperationAnnouncement","getHoveredRect","getInsertionDirection","getLayoutPlaceholders","getLayoutRows","getLayoutShift","appendMovePath","appendResizePath","useTransition","_ref","isRtl","createTransitionReducer","transition","removeTransition","announcement","selectTransitionRows","state","_ref2","transitionReducer","action","type","initTransition","initRemoveTransition","submitTransition","discardTransition","updateTransitionWithPointerEvent","updateTransitionWithKeyboardEvent","acquireTransitionItem","_ref3","operation","interactionType","itemsLayout","draggableItem","draggableRect","collisionIds","layoutEngine","insertionDirection","acquiredItem","Set","layoutShift","path","placeholdersLayout","layoutItem","items","find","it","id","collisionRect","appendPath","x","width","y","height","item","_ref4","removedItem","remove","disturbed","moves","map","move","itemId","delete","Error","itemBelongsToBoard","some","_a","conflicts","length","_ref5","positionOffset","layout","_b","next","itemWidth","columns","itemHeight","itemSize","isOutOfBoundaries","_c","_ref6","_ref7","direction","updateManualItemTransition","xDelta","yDelta","lastPosition","nextPosition","nextPath","minWidth","minHeight","nextTransition","e","_ref8","position","layoutElement","acquiredItemElement","layoutRect","itemRect","coordinatesX","left","insetInlineStart","offset","top","insetBlockStart","Math","min","columnOffset","columnSpan","rowSpan"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/board/transition.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Dispatch, ReactNode, useReducer } from \"react\";\n\nimport { getLogicalBoundingClientRect } from \"@cloudscape-design/component-toolkit/internal\";\n\nimport { InteractionType, Operation } from \"../internal/dnd-controller/controller\";\nimport { BoardItemDefinitionBase, Direction, GridLayout, ItemId, Rect } from \"../internal/interfaces\";\nimport { LayoutEngine } from \"../internal/layout-engine/engine\";\nimport { Coordinates } from \"../internal/utils/coordinates\";\nimport { getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { BoardProps, RemoveTransition, Transition, TransitionAnnouncement } from \"./interfaces\";\nimport { createOperationAnnouncement } from \"./utils/announcements\";\nimport { getHoveredRect } from \"./utils/get-hovered-rect\";\nimport { getInsertionDirection, getLayoutPlaceholders, getLayoutRows, getLayoutShift } from \"./utils/layout\";\nimport { appendMovePath, appendResizePath } from \"./utils/path\";\n\nexport interface TransitionState<D> {\n  transition: null | Transition<D>;\n  removeTransition: null | RemoveTransition<D>;\n  announcement: null | TransitionAnnouncement;\n}\n\nexport type Action<D> =\n  | InitAction<D>\n  | InitRemoveAction<D>\n  | SubmitAction\n  | DiscardAction\n  | UpdateWithPointerAction\n  | UpdateWithKeyboardAction\n  | AcquireItemAction;\n\ninterface InitAction<D> {\n  type: \"init\";\n  operation: Operation;\n  interactionType: InteractionType;\n  itemsLayout: GridLayout;\n  draggableItem: BoardItemDefinitionBase<D>;\n  draggableRect: Rect;\n  collisionIds: readonly ItemId[];\n}\ninterface InitRemoveAction<D> {\n  type: \"init-remove\";\n  items: readonly BoardProps.Item<D>[];\n  removedItem: BoardItemDefinitionBase<D>;\n  itemsLayout: GridLayout;\n}\ninterface SubmitAction {\n  type: \"submit\";\n}\ninterface DiscardAction {\n  type: \"discard\";\n}\ninterface UpdateWithPointerAction {\n  type: \"update-with-pointer\";\n  collisionIds: readonly ItemId[];\n  positionOffset: Coordinates;\n  draggableRect: Rect;\n}\ninterface UpdateWithKeyboardAction {\n  type: \"update-with-keyboard\";\n  direction: Direction;\n}\ninterface AcquireItemAction {\n  type: \"acquire-item\";\n  position: Position;\n  layoutElement: HTMLElement;\n  acquiredItemElement?: ReactNode;\n}\n\nexport function useTransition<D>({ isRtl }: { isRtl: () => boolean }): [TransitionState<D>, Dispatch<Action<D>>] {\n  return useReducer(createTransitionReducer<D>({ isRtl }), {\n    transition: null,\n    removeTransition: null,\n    announcement: null,\n  });\n}\n\nexport function selectTransitionRows<D>(state: TransitionState<D>) {\n  return state.transition ? getLayoutRows(state.transition) : 0;\n}\n\nfunction createTransitionReducer<D>({ isRtl }: { isRtl: () => boolean }) {\n  return function transitionReducer(state: TransitionState<D>, action: Action<D>): TransitionState<D> {\n    switch (action.type) {\n      case \"init\":\n        return initTransition(action);\n      case \"init-remove\":\n        return initRemoveTransition(action);\n      case \"submit\":\n        return submitTransition(state);\n      case \"discard\":\n        return discardTransition(state);\n      case \"update-with-pointer\":\n        return updateTransitionWithPointerEvent(state, action);\n      case \"update-with-keyboard\":\n        return updateTransitionWithKeyboardEvent(state, action, { isRtl });\n      case \"acquire-item\":\n        return acquireTransitionItem(state, action);\n    }\n  };\n}\n\nfunction initTransition<D>({\n  operation,\n  interactionType,\n  itemsLayout,\n  draggableItem,\n  draggableRect,\n  collisionIds,\n}: InitAction<D>): TransitionState<D> {\n  const transition: Transition<D> = {\n    operation,\n    interactionType,\n    itemsLayout,\n    layoutEngine: new LayoutEngine(itemsLayout),\n    insertionDirection: null,\n    draggableItem,\n    draggableRect,\n    acquiredItem: null,\n    collisionIds: new Set(),\n    layoutShift: null,\n    path: [],\n  };\n\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n\n  const layoutItem = itemsLayout.items.find((it) => it.id === draggableItem.id);\n\n  let path: Position[] = [];\n  if (interactionType === \"pointer\" || operation === \"insert\") {\n    const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n    const appendPath = operation === \"resize\" ? appendResizePath : appendMovePath;\n    path = layoutItem ? appendPath([], collisionRect) : [];\n  } else if (layoutItem) {\n    path =\n      operation === \"resize\"\n        ? [new Position({ x: layoutItem.x + layoutItem.width, y: layoutItem.y + layoutItem.height })]\n        : [new Position({ x: layoutItem.x, y: layoutItem.y })];\n  }\n\n  return {\n    transition: { ...transition, path },\n    removeTransition: null,\n    announcement: layoutItem ? { type: \"dnd-started\", item: draggableItem, operation } : null,\n  };\n}\n\nfunction initRemoveTransition<D>({ items, removedItem, itemsLayout }: InitRemoveAction<D>): TransitionState<D> {\n  const layoutShift = new LayoutEngine(itemsLayout).remove(removedItem.id);\n  const removeTransition: RemoveTransition<D> = { items, removedItem, layoutShift };\n  return { transition: null, removeTransition, announcement: null };\n}\n\nfunction submitTransition<D>(state: TransitionState<D>): TransitionState<D> {\n  const { transition, removeTransition } = state;\n\n  if (removeTransition) {\n    const disturbed = new Set(removeTransition.layoutShift.moves.map((move) => move.itemId));\n    disturbed.delete(removeTransition.removedItem.id);\n    return {\n      transition: null,\n      removeTransition: null,\n      announcement: { type: \"item-removed\", item: removeTransition.removedItem, disturbed },\n    };\n  }\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n  const itemBelongsToBoard = item.id === acquiredItem?.id || itemsLayout.items.some((it) => it.id === item.id);\n\n  return transition.layoutShift?.conflicts.length === 0\n    ? {\n        transition: null,\n        removeTransition: null,\n        announcement: itemBelongsToBoard ? { type: \"dnd-committed\", item, operation } : null,\n      }\n    : {\n        transition: null,\n        removeTransition: null,\n        announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n      };\n}\n\nfunction discardTransition<D>(state: TransitionState<D>): TransitionState<D> {\n  const { transition, removeTransition } = state;\n\n  if (removeTransition) {\n    throw new Error(\"Can't discard remove transition.\");\n  }\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { operation, itemsLayout, draggableItem: item, acquiredItem } = transition;\n  const itemBelongsToBoard = item.id === acquiredItem?.id || itemsLayout.items.some((it) => it.id === item.id);\n\n  return {\n    transition: null,\n    removeTransition: null,\n    announcement: itemBelongsToBoard ? { type: \"dnd-discarded\", item, operation } : null,\n  };\n}\n\nfunction updateTransitionWithPointerEvent<D>(\n  state: TransitionState<D>,\n  { collisionIds, positionOffset, draggableRect }: UpdateWithPointerAction,\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const layout = transition.layoutShift?.next ?? transition.itemsLayout;\n  const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n  const itemWidth = layoutItem ? layoutItem.width : getDefaultColumnSpan(transition.draggableItem, layout.columns);\n  const itemHeight = layoutItem ? layoutItem.height : getDefaultRowSpan(transition.draggableItem);\n  const itemSize = itemWidth * itemHeight;\n\n  const isOutOfBoundaries =\n    transition.operation !== \"resize\" ? collisionIds.length < itemSize : collisionIds.length === 0;\n\n  if (isOutOfBoundaries) {\n    return {\n      transition: {\n        ...transition,\n        draggableRect,\n        collisionIds: new Set(),\n        layoutShift: null,\n        insertionDirection: null,\n      },\n      removeTransition: null,\n      announcement: null,\n    };\n  }\n\n  const placeholdersLayout = getLayoutPlaceholders(transition);\n  const collisionRect = getHoveredRect(collisionIds, placeholdersLayout.items);\n  const appendPath = transition.operation === \"resize\" ? appendResizePath : appendMovePath;\n  const path = appendPath(transition.path, collisionRect);\n\n  const insertionDirection = transition.insertionDirection ?? getInsertionDirection(positionOffset);\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n\n  return {\n    transition: {\n      ...transition,\n      draggableRect,\n      collisionIds: new Set(collisionIds),\n      layoutShift,\n      path,\n      insertionDirection,\n    },\n    removeTransition: null,\n    announcement: null,\n  };\n}\n\nfunction updateTransitionWithKeyboardEvent<D>(\n  state: TransitionState<D>,\n  { direction }: UpdateWithKeyboardAction,\n  { isRtl }: { isRtl: () => boolean },\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const updateManualItemTransition = (transition: Transition<D>, direction: Direction): TransitionState<D> => {\n    const xDelta = direction === \"left\" ? -1 : direction === \"right\" ? 1 : 0;\n    const yDelta = direction === \"up\" ? -1 : direction === \"down\" ? 1 : 0;\n    const lastPosition = transition.path[transition.path.length - 1];\n    const nextPosition = new Position({ x: lastPosition.x + xDelta, y: lastPosition.y + yDelta });\n    const nextPath = [...transition.path, nextPosition];\n\n    // Check resizing below min size.\n    const layout = transition.layoutShift?.next ?? transition.itemsLayout;\n    const layoutItem = layout.items.find((it) => it.id === transition.draggableItem.id);\n    const minWidth = getMinColumnSpan(transition.draggableItem, transition.itemsLayout.columns);\n    const minHeight = getMinRowSpan(transition.draggableItem);\n    if (\n      transition.operation === \"resize\" &&\n      layoutItem &&\n      (layoutItem.width + xDelta < minWidth || layoutItem.height + yDelta < minHeight)\n    ) {\n      return state;\n    }\n\n    try {\n      const layoutShift = getLayoutShift(transition, nextPath);\n      const nextTransition = { ...transition, layoutShift, path: nextPath };\n      return {\n        transition: nextTransition,\n        removeTransition: null,\n        announcement: createOperationAnnouncement(nextTransition, direction),\n      };\n    } catch (e) {\n      // Can't create next layout because the next path is out of bounds.\n      return state;\n    }\n  };\n\n  switch (direction) {\n    case \"left\":\n      return updateManualItemTransition(transition, !isRtl() ? \"left\" : \"right\");\n    case \"right\":\n      return updateManualItemTransition(transition, !isRtl() ? \"right\" : \"left\");\n    case \"up\":\n      return updateManualItemTransition(transition, \"up\");\n    case \"down\":\n      return updateManualItemTransition(transition, \"down\");\n  }\n}\n\nfunction acquireTransitionItem<D>(\n  state: TransitionState<D>,\n  { position, layoutElement, acquiredItemElement }: AcquireItemAction,\n): TransitionState<D> {\n  const { transition } = state;\n\n  if (!transition) {\n    throw new Error(\"Invariant violation: no transition.\");\n  }\n\n  const { columns } = transition.itemsLayout;\n\n  const layoutRect = getLogicalBoundingClientRect(layoutElement);\n  const itemRect = transition.draggableRect;\n  const coordinatesX = itemRect.left - layoutRect.insetInlineStart;\n  const offset = new Coordinates({ x: coordinatesX, y: itemRect.top - layoutRect.insetBlockStart });\n  const insertionDirection = getInsertionDirection(offset);\n\n  // Update original insertion position if the item can't fit into the layout by width.\n  const width = getDefaultColumnSpan(transition.draggableItem, columns);\n  position = new Position({ x: Math.min(columns - width, position.x), y: position.y });\n\n  const path = [...transition.path, position];\n\n  const layoutShift = getLayoutShift(transition, path, insertionDirection);\n\n  // The columnOffset, columnSpan and rowSpan are of no use as of being overridden by the layout shift.\n  const acquiredItem = { ...transition.draggableItem, columnOffset: 0, columnSpan: 1, rowSpan: 1 };\n\n  const nextTransition: Transition<D> = {\n    ...transition,\n    collisionIds: new Set(),\n    layoutShift,\n    path,\n    acquiredItem,\n    acquiredItemElement,\n  };\n  return {\n    transition: nextTransition,\n    removeTransition: null,\n    announcement: createOperationAnnouncement(nextTransition, null),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}