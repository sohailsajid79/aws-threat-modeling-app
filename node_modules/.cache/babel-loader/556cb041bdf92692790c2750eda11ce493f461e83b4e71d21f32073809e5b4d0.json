{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getBreakpointValue } from '../../breakpoints';\nimport { getOverflowParentDimensions, getOverflowParents } from '../../utils/scrollable-containers';\nimport styles from './styles.css.js';\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\nconst getClosestParentDimensions = element => {\n  const parents = getOverflowParents(element).map(element => {\n    const {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart\n    } = getLogicalBoundingClientRect(element);\n    return {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart\n    };\n  });\n  return parents.shift();\n};\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\nexport const getAvailableSpace = ({\n  trigger,\n  overflowParents,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile\n}) => {\n  const availableSpaceReserveVertical = stretchHeight ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth ? 0 : isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd\n  } = getLogicalBoundingClientRect(trigger);\n  return overflowParents.reduce(({\n    blockStart,\n    blockEnd,\n    inlineStart,\n    inlineEnd\n  }, overflowParent) => {\n    const offsetTop = triggerBlockEnd - overflowParent.insetBlockStart;\n    const currentBlockStart = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n    const currentBlockEnd = overflowParent.blockSize - offsetTop - availableSpaceReserveVertical;\n    const currentInlineStart = triggerInlineEnd - overflowParent.insetInlineStart - availableSpaceReserveHorizontal;\n    const currentInlineEnd = overflowParent.insetInlineStart + overflowParent.inlineSize - triggerInlineStart - availableSpaceReserveHorizontal;\n    return {\n      blockStart: Math.min(blockStart, currentBlockStart),\n      blockEnd: Math.min(blockEnd, currentBlockEnd),\n      inlineStart: Math.min(inlineStart, currentInlineStart),\n      inlineEnd: Math.min(inlineEnd, currentInlineEnd)\n    };\n  }, {\n    blockStart: Number.MAX_VALUE,\n    blockEnd: Number.MAX_VALUE,\n    inlineStart: Number.MAX_VALUE,\n    inlineEnd: Number.MAX_VALUE\n  });\n};\nexport const getInteriorAvailableSpace = ({\n  trigger,\n  overflowParents,\n  isMobile\n}) => {\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd\n  } = getLogicalBoundingClientRect(trigger);\n  return overflowParents.reduce(({\n    blockStart,\n    blockEnd,\n    inlineStart,\n    inlineEnd\n  }, overflowParent) => {\n    const currentBlockStart = triggerBlockEnd - overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentBlockEnd = overflowParent.blockSize - triggerBlockStart + overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n    const currentInlineStart = triggerInlineStart - overflowParent.insetInlineStart - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    const currentInlineEnd = overflowParent.insetInlineStart + overflowParent.inlineSize - triggerInlineEnd - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n    return {\n      blockStart: Math.min(blockStart, currentBlockStart),\n      blockEnd: Math.min(blockEnd, currentBlockEnd),\n      inlineStart: Math.min(inlineStart, currentInlineStart),\n      inlineEnd: Math.min(inlineEnd, currentInlineEnd)\n    };\n  }, {\n    blockStart: Number.MAX_VALUE,\n    blockEnd: Number.MAX_VALUE,\n    inlineStart: Number.MAX_VALUE,\n    inlineEnd: Number.MAX_VALUE\n  });\n};\nexport const getWidths = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  stretchBeyondTriggerWidth = false\n}) => {\n  // Determine the width of the trigger\n  const {\n    inlineSize: triggerInlineSize\n  } = getLogicalBoundingClientRect(triggerElement);\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerInlineSize, desiredMinWidth) : triggerInlineSize;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerInlineSize) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const {\n    inlineSize: requiredWidth\n  } = getLogicalBoundingClientRect(dropdownElement);\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return {\n    idealWidth,\n    minWidth,\n    triggerInlineSize\n  };\n};\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  expandToViewport,\n  stretchWidth,\n  stretchHeight,\n  isMobile\n}) => {\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const {\n    idealWidth\n  } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  return idealWidth <= availableSpace.inlineStart || idealWidth <= availableSpace.inlineEnd;\n};\nexport const getDropdownPosition = ({\n  triggerElement,\n  dropdownElement,\n  overflowParents,\n  minWidth: desiredMinWidth,\n  preferCenter = false,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile = false,\n  stretchBeyondTriggerWidth = false\n}) => {\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile\n  });\n  const {\n    idealWidth,\n    minWidth,\n    triggerInlineSize\n  } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth\n  });\n  let dropInlineStart;\n  let insetInlineStart = null;\n  let inlineSize = idealWidth;\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd, minWidth);\n  }\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerInlineSize) / 2;\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.inlineStart - triggerInlineSize;\n    const availableOutsideRight = availableSpace.inlineEnd - triggerInlineSize;\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      insetInlineStart = -spillOver;\n    }\n  }\n  const dropBlockStart = availableSpace.blockEnd < dropdownElement.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    insetInlineStart: insetInlineStart === null ? 'auto' : `${insetInlineStart}px`,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`\n  };\n};\nexport const getInteriorDropdownPosition = (trigger, dropdown, overflowParents, isMobile) => {\n  const availableSpace = getInteriorAvailableSpace({\n    trigger,\n    overflowParents,\n    isMobile\n  });\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    inlineSize: triggerInlineSize\n  } = getLogicalBoundingClientRect(trigger);\n  const {\n    insetBlockStart: parentDropdownBlockStart,\n    blockSize: parentDropdownHeight\n  } = getClosestParentDimensions(trigger);\n  let dropInlineStart;\n  let {\n    inlineSize\n  } = getLogicalBoundingClientRect(dropdown);\n  const insetBlockStart = triggerBlockStart - parentDropdownBlockStart;\n  if (inlineSize <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n  } else if (inlineSize <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd);\n  }\n  const insetInlineStart = dropInlineStart ? 0 - inlineSize : triggerInlineSize;\n  const dropBlockStart = availableSpace.blockEnd < dropdown.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const insetBlockEnd = dropBlockStart ? parentDropdownBlockStart + parentDropdownHeight - triggerBlockEnd : 0;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n    insetBlockStart: `${insetBlockStart}px`,\n    insetBlockEnd: `${insetBlockEnd}px`,\n    insetInlineStart: `${insetInlineStart}px`\n  };\n};\nexport const calculatePosition = (dropdownElement, triggerElement, verticalContainerElement, interior, expandToViewport, preferCenter, stretchWidth, stretchHeight, isMobile, minWidth, stretchBeyondTriggerWidth) => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxBlockSize = '';\n  dropdownElement.style.inlineSize = '';\n  dropdownElement.style.insetBlockStart = '';\n  dropdownElement.style.insetBlockEnd = '';\n  dropdownElement.style.insetInlineStart = '';\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight\n  });\n  const position = interior ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile) : getDropdownPosition({\n    triggerElement,\n    dropdownElement,\n    overflowParents,\n    minWidth,\n    preferCenter,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n    stretchBeyondTriggerWidth\n  });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};","map":{"version":3,"names":["getLogicalBoundingClientRect","getBreakpointValue","getOverflowParentDimensions","getOverflowParents","styles","AVAILABLE_SPACE_RESERVE_DEFAULT","AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL","AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL","getClosestParentDimensions","element","parents","map","blockSize","inlineSize","insetBlockStart","insetInlineStart","shift","defaultMaxDropdownWidth","getAvailableSpace","trigger","overflowParents","stretchWidth","stretchHeight","isMobile","availableSpaceReserveVertical","availableSpaceReserveHorizontal","insetBlockEnd","triggerBlockEnd","triggerInlineStart","insetInlineEnd","triggerInlineEnd","reduce","blockStart","blockEnd","inlineStart","inlineEnd","overflowParent","offsetTop","currentBlockStart","offsetHeight","currentBlockEnd","currentInlineStart","currentInlineEnd","Math","min","Number","MAX_VALUE","getInteriorAvailableSpace","AVAILABLE_SPACE_RESERVE_VERTICAL","AVAILABLE_SPACE_RESERVE_HORIZONTAL","triggerBlockStart","getWidths","triggerElement","dropdownElement","desiredMinWidth","stretchBeyondTriggerWidth","triggerInlineSize","minWidth","maxWidth","max","requiredWidth","idealWidth","hasEnoughSpaceToStretchBeyondTriggerWidth","expandToViewport","excludeClosestParent","canExpandOutsideViewport","availableSpace","getDropdownPosition","preferCenter","dropInlineStart","spillOver","availableOutsideLeft","availableOutsideRight","fitsInCenter","dropBlockStart","availableHeight","croppedHeight","floor","getInteriorDropdownPosition","dropdown","parentDropdownBlockStart","parentDropdownHeight","calculatePosition","verticalContainerElement","interior","style","maxBlockSize","classList","remove","position","triggerBox","getBoundingClientRect"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/components/dropdown/dropdown-fit-handler.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getBreakpointValue } from '../../breakpoints';\nimport { BoundingBox, getOverflowParentDimensions, getOverflowParents } from '../../utils/scrollable-containers';\n\nimport styles from './styles.css.js';\n\nconst AVAILABLE_SPACE_RESERVE_DEFAULT = 50;\nconst AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL = 19; // 50 - 31\nconst AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL = 20;\n\ninterface AvailableSpace {\n  blockStart: number;\n  blockEnd: number;\n  inlineStart: number;\n  inlineEnd: number;\n}\nexport interface DropdownPosition {\n  blockSize: string;\n  inlineSize: string;\n  dropBlockStart: boolean;\n  dropInlineStart: boolean;\n  insetInlineStart: string;\n}\nexport interface InteriorDropdownPosition extends DropdownPosition {\n  insetBlockEnd: string;\n  insetBlockStart: string;\n}\n\nconst getClosestParentDimensions = (element: HTMLElement): any => {\n  const parents = getOverflowParents(element).map(element => {\n    const { blockSize, inlineSize, insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(element);\n    return {\n      blockSize,\n      inlineSize,\n      insetBlockStart,\n      insetInlineStart,\n    };\n  });\n\n  return parents.shift();\n};\n\n// By default, most dropdowns should expand their content as necessary, but to a maximum of 465px (the XXS breakpoint).\n// This value was determined by UX but may be subject to change in the future, depending on the feedback.\nexport const defaultMaxDropdownWidth = getBreakpointValue('xxs');\n\nexport const getAvailableSpace = ({\n  trigger,\n  overflowParents,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const availableSpaceReserveVertical = stretchHeight\n    ? 0\n    : isMobile\n      ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n      : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const availableSpaceReserveHorizontal = stretchWidth\n    ? 0\n    : isMobile\n      ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n      : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd,\n  } = getLogicalBoundingClientRect(trigger);\n\n  return overflowParents.reduce(\n    ({ blockStart, blockEnd, inlineStart, inlineEnd }, overflowParent) => {\n      const offsetTop = triggerBlockEnd - overflowParent.insetBlockStart;\n      const currentBlockStart = offsetTop - trigger.offsetHeight - availableSpaceReserveVertical;\n      const currentBlockEnd = overflowParent.blockSize - offsetTop - availableSpaceReserveVertical;\n      const currentInlineStart = triggerInlineEnd - overflowParent.insetInlineStart - availableSpaceReserveHorizontal;\n      const currentInlineEnd =\n        overflowParent.insetInlineStart +\n        overflowParent.inlineSize -\n        triggerInlineStart -\n        availableSpaceReserveHorizontal;\n\n      return {\n        blockStart: Math.min(blockStart, currentBlockStart),\n        blockEnd: Math.min(blockEnd, currentBlockEnd),\n        inlineStart: Math.min(inlineStart, currentInlineStart),\n        inlineEnd: Math.min(inlineEnd, currentInlineEnd),\n      };\n    },\n    {\n      blockStart: Number.MAX_VALUE,\n      blockEnd: Number.MAX_VALUE,\n      inlineStart: Number.MAX_VALUE,\n      inlineEnd: Number.MAX_VALUE,\n    }\n  );\n};\n\nexport const getInteriorAvailableSpace = ({\n  trigger,\n  overflowParents,\n  isMobile,\n}: {\n  trigger: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  isMobile?: boolean;\n}): AvailableSpace => {\n  const AVAILABLE_SPACE_RESERVE_VERTICAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_VERTICAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const AVAILABLE_SPACE_RESERVE_HORIZONTAL = isMobile\n    ? AVAILABLE_SPACE_RESERVE_MOBILE_HORIZONTAL\n    : AVAILABLE_SPACE_RESERVE_DEFAULT;\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    insetInlineStart: triggerInlineStart,\n    insetInlineEnd: triggerInlineEnd,\n  } = getLogicalBoundingClientRect(trigger);\n\n  return overflowParents.reduce(\n    ({ blockStart, blockEnd, inlineStart, inlineEnd }, overflowParent) => {\n      const currentBlockStart = triggerBlockEnd - overflowParent.insetBlockStart - AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentBlockEnd =\n        overflowParent.blockSize -\n        triggerBlockStart +\n        overflowParent.insetBlockStart -\n        AVAILABLE_SPACE_RESERVE_VERTICAL;\n      const currentInlineStart =\n        triggerInlineStart - overflowParent.insetInlineStart - AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n      const currentInlineEnd =\n        overflowParent.insetInlineStart +\n        overflowParent.inlineSize -\n        triggerInlineEnd -\n        AVAILABLE_SPACE_RESERVE_HORIZONTAL;\n\n      return {\n        blockStart: Math.min(blockStart, currentBlockStart),\n        blockEnd: Math.min(blockEnd, currentBlockEnd),\n        inlineStart: Math.min(inlineStart, currentInlineStart),\n        inlineEnd: Math.min(inlineEnd, currentInlineEnd),\n      };\n    },\n    {\n      blockStart: Number.MAX_VALUE,\n      blockEnd: Number.MAX_VALUE,\n      inlineStart: Number.MAX_VALUE,\n      inlineEnd: Number.MAX_VALUE,\n    }\n  );\n};\n\nexport const getWidths = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  stretchBeyondTriggerWidth?: boolean;\n}) => {\n  // Determine the width of the trigger\n  const { inlineSize: triggerInlineSize } = getLogicalBoundingClientRect(triggerElement);\n  // Minimum width is determined by either an explicit number (desiredMinWidth) or the trigger width\n  const minWidth = desiredMinWidth ? Math.min(triggerInlineSize, desiredMinWidth) : triggerInlineSize;\n  // If stretchBeyondTriggerWidth is true, the maximum width is the XS breakpoint (465px) or the trigger width (if bigger).\n  const maxWidth = stretchBeyondTriggerWidth ? Math.max(defaultMaxDropdownWidth, triggerInlineSize) : Number.MAX_VALUE;\n  // Determine the actual dropdown width, the size that it \"wants\" to be\n  const { inlineSize: requiredWidth } = getLogicalBoundingClientRect(dropdownElement);\n  // Try to achieve the required/desired width within the given parameters\n  const idealWidth = Math.min(Math.max(requiredWidth, minWidth), maxWidth);\n  return { idealWidth, minWidth, triggerInlineSize };\n};\n\nexport const hasEnoughSpaceToStretchBeyondTriggerWidth = ({\n  triggerElement,\n  dropdownElement,\n  desiredMinWidth,\n  expandToViewport,\n  stretchWidth,\n  stretchHeight,\n  isMobile,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  desiredMinWidth?: number;\n  expandToViewport: boolean;\n  stretchWidth: boolean;\n  stretchHeight: boolean;\n  isMobile: boolean;\n}) => {\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: false,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const { idealWidth } = getWidths({\n    triggerElement: triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth: true,\n  });\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  return idealWidth <= availableSpace.inlineStart || idealWidth <= availableSpace.inlineEnd;\n};\n\nexport const getDropdownPosition = ({\n  triggerElement,\n  dropdownElement,\n  overflowParents,\n  minWidth: desiredMinWidth,\n  preferCenter = false,\n  stretchWidth = false,\n  stretchHeight = false,\n  isMobile = false,\n  stretchBeyondTriggerWidth = false,\n}: {\n  triggerElement: HTMLElement;\n  dropdownElement: HTMLElement;\n  overflowParents: ReadonlyArray<BoundingBox>;\n  minWidth?: number;\n  preferCenter?: boolean;\n  stretchWidth?: boolean;\n  stretchHeight?: boolean;\n  isMobile?: boolean;\n  stretchBeyondTriggerWidth?: boolean;\n}): DropdownPosition => {\n  // Determine the space available around the dropdown that it can grow in\n  const availableSpace = getAvailableSpace({\n    trigger: triggerElement,\n    overflowParents,\n    stretchWidth,\n    stretchHeight,\n    isMobile,\n  });\n  const { idealWidth, minWidth, triggerInlineSize } = getWidths({\n    triggerElement,\n    dropdownElement,\n    desiredMinWidth,\n    stretchBeyondTriggerWidth,\n  });\n\n  let dropInlineStart: boolean;\n  let insetInlineStart: number | null = null;\n  let inlineSize = idealWidth;\n\n  //1. Can it be positioned with ideal width to the right?\n  if (idealWidth <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n    //2. Can it be positioned with ideal width to the left?\n  } else if (idealWidth <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n    //3. Fit into biggest available space either on left or right\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd, minWidth);\n  }\n\n  if (preferCenter) {\n    const spillOver = (idealWidth - triggerInlineSize) / 2;\n\n    // availableSpace always includes the trigger width, but we want to exclude that\n    const availableOutsideLeft = availableSpace.inlineStart - triggerInlineSize;\n    const availableOutsideRight = availableSpace.inlineEnd - triggerInlineSize;\n\n    const fitsInCenter = availableOutsideLeft >= spillOver && availableOutsideRight >= spillOver;\n    if (fitsInCenter) {\n      insetInlineStart = -spillOver;\n    }\n  }\n\n  const dropBlockStart =\n    availableSpace.blockEnd < dropdownElement.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = stretchHeight ? availableHeight : Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    insetInlineStart: insetInlineStart === null ? 'auto' : `${insetInlineStart}px`,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n  };\n};\n\nexport const getInteriorDropdownPosition = (\n  trigger: HTMLElement,\n  dropdown: HTMLElement,\n  overflowParents: ReadonlyArray<BoundingBox>,\n  isMobile?: boolean\n): InteriorDropdownPosition => {\n  const availableSpace = getInteriorAvailableSpace({ trigger, overflowParents, isMobile });\n  const {\n    insetBlockEnd: triggerBlockEnd,\n    insetBlockStart: triggerBlockStart,\n    inlineSize: triggerInlineSize,\n  } = getLogicalBoundingClientRect(trigger);\n  const { insetBlockStart: parentDropdownBlockStart, blockSize: parentDropdownHeight } =\n    getClosestParentDimensions(trigger);\n\n  let dropInlineStart;\n\n  let { inlineSize } = getLogicalBoundingClientRect(dropdown);\n  const insetBlockStart = triggerBlockStart - parentDropdownBlockStart;\n  if (inlineSize <= availableSpace.inlineEnd) {\n    dropInlineStart = false;\n  } else if (inlineSize <= availableSpace.inlineStart) {\n    dropInlineStart = true;\n  } else {\n    dropInlineStart = availableSpace.inlineStart > availableSpace.inlineEnd;\n    inlineSize = Math.max(availableSpace.inlineStart, availableSpace.inlineEnd);\n  }\n\n  const insetInlineStart = dropInlineStart ? 0 - inlineSize : triggerInlineSize;\n\n  const dropBlockStart =\n    availableSpace.blockEnd < dropdown.offsetHeight && availableSpace.blockStart > availableSpace.blockEnd;\n  const insetBlockEnd = dropBlockStart ? parentDropdownBlockStart + parentDropdownHeight - triggerBlockEnd : 0;\n  const availableHeight = dropBlockStart ? availableSpace.blockStart : availableSpace.blockEnd;\n  // Try and crop the bottom item when all options can't be displayed, affordance for \"there's more\"\n  const croppedHeight = Math.floor(availableHeight / 31) * 31 + 16;\n\n  return {\n    dropBlockStart,\n    dropInlineStart,\n    blockSize: `${croppedHeight}px`,\n    inlineSize: `${inlineSize}px`,\n    insetBlockStart: `${insetBlockStart}px`,\n    insetBlockEnd: `${insetBlockEnd}px`,\n    insetInlineStart: `${insetInlineStart}px`,\n  };\n};\n\nexport const calculatePosition = (\n  dropdownElement: HTMLDivElement,\n  triggerElement: HTMLDivElement,\n  verticalContainerElement: HTMLDivElement,\n  interior: boolean,\n  expandToViewport: boolean,\n  preferCenter: boolean,\n  stretchWidth: boolean,\n  stretchHeight: boolean,\n  isMobile: boolean,\n  minWidth?: number,\n  stretchBeyondTriggerWidth?: boolean\n): [DropdownPosition, DOMRect] => {\n  // cleaning previously assigned values,\n  // so that they are not reused in case of screen resize and similar events\n  verticalContainerElement.style.maxBlockSize = '';\n  dropdownElement.style.inlineSize = '';\n  dropdownElement.style.insetBlockStart = '';\n  dropdownElement.style.insetBlockEnd = '';\n  dropdownElement.style.insetInlineStart = '';\n\n  dropdownElement.classList.remove(styles['dropdown-drop-left']);\n  dropdownElement.classList.remove(styles['dropdown-drop-right']);\n  dropdownElement.classList.remove(styles['dropdown-drop-up']);\n\n  const overflowParents = getOverflowParentDimensions({\n    element: dropdownElement,\n    excludeClosestParent: interior,\n    expandToViewport,\n    canExpandOutsideViewport: stretchHeight,\n  });\n  const position = interior\n    ? getInteriorDropdownPosition(triggerElement, dropdownElement, overflowParents, isMobile)\n    : getDropdownPosition({\n        triggerElement,\n        dropdownElement,\n        overflowParents,\n        minWidth,\n        preferCenter,\n        stretchWidth,\n        stretchHeight,\n        isMobile,\n        stretchBeyondTriggerWidth,\n      });\n  const triggerBox = triggerElement.getBoundingClientRect();\n  return [position, triggerBox];\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}