{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, useCallback, useContext, useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getOffsetInlineStart } from '@cloudscape-design/component-toolkit/internal';\nimport { DynamicOverlapContext } from '../../internal/context/dynamic-overlap-context';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { SPLIT_PANEL_MIN_WIDTH } from '../split-panel';\nimport { checkSplitPanelForcedPosition } from '../split-panel/split-panel-utils';\nimport { useDrawers } from '../utils/use-drawers';\nimport { useFocusControl } from '../utils/use-focus-control';\nimport useResize from '../utils/use-resize';\nimport { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { getSplitPanelPosition } from './split-panel';\nimport useBackgroundOverlap from './use-background-overlap';\nimport styles from './styles.css.js';\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\nconst AppLayoutInternalsContext = createContext(null);\nexport function useAppLayoutInternals() {\n  const ctx = useContext(AppLayoutInternalsContext);\n  if (!ctx) {\n    throw new Error('Invariant violation: this context is only available inside app layout');\n  }\n  return ctx;\n}\nexport const AppLayoutInternalsProvider = React.forwardRef((props, forwardRef) => {\n  var _a, _b, _c, _d, _e;\n  const {\n    toolsHide,\n    toolsOpen: controlledToolsOpen,\n    navigationHide,\n    navigationOpen,\n    contentType,\n    placement,\n    children,\n    splitPanel\n  } = props;\n  const isMobile = useMobile();\n  // Private API for embedded view mode\n  const __embeddedViewMode = Boolean(props.__embeddedViewMode);\n  /**\n   * Set the default values for minimum and maximum content width.\n   */\n  const geckoMaxCssLength = ((1 << 30) - 1) / 60;\n  const halfGeckoMaxCssLength = geckoMaxCssLength / 2;\n  // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n  // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n  const maxContentWidth = props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength ? halfGeckoMaxCssLength : (_a = props.maxContentWidth) !== null && _a !== void 0 ? _a : 0;\n  const minContentWidth = (_b = props.minContentWidth) !== null && _b !== void 0 ? _b : 280;\n  const {\n    refs: navigationRefs,\n    setFocus: focusNavButtons\n  } = useFocusControl(navigationOpen);\n  const handleNavigationClick = useStableCallback(function handleNavigationChange(isOpen) {\n    focusNavButtons();\n    fireNonCancelableEvent(props.onNavigationChange, {\n      open: isOpen\n    });\n  });\n  useEffect(() => {\n    // Close navigation drawer on mobile so that the main content is visible\n    if (isMobile) {\n      handleNavigationClick(false);\n    }\n  }, [isMobile, handleNavigationClick]);\n  const toolsWidth = props.toolsWidth;\n  const [isToolsOpen = false, setIsToolsOpen] = useControllable(controlledToolsOpen, props.onToolsChange, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  });\n  const {\n    refs: toolsRefs,\n    setFocus: focusToolsButtons,\n    loseFocus: loseToolsFocus\n  } = useFocusControl(isToolsOpen, true);\n  const handleToolsClick = useCallback(function handleToolsChange(isOpen, skipFocusControl) {\n    setIsToolsOpen(isOpen);\n    !skipFocusControl && focusToolsButtons();\n    fireNonCancelableEvent(props.onToolsChange, {\n      open: isOpen\n    });\n  }, [props.onToolsChange, setIsToolsOpen, focusToolsButtons]);\n  /**\n   * Set the default values for the minimum and maximum Split Panel width when it is\n   * in the side position. The useLayoutEffect will compute the available space in the\n   * DOM for the Split Panel given the current state. The minimum and maximum\n   * widths will potentially trigger a side effect that will put the Split Panel into\n   * a forced position on the bottom.\n   */\n  const [splitPanelMaxWidth, setSplitPanelMaxWidth] = useState(SPLIT_PANEL_MIN_WIDTH);\n  /**\n   * The useControllable hook will set the default value and manage either\n   * the controlled or uncontrolled state of the Split Panel. By default\n   * the Split Panel should always be closed on page load.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the click events that will change the state of the SplitPanel\n   * to open or closed given the current state. It will set the isSplitPanelOpen\n   * controlled state and fire the onSplitPanelToggle event.\n   */\n  const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(props.splitPanelOpen, props.onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  });\n  /**\n   * The useControllable hook will manage the controlled or uncontrolled\n   * state of the splitPanelPreferences. By default the splitPanelPreferences\n   * is undefined. When set the object shape should have a single key to indicate\n   * either bottom or side position.\n   *\n   * The callback that will handle changes to the splitPanelPreferences\n   * object that will determine if the SplitPanel is rendered either on the\n   * bottom of the viewport or within the Tools container.\n   */\n  const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(props.splitPanelPreferences, props.onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  });\n  const {\n    refs: splitPanelRefs,\n    setLastInteraction: setSplitPanelLastInteraction\n  } = useSplitPanelFocusControl([splitPanelPreferences, isSplitPanelOpen]);\n  const handleSplitPanelClick = useCallback(function handleSplitPanelChange() {\n    setIsSplitPanelOpen(!isSplitPanelOpen);\n    setSplitPanelLastInteraction({\n      type: isSplitPanelOpen ? 'close' : 'open'\n    });\n    fireNonCancelableEvent(props.onSplitPanelToggle, {\n      open: !isSplitPanelOpen\n    });\n  }, [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen, setSplitPanelLastInteraction]);\n  const isSplitPanelForcedPosition = checkSplitPanelForcedPosition({\n    isMobile,\n    splitPanelMaxWidth\n  });\n  const splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n  /**\n   * The useControllable hook will set the default size of the SplitPanel based\n   * on the default position set in the splitPanelPreferences. The logic for the\n   * default size is contained in the SplitPanel component. The splitPanelControlledSize\n   * will be bound to the size property in the SplitPanel context for rendering.\n   *\n   * The callback that will be passed to the SplitPanel component\n   * to handle the resize events that will change the size of the SplitPanel.\n   * It will set the splitPanelControlledSize controlled state and fire the\n   * onSplitPanelResize event.\n   */\n  const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n  const [splitPanelReportedHeaderHeight, setSplitPanelReportedHeaderHeight] = useState(0);\n  const [splitPanelToggle, setSplitPanelToggle] = useState({\n    displayed: false,\n    ariaLabel: undefined\n  });\n  const splitPanelDisplayed = !!(splitPanelToggle.displayed || isSplitPanelOpen) && !!splitPanel;\n  const splitPanelControlId = useUniqueId('split-panel-');\n  const toolsControlId = useUniqueId('tools-');\n  const [splitPanelSize, setSplitPanelSize] = useControllable(props.splitPanelSize, props.onSplitPanelResize, getSplitPanelDefaultSize(splitPanelPosition), {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  });\n  const handleSplitPanelResize = useCallback(size => {\n    setSplitPanelSize(size);\n    fireNonCancelableEvent(props.onSplitPanelResize, {\n      size\n    });\n  }, [props.onSplitPanelResize, setSplitPanelSize]);\n  const handleSplitPanelPreferencesChange = useCallback(function handleSplitPanelChange(detail) {\n    setSplitPanelPreferences(detail);\n    setSplitPanelLastInteraction({\n      type: 'position'\n    });\n    fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n  }, [props.onSplitPanelPreferencesChange, setSplitPanelPreferences, setSplitPanelLastInteraction]);\n  const _f = useDrawers(props, props.ariaLabels, {\n      disableDrawersMerge: true,\n      ariaLabels: props.ariaLabels,\n      toolsHide,\n      toolsOpen: isToolsOpen,\n      tools: props.tools,\n      toolsWidth,\n      onToolsToggle: handleToolsClick\n    }),\n    {\n      drawers,\n      activeDrawer,\n      activeDrawerId,\n      minDrawerSize: drawersMinWidth,\n      onActiveDrawerChange,\n      onActiveDrawerResize,\n      activeDrawerSize\n    } = _f,\n    drawersProps = __rest(_f, [\"drawers\", \"activeDrawer\", \"activeDrawerId\", \"minDrawerSize\", \"onActiveDrawerChange\", \"onActiveDrawerResize\", \"activeDrawerSize\"]);\n  const [drawersMaxWidth, setDrawersMaxWidth] = useState(toolsWidth);\n  const hasDrawers = !!drawers && drawers.length > 0;\n  const {\n    refs: drawersRefs,\n    setFocus: focusDrawersButtons,\n    loseFocus: loseDrawersFocus\n  } = useFocusControl(!!activeDrawerId, true, activeDrawerId);\n  const drawerRef = useRef(null);\n  const {\n    resizeHandle,\n    drawerSize\n  } = useResize(drawerRef, {\n    onActiveDrawerResize,\n    activeDrawerSize,\n    activeDrawer,\n    drawersRefs,\n    isToolsOpen,\n    drawersMaxWidth,\n    drawersMinWidth\n  });\n  const handleDrawersClick = (id, skipFocusControl) => {\n    const newActiveDrawerId = id !== activeDrawerId ? id : null;\n    onActiveDrawerChange(newActiveDrawerId);\n    !skipFocusControl && focusDrawersButtons();\n  };\n  let drawersTriggerCount = drawers ? drawers.length : !toolsHide ? 1 : 0;\n  if (splitPanelDisplayed && splitPanelPosition === 'side') {\n    drawersTriggerCount++;\n  }\n  const hasOpenDrawer = !!activeDrawerId || !toolsHide && isToolsOpen || splitPanelDisplayed && splitPanelPosition === 'side' && isSplitPanelOpen;\n  const hasDrawerViewportOverlay = isMobile && (!!activeDrawerId || !navigationHide && navigationOpen || !toolsHide && isToolsOpen);\n  const layoutElement = useRef(null);\n  const mainElement = useRef(null);\n  const [mainOffsetLeft, setMainOffsetLeft] = useState(0);\n  const {\n    hasBackgroundOverlap,\n    updateBackgroundOverlapHeight\n  } = useBackgroundOverlap({\n    contentHeader: props.contentHeader,\n    disableContentHeaderOverlap: props.disableContentHeaderOverlap,\n    layoutElement\n  });\n  useLayoutEffect(function handleMainOffsetLeft() {\n    const offsetInlineStart = (mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) ? getOffsetInlineStart(mainElement === null || mainElement === void 0 ? void 0 : mainElement.current) : 0;\n    setMainOffsetLeft(offsetInlineStart);\n  }, [placement.inlineSize, navigationOpen, isToolsOpen, splitPanelReportedSize]);\n  /**\n   * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n   * that consumes 100% of the viewport height and width. The body content could potentially\n   * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n   * added to the document body that sets overflow to hidden.\n   */\n  useEffect(function handleBodyScroll() {\n    if (isMobile && (navigationOpen || isToolsOpen || !!activeDrawer)) {\n      document.body.classList.add(styles['block-body-scroll']);\n    } else {\n      document.body.classList.remove(styles['block-body-scroll']);\n    }\n    // Ensure the CSS class is removed from the body on side effect cleanup\n    return function cleanup() {\n      document.body.classList.remove(styles['block-body-scroll']);\n    };\n  }, [isMobile, navigationOpen, isToolsOpen, activeDrawer]);\n  const [notificationsHeight, setNotificationsHeight] = useState(0);\n  const hasNotificationsContent = notificationsHeight > 0;\n  /**\n   * Determine the offsetBottom value based on the presence of a footer element and\n   * the SplitPanel component. Ignore the SplitPanel if it is not in the bottom\n   * position. Use the size property if it is open and the header height if it is closed.\n   */\n  let offsetBottom = placement.insetBlockEnd;\n  if (splitPanelDisplayed && splitPanelPosition === 'bottom') {\n    if (isSplitPanelOpen) {\n      offsetBottom += splitPanelReportedSize;\n    } else {\n      offsetBottom += splitPanelReportedHeaderHeight;\n    }\n  }\n  /**\n   * Warning! This is a hack! In order to accurately calculate if there is adequate\n   * horizontal space for the Split Panel to be in the side position we need two values\n   * that are not available in JavaScript.\n   *\n   * The first is the the content gap on the right which is stored in a design token\n   * and applied in the Layout CSS:\n   *\n   * $contentGapRight: #{awsui.$space-layout-content-horizontal};\n   *\n   * The second is the width of the element that has the circular buttons for the\n   * Tools and Split Panel. This could be suppressed given the state of the Tools\n   * drawer returning a zero value. It would, however, be rendered if the Split Panel\n   * were to move into the side position. This is calculated in the Tools CSS and\n   * the Trigger button CSS with design tokens:\n   *\n   * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n   * width: awsui.$space-layout-toggle-diameter;\n   *\n   * These values will be defined below as static integers that are rough approximations\n   * of their computed width when rendered in the DOM, but doubled to ensure adequate\n   * spacing for the Split Panel to be in side position.\n   */\n  useLayoutEffect(function handleSplitPanelMaxWidth() {\n    const contentGapRight = 50; // Approximately 24px when rendered but doubled for safety\n    const toolsFormOffsetWidth = 120; // Approximately 60px when rendered but doubled for safety\n    const getPanelOffsetWidth = () => {\n      if (drawers) {\n        return activeDrawerId ? drawerSize : 0;\n      }\n      return isToolsOpen ? toolsWidth : 0;\n    };\n    setSplitPanelMaxWidth(placement.inlineSize - mainOffsetLeft - minContentWidth - contentGapRight - toolsFormOffsetWidth - getPanelOffsetWidth());\n    setDrawersMaxWidth(placement.inlineSize - mainOffsetLeft - minContentWidth - contentGapRight - toolsFormOffsetWidth);\n  }, [activeDrawerId, drawerSize, drawers, navigationOpen, isToolsOpen, placement.inlineSize, mainOffsetLeft, minContentWidth, toolsWidth]);\n  /**\n   * The useImperativeHandle hook in conjunction with the forwardRef function\n   * in the AppLayout component definition expose the following callable\n   * functions to component consumers when they put a ref as a property on\n   * their component implementation.\n   */\n  useImperativeHandle(forwardRef, function createImperativeHandle() {\n    return {\n      closeNavigationIfNecessary: function () {\n        isMobile && handleNavigationClick(false);\n      },\n      openTools: function () {\n        handleToolsClick(true, hasDrawers);\n        if (hasDrawers) {\n          focusDrawersButtons(true);\n        }\n      },\n      focusToolsClose: () => {\n        if (hasDrawers) {\n          focusDrawersButtons(true);\n        } else {\n          focusToolsButtons(true);\n        }\n      },\n      focusActiveDrawer: () => focusDrawersButtons(true),\n      focusSplitPanel: () => {\n        var _a;\n        return (_a = splitPanelRefs.slider.current) === null || _a === void 0 ? void 0 : _a.focus();\n      }\n    };\n  }, [isMobile, handleNavigationClick, handleToolsClick, focusToolsButtons, focusDrawersButtons, splitPanelRefs.slider, hasDrawers]);\n  return React.createElement(AppLayoutInternalsContext.Provider, {\n    value: Object.assign(Object.assign({}, props), {\n      activeDrawerId,\n      contentType,\n      drawers,\n      drawersAriaLabel: (_c = drawersProps.ariaLabelsWithDrawers) === null || _c === void 0 ? void 0 : _c.drawers,\n      drawersOverflowAriaLabel: (_d = drawersProps.ariaLabelsWithDrawers) === null || _d === void 0 ? void 0 : _d.drawersOverflow,\n      drawersOverflowWithBadgeAriaLabel: (_e = drawersProps.ariaLabelsWithDrawers) === null || _e === void 0 ? void 0 : _e.drawersOverflowWithBadge,\n      drawersRefs,\n      drawersMinWidth,\n      drawersMaxWidth,\n      drawerSize,\n      drawerRef,\n      resizeHandle,\n      drawersTriggerCount,\n      headerHeight: placement.insetBlockStart,\n      footerHeight: placement.insetBlockEnd,\n      hasDrawerViewportOverlay,\n      handleDrawersClick,\n      handleNavigationClick,\n      handleSplitPanelClick,\n      handleSplitPanelPreferencesChange,\n      handleSplitPanelResize,\n      handleToolsClick,\n      hasBackgroundOverlap,\n      hasNotificationsContent,\n      hasOpenDrawer,\n      isBackgroundOverlapDisabled: props.disableContentHeaderOverlap || !hasBackgroundOverlap,\n      isMobile,\n      isSplitPanelForcedPosition,\n      isSplitPanelOpen,\n      isToolsOpen,\n      layoutElement,\n      layoutWidth: placement.inlineSize,\n      loseToolsFocus,\n      loseDrawersFocus,\n      mainElement,\n      mainOffsetLeft,\n      maxContentWidth,\n      minContentWidth,\n      navigationHide,\n      navigationRefs,\n      notificationsHeight,\n      setNotificationsHeight,\n      offsetBottom,\n      setSplitPanelReportedSize,\n      setSplitPanelReportedHeaderHeight,\n      splitPanel,\n      splitPanelControlId,\n      splitPanelDisplayed,\n      splitPanelMaxWidth,\n      splitPanelPosition,\n      splitPanelPreferences,\n      splitPanelReportedSize,\n      splitPanelReportedHeaderHeight,\n      splitPanelSize,\n      splitPanelToggle,\n      setSplitPanelToggle,\n      splitPanelRefs,\n      toolsControlId,\n      toolsHide,\n      toolsOpen: isToolsOpen,\n      toolsWidth,\n      toolsRefs,\n      __embeddedViewMode\n    })\n  }, React.createElement(DynamicOverlapContext.Provider, {\n    value: updateBackgroundOverlapHeight\n  }, children));\n});","map":{"version":3,"names":["React","createContext","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useRef","useState","useStableCallback","getOffsetInlineStart","DynamicOverlapContext","fireNonCancelableEvent","useControllable","useMobile","useUniqueId","getSplitPanelDefaultSize","SPLIT_PANEL_MIN_WIDTH","checkSplitPanelForcedPosition","useDrawers","useFocusControl","useResize","useSplitPanelFocusControl","getSplitPanelPosition","useBackgroundOverlap","styles","AppLayoutInternalsContext","useAppLayoutInternals","ctx","Error","AppLayoutInternalsProvider","forwardRef","props","toolsHide","toolsOpen","controlledToolsOpen","navigationHide","navigationOpen","contentType","placement","children","splitPanel","isMobile","__embeddedViewMode","Boolean","geckoMaxCssLength","halfGeckoMaxCssLength","maxContentWidth","_a","minContentWidth","_b","refs","navigationRefs","setFocus","focusNavButtons","handleNavigationClick","handleNavigationChange","isOpen","onNavigationChange","open","toolsWidth","isToolsOpen","setIsToolsOpen","onToolsChange","componentName","controlledProp","changeHandler","toolsRefs","focusToolsButtons","loseFocus","loseToolsFocus","handleToolsClick","handleToolsChange","skipFocusControl","splitPanelMaxWidth","setSplitPanelMaxWidth","isSplitPanelOpen","setIsSplitPanelOpen","splitPanelOpen","onSplitPanelToggle","splitPanelPreferences","setSplitPanelPreferences","onSplitPanelPreferencesChange","undefined","splitPanelRefs","setLastInteraction","setSplitPanelLastInteraction","handleSplitPanelClick","handleSplitPanelChange","type","isSplitPanelForcedPosition","splitPanelPosition","splitPanelReportedSize","setSplitPanelReportedSize","splitPanelReportedHeaderHeight","setSplitPanelReportedHeaderHeight","splitPanelToggle","setSplitPanelToggle","displayed","ariaLabel","splitPanelDisplayed","splitPanelControlId","toolsControlId","splitPanelSize","setSplitPanelSize","onSplitPanelResize","handleSplitPanelResize","size","handleSplitPanelPreferencesChange","detail","_f","ariaLabels","disableDrawersMerge","tools","onToolsToggle","drawers","activeDrawer","activeDrawerId","minDrawerSize","drawersMinWidth","onActiveDrawerChange","onActiveDrawerResize","activeDrawerSize","drawersProps","__rest","drawersMaxWidth","setDrawersMaxWidth","hasDrawers","length","drawersRefs","focusDrawersButtons","loseDrawersFocus","drawerRef","resizeHandle","drawerSize","handleDrawersClick","id","newActiveDrawerId","drawersTriggerCount","hasOpenDrawer","hasDrawerViewportOverlay","layoutElement","mainElement","mainOffsetLeft","setMainOffsetLeft","hasBackgroundOverlap","updateBackgroundOverlapHeight","contentHeader","disableContentHeaderOverlap","handleMainOffsetLeft","offsetInlineStart","current","inlineSize","handleBodyScroll","document","body","classList","add","remove","cleanup","notificationsHeight","setNotificationsHeight","hasNotificationsContent","offsetBottom","insetBlockEnd","handleSplitPanelMaxWidth","contentGapRight","toolsFormOffsetWidth","getPanelOffsetWidth","createImperativeHandle","closeNavigationIfNecessary","openTools","focusToolsClose","focusActiveDrawer","focusSplitPanel","slider","focus","createElement","Provider","value","Object","assign","drawersAriaLabel","_c","ariaLabelsWithDrawers","drawersOverflowAriaLabel","_d","drawersOverflow","drawersOverflowWithBadgeAriaLabel","_e","drawersOverflowWithBadge","headerHeight","insetBlockStart","footerHeight","isBackgroundOverlapDisabled","layoutWidth"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/app-layout/visual-refresh/context.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useRef,\n  useState,\n} from 'react';\n\nimport { useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getOffsetInlineStart } from '@cloudscape-design/component-toolkit/internal';\n\nimport { DynamicOverlapContext } from '../../internal/context/dynamic-overlap-context';\nimport { SplitPanelSideToggleProps } from '../../internal/context/split-panel-context';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useUniqueId } from '../../internal/hooks/use-unique-id';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { AppLayoutProps, AppLayoutPropsWithDefaults } from '../interfaces';\nimport { SPLIT_PANEL_MIN_WIDTH } from '../split-panel';\nimport { checkSplitPanelForcedPosition } from '../split-panel/split-panel-utils';\nimport { useDrawers } from '../utils/use-drawers';\nimport { FocusControlRefs, useFocusControl } from '../utils/use-focus-control';\nimport useResize from '../utils/use-resize';\nimport { SplitPanelFocusControlRefs, useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { getSplitPanelPosition } from './split-panel';\nimport useBackgroundOverlap from './use-background-overlap';\n\nimport styles from './styles.css.js';\n\nexport interface AppLayoutInternals extends AppLayoutPropsWithDefaults {\n  activeDrawerId: string | null;\n  drawers: Array<AppLayoutProps.Drawer> | undefined;\n  drawersAriaLabel: string | undefined;\n  drawersOverflowAriaLabel: string | undefined;\n  drawersOverflowWithBadgeAriaLabel: string | undefined;\n  drawersRefs: FocusControlRefs;\n  drawerSize: number;\n  drawersMinWidth: number;\n  drawersMaxWidth: number;\n  drawerRef: React.Ref<HTMLElement>;\n  resizeHandle: React.ReactElement;\n  drawersTriggerCount: number;\n  handleDrawersClick: (activeDrawerId: string | null, skipFocusControl?: boolean) => void;\n  handleSplitPanelClick: () => void;\n  handleNavigationClick: (isOpen: boolean) => void;\n  handleSplitPanelPreferencesChange: (detail: AppLayoutProps.SplitPanelPreferences) => void;\n  handleSplitPanelResize: (newSize: number) => void;\n  handleToolsClick: (value: boolean, skipFocusControl?: boolean) => void;\n  hasBackgroundOverlap: boolean;\n  hasDrawerViewportOverlay: boolean;\n  hasNotificationsContent: boolean;\n  hasOpenDrawer?: boolean;\n  isBackgroundOverlapDisabled: boolean;\n  isMobile: boolean;\n  isSplitPanelForcedPosition: boolean;\n  isSplitPanelOpen?: boolean;\n  isToolsOpen: boolean;\n  layoutElement: React.Ref<HTMLElement>;\n  layoutWidth: number;\n  loseToolsFocus: () => void;\n  loseDrawersFocus: () => void;\n  mainElement: React.Ref<HTMLDivElement>;\n  mainOffsetLeft: number;\n  navigationRefs: FocusControlRefs;\n  notificationsHeight: number;\n  setNotificationsHeight: (height: number) => void;\n  offsetBottom: number;\n  setSplitPanelReportedSize: (value: number) => void;\n  setSplitPanelReportedHeaderHeight: (value: number) => void;\n  headerHeight: number;\n  footerHeight: number;\n  splitPanelControlId: string;\n  splitPanelMaxWidth: number;\n  splitPanelPosition: AppLayoutProps.SplitPanelPosition;\n  splitPanelReportedSize: number;\n  splitPanelReportedHeaderHeight: number;\n  splitPanelToggle: SplitPanelSideToggleProps;\n  setSplitPanelToggle: (toggle: SplitPanelSideToggleProps) => void;\n  splitPanelDisplayed: boolean;\n  splitPanelRefs: SplitPanelFocusControlRefs;\n  toolsControlId: string;\n  toolsRefs: FocusControlRefs;\n  __embeddedViewMode?: boolean;\n}\n\n/**\n * The default values are destructured in the context instantiation to\n * prevent downstream Typescript errors. This could likely be replaced\n * by a context interface definition that extends the AppLayout interface.\n */\nconst AppLayoutInternalsContext = createContext<AppLayoutInternals | null>(null);\n\ninterface AppLayoutProviderInternalsProps extends AppLayoutPropsWithDefaults {\n  children: React.ReactNode;\n}\n\nexport function useAppLayoutInternals() {\n  const ctx = useContext(AppLayoutInternalsContext);\n  if (!ctx) {\n    throw new Error('Invariant violation: this context is only available inside app layout');\n  }\n  return ctx;\n}\n\nexport const AppLayoutInternalsProvider = React.forwardRef(\n  (props: AppLayoutProviderInternalsProps, forwardRef: React.Ref<AppLayoutProps.Ref>) => {\n    const {\n      toolsHide,\n      toolsOpen: controlledToolsOpen,\n      navigationHide,\n      navigationOpen,\n      contentType,\n      placement,\n      children,\n      splitPanel,\n    } = props;\n    const isMobile = useMobile();\n\n    // Private API for embedded view mode\n    const __embeddedViewMode = Boolean((props as any).__embeddedViewMode);\n\n    /**\n     * Set the default values for minimum and maximum content width.\n     */\n    const geckoMaxCssLength = ((1 << 30) - 1) / 60;\n    const halfGeckoMaxCssLength = geckoMaxCssLength / 2;\n    // CSS lengths in Gecko are limited to at most (1<<30)-1 app units (Gecko uses 60 as app unit).\n    // Limit the maxContentWidth to the half of the upper boundary (≈4230^2) to be on the safe side.\n    const maxContentWidth =\n      props.maxContentWidth && props.maxContentWidth > halfGeckoMaxCssLength\n        ? halfGeckoMaxCssLength\n        : props.maxContentWidth ?? 0;\n    const minContentWidth = props.minContentWidth ?? 280;\n\n    const { refs: navigationRefs, setFocus: focusNavButtons } = useFocusControl(navigationOpen);\n\n    const handleNavigationClick = useStableCallback(function handleNavigationChange(isOpen: boolean) {\n      focusNavButtons();\n      fireNonCancelableEvent(props.onNavigationChange, { open: isOpen });\n    });\n\n    useEffect(() => {\n      // Close navigation drawer on mobile so that the main content is visible\n      if (isMobile) {\n        handleNavigationClick(false);\n      }\n    }, [isMobile, handleNavigationClick]);\n\n    const toolsWidth = props.toolsWidth;\n    const [isToolsOpen = false, setIsToolsOpen] = useControllable(controlledToolsOpen, props.onToolsChange, false, {\n      componentName: 'AppLayout',\n      controlledProp: 'toolsOpen',\n      changeHandler: 'onToolsChange',\n    });\n\n    const {\n      refs: toolsRefs,\n      setFocus: focusToolsButtons,\n      loseFocus: loseToolsFocus,\n    } = useFocusControl(isToolsOpen, true);\n\n    const handleToolsClick = useCallback(\n      function handleToolsChange(isOpen: boolean, skipFocusControl?: boolean) {\n        setIsToolsOpen(isOpen);\n        !skipFocusControl && focusToolsButtons();\n        fireNonCancelableEvent(props.onToolsChange, { open: isOpen });\n      },\n      [props.onToolsChange, setIsToolsOpen, focusToolsButtons]\n    );\n\n    /**\n     * Set the default values for the minimum and maximum Split Panel width when it is\n     * in the side position. The useLayoutEffect will compute the available space in the\n     * DOM for the Split Panel given the current state. The minimum and maximum\n     * widths will potentially trigger a side effect that will put the Split Panel into\n     * a forced position on the bottom.\n     */\n    const [splitPanelMaxWidth, setSplitPanelMaxWidth] = useState(SPLIT_PANEL_MIN_WIDTH);\n\n    /**\n     * The useControllable hook will set the default value and manage either\n     * the controlled or uncontrolled state of the Split Panel. By default\n     * the Split Panel should always be closed on page load.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the click events that will change the state of the SplitPanel\n     * to open or closed given the current state. It will set the isSplitPanelOpen\n     * controlled state and fire the onSplitPanelToggle event.\n     */\n    const [isSplitPanelOpen, setIsSplitPanelOpen] = useControllable(\n      props.splitPanelOpen,\n      props.onSplitPanelToggle,\n      false,\n      { componentName: 'AppLayout', controlledProp: 'splitPanelOpen', changeHandler: 'onSplitPanelToggle' }\n    );\n\n    /**\n     * The useControllable hook will manage the controlled or uncontrolled\n     * state of the splitPanelPreferences. By default the splitPanelPreferences\n     * is undefined. When set the object shape should have a single key to indicate\n     * either bottom or side position.\n     *\n     * The callback that will handle changes to the splitPanelPreferences\n     * object that will determine if the SplitPanel is rendered either on the\n     * bottom of the viewport or within the Tools container.\n     */\n    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(\n      props.splitPanelPreferences,\n      props.onSplitPanelPreferencesChange,\n      undefined,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelPreferences',\n        changeHandler: 'onSplitPanelPreferencesChange',\n      }\n    );\n\n    const { refs: splitPanelRefs, setLastInteraction: setSplitPanelLastInteraction } = useSplitPanelFocusControl([\n      splitPanelPreferences,\n      isSplitPanelOpen,\n    ]);\n\n    const handleSplitPanelClick = useCallback(\n      function handleSplitPanelChange() {\n        setIsSplitPanelOpen(!isSplitPanelOpen);\n        setSplitPanelLastInteraction({ type: isSplitPanelOpen ? 'close' : 'open' });\n        fireNonCancelableEvent(props.onSplitPanelToggle, { open: !isSplitPanelOpen });\n      },\n      [props.onSplitPanelToggle, isSplitPanelOpen, setIsSplitPanelOpen, setSplitPanelLastInteraction]\n    );\n\n    const isSplitPanelForcedPosition = checkSplitPanelForcedPosition({ isMobile, splitPanelMaxWidth });\n    const splitPanelPosition = getSplitPanelPosition(isSplitPanelForcedPosition, splitPanelPreferences);\n\n    /**\n     * The useControllable hook will set the default size of the SplitPanel based\n     * on the default position set in the splitPanelPreferences. The logic for the\n     * default size is contained in the SplitPanel component. The splitPanelControlledSize\n     * will be bound to the size property in the SplitPanel context for rendering.\n     *\n     * The callback that will be passed to the SplitPanel component\n     * to handle the resize events that will change the size of the SplitPanel.\n     * It will set the splitPanelControlledSize controlled state and fire the\n     * onSplitPanelResize event.\n     */\n    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n    const [splitPanelReportedHeaderHeight, setSplitPanelReportedHeaderHeight] = useState(0);\n    const [splitPanelToggle, setSplitPanelToggle] = useState<SplitPanelSideToggleProps>({\n      displayed: false,\n      ariaLabel: undefined,\n    });\n    const splitPanelDisplayed = !!(splitPanelToggle.displayed || isSplitPanelOpen) && !!splitPanel;\n    const splitPanelControlId = useUniqueId('split-panel-');\n    const toolsControlId = useUniqueId('tools-');\n\n    const [splitPanelSize, setSplitPanelSize] = useControllable(\n      props.splitPanelSize,\n      props.onSplitPanelResize,\n      getSplitPanelDefaultSize(splitPanelPosition),\n      { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }\n    );\n\n    const handleSplitPanelResize = useCallback(\n      (size: number) => {\n        setSplitPanelSize(size);\n        fireNonCancelableEvent(props.onSplitPanelResize, { size });\n      },\n      [props.onSplitPanelResize, setSplitPanelSize]\n    );\n\n    const handleSplitPanelPreferencesChange = useCallback(\n      function handleSplitPanelChange(detail: AppLayoutProps.SplitPanelPreferences) {\n        setSplitPanelPreferences(detail);\n        setSplitPanelLastInteraction({ type: 'position' });\n        fireNonCancelableEvent(props.onSplitPanelPreferencesChange, detail);\n      },\n      [props.onSplitPanelPreferencesChange, setSplitPanelPreferences, setSplitPanelLastInteraction]\n    );\n\n    const {\n      drawers,\n      activeDrawer,\n      activeDrawerId,\n      minDrawerSize: drawersMinWidth,\n      onActiveDrawerChange,\n      onActiveDrawerResize,\n      activeDrawerSize,\n      ...drawersProps\n    } = useDrawers(props, props.ariaLabels, {\n      disableDrawersMerge: true,\n      ariaLabels: props.ariaLabels,\n      toolsHide,\n      toolsOpen: isToolsOpen,\n      tools: props.tools,\n      toolsWidth,\n      onToolsToggle: handleToolsClick,\n    });\n\n    const [drawersMaxWidth, setDrawersMaxWidth] = useState(toolsWidth);\n    const hasDrawers = !!drawers && drawers.length > 0;\n\n    const {\n      refs: drawersRefs,\n      setFocus: focusDrawersButtons,\n      loseFocus: loseDrawersFocus,\n    } = useFocusControl(!!activeDrawerId, true, activeDrawerId);\n\n    const drawerRef = useRef<HTMLDivElement>(null);\n    const { resizeHandle, drawerSize } = useResize(drawerRef, {\n      onActiveDrawerResize,\n      activeDrawerSize,\n      activeDrawer,\n      drawersRefs,\n      isToolsOpen,\n      drawersMaxWidth,\n      drawersMinWidth,\n    });\n\n    const handleDrawersClick = (id: string | null, skipFocusControl?: boolean) => {\n      const newActiveDrawerId = id !== activeDrawerId ? id : null;\n\n      onActiveDrawerChange(newActiveDrawerId);\n\n      !skipFocusControl && focusDrawersButtons();\n    };\n\n    let drawersTriggerCount = drawers ? drawers.length : !toolsHide ? 1 : 0;\n    if (splitPanelDisplayed && splitPanelPosition === 'side') {\n      drawersTriggerCount++;\n    }\n    const hasOpenDrawer =\n      !!activeDrawerId ||\n      (!toolsHide && isToolsOpen) ||\n      (splitPanelDisplayed && splitPanelPosition === 'side' && isSplitPanelOpen);\n    const hasDrawerViewportOverlay =\n      isMobile && (!!activeDrawerId || (!navigationHide && navigationOpen) || (!toolsHide && isToolsOpen));\n\n    const layoutElement = useRef<HTMLDivElement>(null);\n    const mainElement = useRef<HTMLDivElement>(null);\n    const [mainOffsetLeft, setMainOffsetLeft] = useState(0);\n\n    const { hasBackgroundOverlap, updateBackgroundOverlapHeight } = useBackgroundOverlap({\n      contentHeader: props.contentHeader,\n      disableContentHeaderOverlap: props.disableContentHeaderOverlap,\n      layoutElement,\n    });\n\n    useLayoutEffect(\n      function handleMainOffsetLeft() {\n        const offsetInlineStart = mainElement?.current ? getOffsetInlineStart(mainElement?.current) : 0;\n        setMainOffsetLeft(offsetInlineStart);\n      },\n      [placement.inlineSize, navigationOpen, isToolsOpen, splitPanelReportedSize]\n    );\n\n    /**\n     * On mobile viewports the navigation and tools drawers are adjusted to a fixed position\n     * that consumes 100% of the viewport height and width. The body content could potentially\n     * be scrollable underneath the drawer. In order to prevent this a CSS class needs to be\n     * added to the document body that sets overflow to hidden.\n     */\n    useEffect(\n      function handleBodyScroll() {\n        if (isMobile && (navigationOpen || isToolsOpen || !!activeDrawer)) {\n          document.body.classList.add(styles['block-body-scroll']);\n        } else {\n          document.body.classList.remove(styles['block-body-scroll']);\n        }\n\n        // Ensure the CSS class is removed from the body on side effect cleanup\n        return function cleanup() {\n          document.body.classList.remove(styles['block-body-scroll']);\n        };\n      },\n      [isMobile, navigationOpen, isToolsOpen, activeDrawer]\n    );\n\n    const [notificationsHeight, setNotificationsHeight] = useState(0);\n    const hasNotificationsContent = notificationsHeight > 0;\n    /**\n     * Determine the offsetBottom value based on the presence of a footer element and\n     * the SplitPanel component. Ignore the SplitPanel if it is not in the bottom\n     * position. Use the size property if it is open and the header height if it is closed.\n     */\n    let offsetBottom = placement.insetBlockEnd;\n\n    if (splitPanelDisplayed && splitPanelPosition === 'bottom') {\n      if (isSplitPanelOpen) {\n        offsetBottom += splitPanelReportedSize;\n      } else {\n        offsetBottom += splitPanelReportedHeaderHeight;\n      }\n    }\n\n    /**\n     * Warning! This is a hack! In order to accurately calculate if there is adequate\n     * horizontal space for the Split Panel to be in the side position we need two values\n     * that are not available in JavaScript.\n     *\n     * The first is the the content gap on the right which is stored in a design token\n     * and applied in the Layout CSS:\n     *\n     * $contentGapRight: #{awsui.$space-layout-content-horizontal};\n     *\n     * The second is the width of the element that has the circular buttons for the\n     * Tools and Split Panel. This could be suppressed given the state of the Tools\n     * drawer returning a zero value. It would, however, be rendered if the Split Panel\n     * were to move into the side position. This is calculated in the Tools CSS and\n     * the Trigger button CSS with design tokens:\n     *\n     * padding: awsui.$space-scaled-s awsui.$space-layout-toggle-padding;\n     * width: awsui.$space-layout-toggle-diameter;\n     *\n     * These values will be defined below as static integers that are rough approximations\n     * of their computed width when rendered in the DOM, but doubled to ensure adequate\n     * spacing for the Split Panel to be in side position.\n     */\n    useLayoutEffect(\n      function handleSplitPanelMaxWidth() {\n        const contentGapRight = 50; // Approximately 24px when rendered but doubled for safety\n        const toolsFormOffsetWidth = 120; // Approximately 60px when rendered but doubled for safety\n        const getPanelOffsetWidth = () => {\n          if (drawers) {\n            return activeDrawerId ? drawerSize : 0;\n          }\n          return isToolsOpen ? toolsWidth : 0;\n        };\n\n        setSplitPanelMaxWidth(\n          placement.inlineSize -\n            mainOffsetLeft -\n            minContentWidth -\n            contentGapRight -\n            toolsFormOffsetWidth -\n            getPanelOffsetWidth()\n        );\n\n        setDrawersMaxWidth(\n          placement.inlineSize - mainOffsetLeft - minContentWidth - contentGapRight - toolsFormOffsetWidth\n        );\n      },\n      [\n        activeDrawerId,\n        drawerSize,\n        drawers,\n        navigationOpen,\n        isToolsOpen,\n        placement.inlineSize,\n        mainOffsetLeft,\n        minContentWidth,\n        toolsWidth,\n      ]\n    );\n\n    /**\n     * The useImperativeHandle hook in conjunction with the forwardRef function\n     * in the AppLayout component definition expose the following callable\n     * functions to component consumers when they put a ref as a property on\n     * their component implementation.\n     */\n    useImperativeHandle(\n      forwardRef,\n      function createImperativeHandle() {\n        return {\n          closeNavigationIfNecessary: function () {\n            isMobile && handleNavigationClick(false);\n          },\n          openTools: function () {\n            handleToolsClick(true, hasDrawers);\n            if (hasDrawers) {\n              focusDrawersButtons(true);\n            }\n          },\n          focusToolsClose: () => {\n            if (hasDrawers) {\n              focusDrawersButtons(true);\n            } else {\n              focusToolsButtons(true);\n            }\n          },\n          focusActiveDrawer: () => focusDrawersButtons(true),\n          focusSplitPanel: () => splitPanelRefs.slider.current?.focus(),\n        };\n      },\n      [\n        isMobile,\n        handleNavigationClick,\n        handleToolsClick,\n        focusToolsButtons,\n        focusDrawersButtons,\n        splitPanelRefs.slider,\n        hasDrawers,\n      ]\n    );\n\n    return (\n      <AppLayoutInternalsContext.Provider\n        value={{\n          ...props,\n          activeDrawerId,\n          contentType,\n          drawers,\n          drawersAriaLabel: drawersProps.ariaLabelsWithDrawers?.drawers,\n          drawersOverflowAriaLabel: drawersProps.ariaLabelsWithDrawers?.drawersOverflow,\n          drawersOverflowWithBadgeAriaLabel: drawersProps.ariaLabelsWithDrawers?.drawersOverflowWithBadge,\n          drawersRefs,\n          drawersMinWidth,\n          drawersMaxWidth,\n          drawerSize,\n          drawerRef,\n          resizeHandle,\n          drawersTriggerCount,\n          headerHeight: placement.insetBlockStart,\n          footerHeight: placement.insetBlockEnd,\n          hasDrawerViewportOverlay,\n          handleDrawersClick,\n          handleNavigationClick,\n          handleSplitPanelClick,\n          handleSplitPanelPreferencesChange,\n          handleSplitPanelResize,\n          handleToolsClick,\n          hasBackgroundOverlap,\n          hasNotificationsContent,\n          hasOpenDrawer,\n          isBackgroundOverlapDisabled: props.disableContentHeaderOverlap || !hasBackgroundOverlap,\n          isMobile,\n          isSplitPanelForcedPosition,\n          isSplitPanelOpen,\n          isToolsOpen,\n          layoutElement,\n          layoutWidth: placement.inlineSize,\n          loseToolsFocus,\n          loseDrawersFocus,\n          mainElement,\n          mainOffsetLeft,\n          maxContentWidth,\n          minContentWidth,\n          navigationHide,\n          navigationRefs,\n          notificationsHeight,\n          setNotificationsHeight,\n          offsetBottom,\n          setSplitPanelReportedSize,\n          setSplitPanelReportedHeaderHeight,\n          splitPanel,\n          splitPanelControlId,\n          splitPanelDisplayed,\n          splitPanelMaxWidth,\n          splitPanelPosition,\n          splitPanelPreferences,\n          splitPanelReportedSize,\n          splitPanelReportedHeaderHeight,\n          splitPanelSize,\n          splitPanelToggle,\n          setSplitPanelToggle,\n          splitPanelRefs,\n          toolsControlId,\n          toolsHide,\n          toolsOpen: isToolsOpen,\n          toolsWidth,\n          toolsRefs,\n          __embeddedViewMode,\n        }}\n      >\n        <DynamicOverlapContext.Provider value={updateBackgroundOverlapHeight}>\n          {children}\n        </DynamicOverlapContext.Provider>\n      </AppLayoutInternalsContext.Provider>\n    );\n  }\n);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}