{"ast":null,"code":"import { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useRef } from \"react\";\nimport { usePrevious } from \"@dnd-kit/utilities\";\nimport clsx from \"clsx\";\nimport { getIsRtl } from \"@cloudscape-design/component-toolkit/internal\";\nimport { getDataAttributes } from \"../internal/base-component/get-data-attributes\";\nimport { useContainerColumns } from \"../internal/breakpoints\";\nimport { TRANSITION_DURATION_MS } from \"../internal/constants\";\nimport { useDragSubscription } from \"../internal/dnd-controller/controller\";\nimport { useGlobalDragStateStyles } from \"../internal/global-drag-state-styles\";\nimport Grid from \"../internal/grid\";\nimport { ItemContainer } from \"../internal/item-container\";\nimport LiveRegion from \"../internal/live-region\";\nimport { createPlaceholdersLayout, getDefaultColumnSpan, getDefaultRowSpan, getMinColumnSpan, getMinRowSpan, interpretItems } from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { useAutoScroll } from \"../internal/utils/use-auto-scroll\";\nimport { useMergeRefs } from \"../internal/utils/use-merge-refs\";\nimport Placeholder from \"./placeholder\";\nimport { selectTransitionRows, useTransition } from \"./transition\";\nimport { announcementToString } from \"./utils/announcements\";\nimport { createTransforms } from \"./utils/create-transforms\";\nimport { createItemsChangeEvent } from \"./utils/events\";\nimport styles from \"./styles.css.js\";\nexport function InternalBoard(_ref) {\n  let {\n    items,\n    renderItem,\n    onItemsChange,\n    empty,\n    i18nStrings,\n    __internalRootRef,\n    ...rest\n  } = _ref;\n  var _a, _b;\n  const containerAccessRef = useRef(null);\n  const [currentColumns, containerQueryRef] = useContainerColumns();\n  const containerRef = useMergeRefs(containerAccessRef, containerQueryRef);\n  const itemContainerRef = useRef({});\n  const isRtl = () => getIsRtl(containerAccessRef.current);\n  useGlobalDragStateStyles();\n  const autoScrollHandlers = useAutoScroll();\n  const [transitionState, dispatch] = useTransition({\n    isRtl\n  });\n  const transition = transitionState.transition;\n  const removeTransition = transitionState.removeTransition;\n  const transitionAnnouncement = transitionState.announcement;\n  const acquiredItem = (_a = transition === null || transition === void 0 ? void 0 : transition.acquiredItem) !== null && _a !== void 0 ? _a : null;\n  const acquiredItemElement = transition === null || transition === void 0 ? void 0 : transition.acquiredItemElement;\n  // Using cached columns from transition to ensure no unexpected changes in the process.\n  const columns = transition ? transition.itemsLayout.columns : currentColumns;\n  // Use previous items while remove transition is in progress.\n  items = (_b = removeTransition === null || removeTransition === void 0 ? void 0 : removeTransition.items) !== null && _b !== void 0 ? _b : items;\n  // The acquired item is the one being inserting at the moment but not submitted yet.\n  // It needs to be included to the layout to be a part of layout shifts and rendering.\n  items = acquiredItem ? [...items, acquiredItem] : items;\n  const itemsLayout = interpretItems(items, columns);\n  const layoutItemById = new Map(itemsLayout.items.map(item => [item.id, item]));\n  const layoutItemIndexById = new Map(itemsLayout.items.map((item, index) => [item.id, index]));\n  // Items and layout items must maintain the same order visually, in the DOM and in the data\n  // to ensure on-change events and tab order work as expected.\n  items = [...items].sort((a, b) => {\n    var _a, _b;\n    return ((_a = layoutItemIndexById.get(a.id)) !== null && _a !== void 0 ? _a : -1) - ((_b = layoutItemIndexById.get(b.id)) !== null && _b !== void 0 ? _b : -1);\n  });\n  // When an item gets acquired or removed the focus needs to be dispatched on the next render.\n  const focusNextRenderIdRef = useRef(null);\n  useEffect(() => {\n    const focusTarget = focusNextRenderIdRef.current;\n    if (focusTarget) {\n      itemContainerRef.current[focusTarget].focusDragHandle();\n    }\n    focusNextRenderIdRef.current = null;\n  });\n  // Submit scheduled removal after a delay to let animations play.\n  useEffect(() => {\n    if (!removeTransition) {\n      return;\n    }\n    const timeoutId = setTimeout(() => {\n      var _a;\n      dispatch({\n        type: \"submit\"\n      });\n      const removedItemIndex = items.findIndex(it => it.id === removeTransition.removedItem.id);\n      const nextIndexToFocus = removedItemIndex !== items.length - 1 ? removedItemIndex : items.length - 2;\n      const newItems = createItemsChangeEvent(items, removeTransition.layoutShift);\n      const itemIdToFocus = (_a = newItems.detail.items[nextIndexToFocus]) === null || _a === void 0 ? void 0 : _a.id;\n      if (itemIdToFocus) {\n        itemContainerRef.current[itemIdToFocus].focusDragHandle();\n      }\n      onItemsChange(newItems);\n    }, TRANSITION_DURATION_MS);\n    return () => clearTimeout(timeoutId);\n  }, [removeTransition, items, onItemsChange]);\n  // When item is inserting with the keyboard it keeps rendering by the palette and upon submission\n  // it starts rendering by the board. This transitions might lead to the focus being lost from the item's drag handle.\n  // The below code refocuses the drag handle when detecting the acquired item is no longer used.\n  const acquiredItemId = usePrevious(acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id);\n  const previousAcquiredItemElement = usePrevious(acquiredItemElement);\n  useEffect(() => {\n    var _a;\n    if (acquiredItemId && previousAcquiredItemElement && !acquiredItemElement) {\n      (_a = itemContainerRef.current[acquiredItemId]) === null || _a === void 0 ? void 0 : _a.focusDragHandle();\n    }\n  }, [acquiredItemId, previousAcquiredItemElement, acquiredItemElement]);\n  const rows = selectTransitionRows(transitionState) || itemsLayout.rows;\n  const placeholdersLayout = createPlaceholdersLayout(rows, itemsLayout.columns);\n  function isElementOverBoard(rect) {\n    const board = containerAccessRef.current;\n    const boardContains = target => board === target || board.contains(target);\n    const left = !isRtl() ? rect.left : document.documentElement.clientWidth - rect.left;\n    const right = !isRtl() ? rect.right : document.documentElement.clientWidth - rect.right;\n    const {\n      top,\n      bottom\n    } = rect;\n    return boardContains(document.elementFromPoint(left, top)) || boardContains(document.elementFromPoint(right, top)) || boardContains(document.elementFromPoint(right, bottom)) || boardContains(document.elementFromPoint(left, bottom));\n  }\n  useDragSubscription(\"start\", _ref2 => {\n    let {\n      operation,\n      interactionType,\n      draggableItem,\n      collisionRect,\n      collisionIds\n    } = _ref2;\n    dispatch({\n      type: \"init\",\n      operation,\n      interactionType,\n      itemsLayout,\n      // TODO: resolve any\n      // The code only works assuming the board can take any draggable.\n      // If draggables can be of different types a check of some sort is required here.\n      draggableItem: draggableItem,\n      draggableRect: collisionRect,\n      collisionIds: interactionType === \"pointer\" && isElementOverBoard(collisionRect) ? collisionIds : []\n    });\n    autoScrollHandlers.addPointerEventHandlers();\n  });\n  useDragSubscription(\"update\", _ref3 => {\n    let {\n      interactionType,\n      collisionIds,\n      positionOffset,\n      collisionRect\n    } = _ref3;\n    dispatch({\n      type: \"update-with-pointer\",\n      collisionIds: interactionType === \"pointer\" && isElementOverBoard(collisionRect) ? collisionIds : [],\n      positionOffset,\n      draggableRect: collisionRect\n    });\n  });\n  useDragSubscription(\"submit\", () => {\n    dispatch({\n      type: \"submit\"\n    });\n    autoScrollHandlers.removePointerEventHandlers();\n    if (!transition) {\n      throw new Error(\"Invariant violation: no transition.\");\n    }\n    if (!transition.layoutShift || transition.layoutShift.conflicts.length > 0 || transition.layoutShift.moves.length === 0) {\n      return null;\n    }\n    // Commit new layout for insert case.\n    if (transition.operation === \"insert\") {\n      onItemsChange(createItemsChangeEvent([...items, transition.draggableItem], transition.layoutShift));\n    }\n    // Commit new layout for reorder/resize case.\n    else {\n      onItemsChange(createItemsChangeEvent(items, transition.layoutShift));\n    }\n  });\n  useDragSubscription(\"discard\", () => {\n    dispatch({\n      type: \"discard\"\n    });\n    autoScrollHandlers.removePointerEventHandlers();\n  });\n  useDragSubscription(\"acquire\", _ref4 => {\n    let {\n      droppableId,\n      draggableItem,\n      renderAcquiredItem\n    } = _ref4;\n    const placeholder = placeholdersLayout.items.find(it => it.id === droppableId);\n    // If missing then it does not belong to this board.\n    if (!placeholder) {\n      return;\n    }\n    dispatch({\n      type: \"acquire-item\",\n      position: new Position({\n        x: placeholder.x,\n        y: placeholder.y\n      }),\n      layoutElement: containerAccessRef.current,\n      acquiredItemElement: renderAcquiredItem()\n    });\n    focusNextRenderIdRef.current = draggableItem.id;\n  });\n  const removeItemAction = removedItem => {\n    dispatch({\n      type: \"init-remove\",\n      items,\n      itemsLayout,\n      removedItem\n    });\n  };\n  function onItemMove(direction) {\n    if (transition) {\n      dispatch({\n        type: \"update-with-keyboard\",\n        direction\n      });\n      autoScrollHandlers.scheduleActiveElementScrollIntoView(TRANSITION_DURATION_MS);\n    }\n  }\n  const announcement = transitionAnnouncement ? announcementToString(transitionAnnouncement, items, i18nStrings, itemsLayout.columns) : \"\";\n  return _jsxs(\"div\", {\n    ref: __internalRootRef,\n    ...getDataAttributes(rest),\n    children: [_jsx(\"div\", {\n      ref: containerRef,\n      className: clsx(styles.root, {\n        [styles.empty]: rows === 0\n      }),\n      children: rows > 0 ? _jsx(Grid, {\n        isRtl: isRtl,\n        columns: itemsLayout.columns,\n        layout: [...placeholdersLayout.items, ...itemsLayout.items],\n        children: gridContext => {\n          var _a;\n          const layoutShift = (_a = transition === null || transition === void 0 ? void 0 : transition.layoutShift) !== null && _a !== void 0 ? _a : removeTransition === null || removeTransition === void 0 ? void 0 : removeTransition.layoutShift;\n          const transforms = layoutShift ? createTransforms(itemsLayout, layoutShift.moves, gridContext) : {};\n          // Exclude drag target from transforms.\n          if (transition && transition.interactionType === \"pointer\") {\n            delete transforms[transition.draggableItem.id];\n          }\n          const children = [];\n          /* Placeholders are rendered even when there is no transition to support the first collisions check. */\n          placeholdersLayout.items.forEach(placeholder => {\n            var _a;\n            return children.push(_jsx(Placeholder, {\n              id: placeholder.id,\n              state: transition ? ((_a = transition.collisionIds) === null || _a === void 0 ? void 0 : _a.has(placeholder.id)) ? \"hover\" : \"active\" : \"default\",\n              gridContext: gridContext,\n              columns: itemsLayout.columns\n            }, placeholder.id));\n          });\n          items.forEach(item => {\n            const layoutItem = layoutItemById.get(item.id);\n            const isResizing = (transition === null || transition === void 0 ? void 0 : transition.operation) === \"resize\" && (transition === null || transition === void 0 ? void 0 : transition.draggableItem.id) === item.id;\n            const itemSize = layoutItem !== null && layoutItem !== void 0 ? layoutItem : {\n              width: getDefaultColumnSpan(item, itemsLayout.columns),\n              height: getDefaultRowSpan(item)\n            };\n            const itemMaxSize = isResizing && layoutItem ? {\n              width: itemsLayout.columns - layoutItem.x,\n              height: 999\n            } : itemSize;\n            children.push(_jsx(ItemContainer, {\n              ref: elem => {\n                if (elem) {\n                  itemContainerRef.current[item.id] = elem;\n                } else {\n                  delete itemContainerRef.current[item.id];\n                }\n              },\n              item: item,\n              transform: transforms[item.id],\n              inTransition: !!transition || !!removeTransition,\n              placed: item.id !== (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id),\n              acquired: item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id),\n              getItemSize: () => ({\n                width: gridContext.getWidth(itemSize.width),\n                minWidth: gridContext.getWidth(getMinColumnSpan(item, itemsLayout.columns)),\n                maxWidth: gridContext.getWidth(itemMaxSize.width),\n                height: gridContext.getHeight(itemSize.height),\n                minHeight: gridContext.getHeight(getMinRowSpan(item)),\n                maxHeight: gridContext.getHeight(itemMaxSize.height)\n              }),\n              onKeyMove: onItemMove,\n              isRtl: isRtl,\n              children: item.id === (acquiredItem === null || acquiredItem === void 0 ? void 0 : acquiredItem.id) && acquiredItemElement ? () => acquiredItemElement : () => renderItem(item, {\n                removeItem: () => removeItemAction(item)\n              })\n            }, item.id));\n          });\n          return children;\n        }\n      }) : empty\n    }), _jsx(LiveRegion, {\n      children: announcement\n    })]\n  });\n}","map":{"version":3,"names":["useEffect","useRef","usePrevious","clsx","getIsRtl","getDataAttributes","useContainerColumns","TRANSITION_DURATION_MS","useDragSubscription","useGlobalDragStateStyles","Grid","ItemContainer","LiveRegion","createPlaceholdersLayout","getDefaultColumnSpan","getDefaultRowSpan","getMinColumnSpan","getMinRowSpan","interpretItems","Position","useAutoScroll","useMergeRefs","Placeholder","selectTransitionRows","useTransition","announcementToString","createTransforms","createItemsChangeEvent","styles","InternalBoard","_ref","items","renderItem","onItemsChange","empty","i18nStrings","__internalRootRef","rest","containerAccessRef","currentColumns","containerQueryRef","containerRef","itemContainerRef","isRtl","current","autoScrollHandlers","transitionState","dispatch","transition","removeTransition","transitionAnnouncement","announcement","acquiredItem","_a","acquiredItemElement","columns","itemsLayout","_b","layoutItemById","Map","map","item","id","layoutItemIndexById","index","sort","a","b","get","focusNextRenderIdRef","focusTarget","focusDragHandle","timeoutId","setTimeout","type","removedItemIndex","findIndex","it","removedItem","nextIndexToFocus","length","newItems","layoutShift","itemIdToFocus","detail","clearTimeout","acquiredItemId","previousAcquiredItemElement","rows","placeholdersLayout","isElementOverBoard","rect","board","boardContains","target","contains","left","document","documentElement","clientWidth","right","top","bottom","elementFromPoint","_ref2","operation","interactionType","draggableItem","collisionRect","collisionIds","draggableRect","addPointerEventHandlers","_ref3","positionOffset","removePointerEventHandlers","Error","conflicts","moves","_ref4","droppableId","renderAcquiredItem","placeholder","find","position","x","y","layoutElement","removeItemAction","onItemMove","direction","scheduleActiveElementScrollIntoView","_jsxs","ref","children","_jsx","className","root","layout","gridContext","transforms","forEach","push","state","has","layoutItem","isResizing","itemSize","width","height","itemMaxSize","elem","transform","inTransition","placed","acquired","getItemSize","getWidth","minWidth","maxWidth","getHeight","minHeight","maxHeight","onKeyMove","removeItem"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/board/internal.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ReactNode, useEffect, useRef } from \"react\";\nimport { usePrevious } from \"@dnd-kit/utilities\";\nimport clsx from \"clsx\";\n\nimport { getIsRtl } from \"@cloudscape-design/component-toolkit/internal\";\n\nimport { getDataAttributes } from \"../internal/base-component/get-data-attributes\";\nimport { InternalBaseComponentProps } from \"../internal/base-component/use-base-component\";\nimport { useContainerColumns } from \"../internal/breakpoints\";\nimport { TRANSITION_DURATION_MS } from \"../internal/constants\";\nimport { useDragSubscription } from \"../internal/dnd-controller/controller\";\nimport { useGlobalDragStateStyles } from \"../internal/global-drag-state-styles\";\nimport Grid from \"../internal/grid\";\nimport { BoardItemDefinition, BoardItemDefinitionBase, Direction, ItemId, Rect } from \"../internal/interfaces\";\nimport { ItemContainer, ItemContainerRef } from \"../internal/item-container\";\nimport LiveRegion from \"../internal/live-region\";\nimport {\n  createPlaceholdersLayout,\n  getDefaultColumnSpan,\n  getDefaultRowSpan,\n  getMinColumnSpan,\n  getMinRowSpan,\n  interpretItems,\n} from \"../internal/utils/layout\";\nimport { Position } from \"../internal/utils/position\";\nimport { useAutoScroll } from \"../internal/utils/use-auto-scroll\";\nimport { useMergeRefs } from \"../internal/utils/use-merge-refs\";\nimport { BoardProps } from \"./interfaces\";\nimport Placeholder from \"./placeholder\";\nimport { selectTransitionRows, useTransition } from \"./transition\";\nimport { announcementToString } from \"./utils/announcements\";\nimport { createTransforms } from \"./utils/create-transforms\";\nimport { createItemsChangeEvent } from \"./utils/events\";\n\nimport styles from \"./styles.css.js\";\n\nexport function InternalBoard<D>({\n  items,\n  renderItem,\n  onItemsChange,\n  empty,\n  i18nStrings,\n  __internalRootRef,\n  ...rest\n}: BoardProps<D> & InternalBaseComponentProps) {\n  const containerAccessRef = useRef<HTMLDivElement>(null);\n  const [currentColumns, containerQueryRef] = useContainerColumns();\n  const containerRef = useMergeRefs(containerAccessRef, containerQueryRef);\n  const itemContainerRef = useRef<{ [id: ItemId]: ItemContainerRef }>({});\n\n  const isRtl = () => getIsRtl(containerAccessRef.current);\n\n  useGlobalDragStateStyles();\n\n  const autoScrollHandlers = useAutoScroll();\n\n  const [transitionState, dispatch] = useTransition<D>({ isRtl });\n  const transition = transitionState.transition;\n  const removeTransition = transitionState.removeTransition;\n  const transitionAnnouncement = transitionState.announcement;\n  const acquiredItem = transition?.acquiredItem ?? null;\n  const acquiredItemElement = transition?.acquiredItemElement;\n\n  // Using cached columns from transition to ensure no unexpected changes in the process.\n  const columns = transition ? transition.itemsLayout.columns : currentColumns;\n\n  // Use previous items while remove transition is in progress.\n  items = removeTransition?.items ?? items;\n\n  // The acquired item is the one being inserting at the moment but not submitted yet.\n  // It needs to be included to the layout to be a part of layout shifts and rendering.\n  items = acquiredItem ? [...items, acquiredItem] : items;\n  const itemsLayout = interpretItems(items, columns);\n\n  const layoutItemById = new Map(itemsLayout.items.map((item) => [item.id, item]));\n  const layoutItemIndexById = new Map(itemsLayout.items.map((item, index) => [item.id, index]));\n\n  // Items and layout items must maintain the same order visually, in the DOM and in the data\n  // to ensure on-change events and tab order work as expected.\n  items = [...items].sort((a, b) => (layoutItemIndexById.get(a.id) ?? -1) - (layoutItemIndexById.get(b.id) ?? -1));\n\n  // When an item gets acquired or removed the focus needs to be dispatched on the next render.\n  const focusNextRenderIdRef = useRef<null | ItemId>(null);\n  useEffect(() => {\n    const focusTarget = focusNextRenderIdRef.current;\n    if (focusTarget) {\n      itemContainerRef.current[focusTarget].focusDragHandle();\n    }\n    focusNextRenderIdRef.current = null;\n  });\n\n  // Submit scheduled removal after a delay to let animations play.\n  useEffect(() => {\n    if (!removeTransition) {\n      return;\n    }\n\n    const timeoutId = setTimeout(() => {\n      dispatch({ type: \"submit\" });\n\n      const removedItemIndex = items.findIndex((it) => it.id === removeTransition.removedItem.id);\n      const nextIndexToFocus = removedItemIndex !== items.length - 1 ? removedItemIndex : items.length - 2;\n      const newItems = createItemsChangeEvent(items, removeTransition.layoutShift);\n      const itemIdToFocus = newItems.detail.items[nextIndexToFocus]?.id;\n\n      if (itemIdToFocus) {\n        itemContainerRef.current[itemIdToFocus].focusDragHandle();\n      }\n      onItemsChange(newItems);\n    }, TRANSITION_DURATION_MS);\n\n    return () => clearTimeout(timeoutId);\n  }, [removeTransition, items, onItemsChange]);\n\n  // When item is inserting with the keyboard it keeps rendering by the palette and upon submission\n  // it starts rendering by the board. This transitions might lead to the focus being lost from the item's drag handle.\n  // The below code refocuses the drag handle when detecting the acquired item is no longer used.\n  const acquiredItemId = usePrevious(acquiredItem?.id);\n  const previousAcquiredItemElement = usePrevious(acquiredItemElement);\n  useEffect(() => {\n    if (acquiredItemId && previousAcquiredItemElement && !acquiredItemElement) {\n      itemContainerRef.current[acquiredItemId]?.focusDragHandle();\n    }\n  }, [acquiredItemId, previousAcquiredItemElement, acquiredItemElement]);\n\n  const rows = selectTransitionRows(transitionState) || itemsLayout.rows;\n  const placeholdersLayout = createPlaceholdersLayout(rows, itemsLayout.columns);\n\n  function isElementOverBoard(rect: Rect) {\n    const board = containerAccessRef.current!;\n    const boardContains = (target: null | Element) => board === target || board.contains(target);\n    const left = !isRtl() ? rect.left : document.documentElement.clientWidth - rect.left;\n    const right = !isRtl() ? rect.right : document.documentElement.clientWidth - rect.right;\n    const { top, bottom } = rect;\n    return (\n      boardContains(document.elementFromPoint(left, top)) ||\n      boardContains(document.elementFromPoint(right, top)) ||\n      boardContains(document.elementFromPoint(right, bottom)) ||\n      boardContains(document.elementFromPoint(left, bottom))\n    );\n  }\n\n  useDragSubscription(\"start\", ({ operation, interactionType, draggableItem, collisionRect, collisionIds }) => {\n    dispatch({\n      type: \"init\",\n      operation,\n      interactionType,\n      itemsLayout,\n      // TODO: resolve any\n      // The code only works assuming the board can take any draggable.\n      // If draggables can be of different types a check of some sort is required here.\n      draggableItem: draggableItem as BoardItemDefinitionBase<any>,\n      draggableRect: collisionRect,\n      collisionIds: interactionType === \"pointer\" && isElementOverBoard(collisionRect) ? collisionIds : [],\n    });\n\n    autoScrollHandlers.addPointerEventHandlers();\n  });\n\n  useDragSubscription(\"update\", ({ interactionType, collisionIds, positionOffset, collisionRect }) => {\n    dispatch({\n      type: \"update-with-pointer\",\n      collisionIds: interactionType === \"pointer\" && isElementOverBoard(collisionRect) ? collisionIds : [],\n      positionOffset,\n      draggableRect: collisionRect,\n    });\n  });\n\n  useDragSubscription(\"submit\", () => {\n    dispatch({ type: \"submit\" });\n\n    autoScrollHandlers.removePointerEventHandlers();\n\n    if (!transition) {\n      throw new Error(\"Invariant violation: no transition.\");\n    }\n    if (\n      !transition.layoutShift ||\n      transition.layoutShift.conflicts.length > 0 ||\n      transition.layoutShift.moves.length === 0\n    ) {\n      return null;\n    }\n\n    // Commit new layout for insert case.\n    if (transition.operation === \"insert\") {\n      onItemsChange(createItemsChangeEvent([...items, transition.draggableItem], transition.layoutShift));\n    }\n    // Commit new layout for reorder/resize case.\n    else {\n      onItemsChange(createItemsChangeEvent(items, transition.layoutShift));\n    }\n  });\n\n  useDragSubscription(\"discard\", () => {\n    dispatch({ type: \"discard\" });\n\n    autoScrollHandlers.removePointerEventHandlers();\n  });\n\n  useDragSubscription(\"acquire\", ({ droppableId, draggableItem, renderAcquiredItem }) => {\n    const placeholder = placeholdersLayout.items.find((it) => it.id === droppableId);\n\n    // If missing then it does not belong to this board.\n    if (!placeholder) {\n      return;\n    }\n\n    dispatch({\n      type: \"acquire-item\",\n      position: new Position({ x: placeholder.x, y: placeholder.y }),\n      layoutElement: containerAccessRef.current!,\n      acquiredItemElement: renderAcquiredItem(),\n    });\n    focusNextRenderIdRef.current = draggableItem.id;\n  });\n\n  const removeItemAction = (removedItem: BoardItemDefinition<D>) => {\n    dispatch({ type: \"init-remove\", items, itemsLayout, removedItem });\n  };\n\n  function onItemMove(direction: Direction) {\n    if (transition) {\n      dispatch({ type: \"update-with-keyboard\", direction });\n      autoScrollHandlers.scheduleActiveElementScrollIntoView(TRANSITION_DURATION_MS);\n    }\n  }\n\n  const announcement = transitionAnnouncement\n    ? announcementToString(transitionAnnouncement, items, i18nStrings, itemsLayout.columns)\n    : \"\";\n\n  return (\n    <div ref={__internalRootRef} {...getDataAttributes(rest)}>\n      <div ref={containerRef} className={clsx(styles.root, { [styles.empty]: rows === 0 })}>\n        {rows > 0 ? (\n          <Grid\n            isRtl={isRtl}\n            columns={itemsLayout.columns}\n            layout={[...placeholdersLayout.items, ...itemsLayout.items]}\n          >\n            {(gridContext) => {\n              const layoutShift = transition?.layoutShift ?? removeTransition?.layoutShift;\n              const transforms = layoutShift ? createTransforms(itemsLayout, layoutShift.moves, gridContext) : {};\n\n              // Exclude drag target from transforms.\n              if (transition && transition.interactionType === \"pointer\") {\n                delete transforms[transition.draggableItem.id];\n              }\n\n              const children: ReactNode[] = [];\n\n              /* Placeholders are rendered even when there is no transition to support the first collisions check. */\n              placeholdersLayout.items.forEach((placeholder) =>\n                children.push(\n                  <Placeholder\n                    key={placeholder.id}\n                    id={placeholder.id}\n                    state={transition ? (transition.collisionIds?.has(placeholder.id) ? \"hover\" : \"active\") : \"default\"}\n                    gridContext={gridContext}\n                    columns={itemsLayout.columns}\n                  />,\n                ),\n              );\n\n              items.forEach((item) => {\n                const layoutItem = layoutItemById.get(item.id);\n                const isResizing = transition?.operation === \"resize\" && transition?.draggableItem.id === item.id;\n\n                const itemSize = layoutItem ?? {\n                  width: getDefaultColumnSpan(item, itemsLayout.columns),\n                  height: getDefaultRowSpan(item),\n                };\n\n                const itemMaxSize =\n                  isResizing && layoutItem ? { width: itemsLayout.columns - layoutItem.x, height: 999 } : itemSize;\n\n                children.push(\n                  <ItemContainer\n                    key={item.id}\n                    ref={(elem) => {\n                      if (elem) {\n                        itemContainerRef.current[item.id] = elem;\n                      } else {\n                        delete itemContainerRef.current[item.id];\n                      }\n                    }}\n                    item={item}\n                    transform={transforms[item.id]}\n                    inTransition={!!transition || !!removeTransition}\n                    placed={item.id !== acquiredItem?.id}\n                    acquired={item.id === acquiredItem?.id}\n                    getItemSize={() => ({\n                      width: gridContext.getWidth(itemSize.width),\n                      minWidth: gridContext.getWidth(getMinColumnSpan(item, itemsLayout.columns)),\n                      maxWidth: gridContext.getWidth(itemMaxSize.width),\n                      height: gridContext.getHeight(itemSize.height),\n                      minHeight: gridContext.getHeight(getMinRowSpan(item)),\n                      maxHeight: gridContext.getHeight(itemMaxSize.height),\n                    })}\n                    onKeyMove={onItemMove}\n                    isRtl={isRtl}\n                  >\n                    {item.id === acquiredItem?.id && acquiredItemElement\n                      ? () => acquiredItemElement\n                      : () => renderItem(item, { removeItem: () => removeItemAction(item) })}\n                  </ItemContainer>,\n                );\n              });\n\n              return children;\n            }}\n          </Grid>\n        ) : (\n          empty\n        )}\n      </div>\n\n      <LiveRegion>{announcement}</LiveRegion>\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}