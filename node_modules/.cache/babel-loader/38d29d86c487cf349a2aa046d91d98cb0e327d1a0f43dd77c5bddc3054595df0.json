{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { fireNonCancelableEvent } from '../internal/events';\nimport { operatorToDescription } from './i18n-utils';\nimport { matchFilteringProperty, matchOperator, matchOperatorPrefix, matchTokenValue, removeOperator, tokenGroupToTokens, trimStart } from './utils';\nexport const getQueryActions = ({\n  query,\n  onChange,\n  filteringOptions,\n  enableTokenGroups\n}) => {\n  const setQuery = query => {\n    function transformToken(token) {\n      if ('operator' in token) {\n        return matchTokenValue(token, filteringOptions);\n      }\n      return Object.assign(Object.assign({}, token), {\n        tokens: token.tokens.map(transformToken)\n      });\n    }\n    const tokens = query.tokens.map(transformToken);\n    if (enableTokenGroups) {\n      fireNonCancelableEvent(onChange, {\n        tokens: [],\n        operation: query.operation,\n        tokenGroups: tokens\n      });\n    } else {\n      fireNonCancelableEvent(onChange, {\n        tokens: tokenGroupToTokens(tokens),\n        operation: query.operation\n      });\n    }\n  };\n  const addToken = token => {\n    setQuery(Object.assign(Object.assign({}, query), {\n      tokens: [...query.tokens, token]\n    }));\n  };\n  const updateToken = (updateIndex, updatedToken, releasedTokens) => {\n    const nestedTokens = tokenGroupToTokens([updatedToken]);\n    const capturedTokenIndices = nestedTokens.map(token => token.standaloneIndex).filter(index => index !== undefined);\n    const tokens = query.tokens.map((token, index) => index === updateIndex ? updatedToken : token).filter((_, index) => index === updateIndex || !capturedTokenIndices.includes(index));\n    tokens.push(...releasedTokens);\n    setQuery(Object.assign(Object.assign({}, query), {\n      tokens\n    }));\n  };\n  const removeToken = removeIndex => {\n    setQuery(Object.assign(Object.assign({}, query), {\n      tokens: query.tokens.filter((_, index) => index !== removeIndex)\n    }));\n  };\n  const removeAllTokens = () => {\n    setQuery(Object.assign(Object.assign({}, query), {\n      tokens: []\n    }));\n  };\n  const updateOperation = operation => {\n    setQuery(Object.assign(Object.assign({}, query), {\n      operation\n    }));\n  };\n  return {\n    addToken,\n    updateToken,\n    updateOperation,\n    removeToken,\n    removeAllTokens\n  };\n};\nexport const getAllowedOperators = property => {\n  const {\n    operators = [],\n    defaultOperator\n  } = property;\n  const operatorOrder = ['=', '!=', ':', '!:', '^', '!^', '>=', '<=', '<', '>'];\n  const operatorSet = new Set([defaultOperator, ...operators]);\n  return operatorOrder.filter(op => operatorSet.has(op));\n};\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\nexport const parseText = (filteringText, filteringProperties, freeTextFiltering) => {\n  const property = matchFilteringProperty(filteringProperties, filteringText);\n  if (!property) {\n    if (!freeTextFiltering.disabled) {\n      // For free text filtering, we allow ! as a shortcut for !:\n      const freeTextOperators = freeTextFiltering.operators.indexOf('!:') >= 0 ? ['!', ...freeTextFiltering.operators] : freeTextFiltering.operators;\n      const operator = matchOperator(freeTextOperators, filteringText);\n      if (operator) {\n        return {\n          step: 'free-text',\n          operator: operator === '!' ? '!:' : operator,\n          value: removeOperator(filteringText, operator)\n        };\n      }\n    }\n    return {\n      step: 'free-text',\n      value: filteringText\n    };\n  }\n  const allowedOps = getAllowedOperators(property);\n  const textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  const operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n  if (operator) {\n    return {\n      step: 'property',\n      property,\n      operator,\n      value: removeOperator(textWithoutProperty, operator)\n    };\n  }\n  const operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n  if (operatorPrefix !== null) {\n    return {\n      step: 'operator',\n      property,\n      operatorPrefix\n    };\n  }\n  return {\n    step: 'free-text',\n    value: filteringText\n  };\n};\nexport const getAllValueSuggestions = (filteringOptions, operator = '=', i18nStrings, customGroupsText) => {\n  var _a;\n  const defaultGroup = {\n    label: (_a = i18nStrings.groupValuesText) !== null && _a !== void 0 ? _a : '',\n    options: []\n  };\n  const customGroups = {};\n  filteringOptions.forEach(filteringOption => {\n    const property = filteringOption.property;\n    // given option refers to a non-existent filtering property\n    if (!property) {\n      return;\n    }\n    // this option's filtering property does not support current operator\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n    if (property.propertyGroup && !customGroups[property.propertyGroup]) {\n      const label = customGroupsText.reduce((acc, customGroup) => customGroup.group === property.propertyGroup ? customGroup.values : acc, '');\n      customGroups[property.propertyGroup] = {\n        label,\n        options: []\n      };\n    }\n    const propertyGroup = property.propertyGroup ? customGroups[property.propertyGroup] : defaultGroup;\n    propertyGroup.options.push({\n      value: property.propertyLabel + ' ' + (operator || '=') + ' ' + filteringOption.value,\n      label: filteringOption.label,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '=')\n    });\n  });\n  return [defaultGroup, ...Object.keys(customGroups).map(group => customGroups[group])];\n};\nconst filteringPropertyToAutosuggestOption = filteringProperty => ({\n  value: filteringProperty.propertyLabel,\n  label: filteringProperty.propertyLabel,\n  keepOpenOnSelect: true\n});\nexport function getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToOption) {\n  var _a;\n  const defaultGroup = {\n    label: (_a = i18nStrings.groupPropertiesText) !== null && _a !== void 0 ? _a : '',\n    options: []\n  };\n  const customGroups = {};\n  filteringProperties.forEach(filteringProperty => {\n    const {\n      propertyGroup\n    } = filteringProperty;\n    let optionsGroup = defaultGroup;\n    if (propertyGroup) {\n      if (!customGroups[propertyGroup]) {\n        const label = customGroupsText.reduce((acc, customGroup) => customGroup.group === propertyGroup ? customGroup.properties : acc, '');\n        customGroups[propertyGroup] = {\n          options: [],\n          label\n        };\n      }\n      optionsGroup = customGroups[propertyGroup];\n    }\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  const defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  const customGroupsArray = Object.keys(customGroups).map(groupKey => customGroups[groupKey]);\n  return [...defaultGroupArray, ...customGroupsArray];\n}\nexport const getAutosuggestOptions = (parsedText, filteringProperties, filteringOptions, customGroupsText, i18nStrings) => {\n  switch (parsedText.step) {\n    case 'property':\n      {\n        const {\n          propertyLabel,\n          groupValuesLabel\n        } = parsedText.property;\n        const options = filteringOptions.filter(o => o.property === parsedText.property);\n        return {\n          filterText: parsedText.value,\n          options: [{\n            options: options.map(({\n              label,\n              value\n            }) => ({\n              value: propertyLabel + ' ' + parsedText.operator + ' ' + value,\n              label: label,\n              __labelPrefix: propertyLabel + ' ' + parsedText.operator\n            })),\n            label: groupValuesLabel\n          }]\n        };\n      }\n    case 'operator':\n      {\n        return {\n          filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n          options: [...getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption), {\n            options: getAllowedOperators(parsedText.property).map(value => ({\n              value: parsedText.property.propertyLabel + ' ' + value + ' ',\n              label: parsedText.property.propertyLabel + ' ' + value,\n              description: operatorToDescription(value, i18nStrings),\n              keepOpenOnSelect: true\n            })),\n            label: i18nStrings.operatorsText\n          }]\n        };\n      }\n    case 'free-text':\n      {\n        const needsValueSuggestions = !!parsedText.value;\n        const needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n        return {\n          filterText: parsedText.value,\n          options: [...(needsPropertySuggestions ? getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption) : []), ...(needsValueSuggestions ? getAllValueSuggestions(filteringOptions, parsedText.operator, i18nStrings, customGroupsText) : [])]\n        };\n      }\n  }\n};","map":{"version":3,"names":["fireNonCancelableEvent","operatorToDescription","matchFilteringProperty","matchOperator","matchOperatorPrefix","matchTokenValue","removeOperator","tokenGroupToTokens","trimStart","getQueryActions","query","onChange","filteringOptions","enableTokenGroups","setQuery","transformToken","token","Object","assign","tokens","map","operation","tokenGroups","addToken","updateToken","updateIndex","updatedToken","releasedTokens","nestedTokens","capturedTokenIndices","standaloneIndex","filter","index","undefined","_","includes","push","removeToken","removeIndex","removeAllTokens","updateOperation","getAllowedOperators","property","operators","defaultOperator","operatorOrder","operatorSet","Set","op","has","parseText","filteringText","filteringProperties","freeTextFiltering","disabled","freeTextOperators","indexOf","operator","step","value","allowedOps","textWithoutProperty","substring","propertyLabel","length","operatorPrefix","getAllValueSuggestions","i18nStrings","customGroupsText","defaultGroup","label","_a","groupValuesText","options","customGroups","forEach","filteringOption","propertyGroup","reduce","acc","customGroup","group","values","__labelPrefix","keys","filteringPropertyToAutosuggestOption","filteringProperty","keepOpenOnSelect","getPropertySuggestions","filteringPropertyToOption","groupPropertiesText","optionsGroup","properties","defaultGroupArray","customGroupsArray","groupKey","getAutosuggestOptions","parsedText","groupValuesLabel","o","filterText","description","operatorsText","needsValueSuggestions","needsPropertySuggestions"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/property-filter/controller.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AutosuggestProps } from '../autosuggest/interfaces';\nimport { fireNonCancelableEvent, NonCancelableEventHandler } from '../internal/events';\nimport { I18nStringsOperators, operatorToDescription } from './i18n-utils';\nimport {\n  ComparisonOperator,\n  GroupText,\n  I18nStrings,\n  InternalFilteringOption,\n  InternalFilteringProperty,\n  InternalFreeTextFiltering,\n  InternalQuery,\n  InternalToken,\n  InternalTokenGroup,\n  JoinOperation,\n  ParsedText,\n  Query,\n  Token,\n  TokenGroup,\n} from './interfaces';\nimport {\n  matchFilteringProperty,\n  matchOperator,\n  matchOperatorPrefix,\n  matchTokenValue,\n  removeOperator,\n  tokenGroupToTokens,\n  trimStart,\n} from './utils';\n\ntype I18nStringsController = I18nStringsOperators &\n  Pick<I18nStrings, 'operatorsText' | 'groupPropertiesText' | 'groupValuesText'>;\n\nexport const getQueryActions = ({\n  query,\n  onChange,\n  filteringOptions,\n  enableTokenGroups,\n}: {\n  query: InternalQuery;\n  onChange: NonCancelableEventHandler<Query>;\n  filteringOptions: readonly InternalFilteringOption[];\n  enableTokenGroups: boolean;\n}) => {\n  const setQuery = (query: InternalQuery) => {\n    function transformToken(token: InternalToken | InternalTokenGroup): Token | TokenGroup {\n      if ('operator' in token) {\n        return matchTokenValue(token, filteringOptions);\n      }\n      return { ...token, tokens: token.tokens.map(transformToken) };\n    }\n    const tokens = query.tokens.map(transformToken);\n\n    if (enableTokenGroups) {\n      fireNonCancelableEvent(onChange, { tokens: [], operation: query.operation, tokenGroups: tokens });\n    } else {\n      fireNonCancelableEvent(onChange, { tokens: tokenGroupToTokens<Token>(tokens), operation: query.operation });\n    }\n  };\n\n  const addToken = (token: InternalToken) => {\n    setQuery({ ...query, tokens: [...query.tokens, token] });\n  };\n\n  const updateToken = (\n    updateIndex: number,\n    updatedToken: InternalToken | InternalTokenGroup,\n    releasedTokens: InternalToken[]\n  ) => {\n    const nestedTokens = tokenGroupToTokens<InternalToken>([updatedToken]);\n    const capturedTokenIndices = nestedTokens.map(token => token.standaloneIndex).filter(index => index !== undefined);\n    const tokens = query.tokens\n      .map((token, index) => (index === updateIndex ? updatedToken : token))\n      .filter((_, index) => index === updateIndex || !capturedTokenIndices.includes(index));\n    tokens.push(...releasedTokens);\n    setQuery({ ...query, tokens });\n  };\n\n  const removeToken = (removeIndex: number) => {\n    setQuery({ ...query, tokens: query.tokens.filter((_, index) => index !== removeIndex) });\n  };\n\n  const removeAllTokens = () => {\n    setQuery({ ...query, tokens: [] });\n  };\n\n  const updateOperation = (operation: JoinOperation) => {\n    setQuery({ ...query, operation });\n  };\n\n  return { addToken, updateToken, updateOperation, removeToken, removeAllTokens };\n};\n\nexport const getAllowedOperators = (property: InternalFilteringProperty): ComparisonOperator[] => {\n  const { operators = [], defaultOperator } = property;\n  const operatorOrder = ['=', '!=', ':', '!:', '^', '!^', '>=', '<=', '<', '>'] as const;\n  const operatorSet = new Set([defaultOperator, ...operators]);\n  return operatorOrder.filter(op => operatorSet.has(op));\n};\n\n/*\n * parses the value of the filtering input to figure out the current step of entering the token:\n * - \"property\": means that a filter on a particular column is being added, with operator already finalized\n * - \"operator\": means that a filter on a particular column is being added, with operator not yet finalized\n * - \"free-text\": means that a \"free text\" token is being added\n */\nexport const parseText = (\n  filteringText: string,\n  filteringProperties: readonly InternalFilteringProperty[],\n  freeTextFiltering: InternalFreeTextFiltering\n): ParsedText => {\n  const property = matchFilteringProperty(filteringProperties, filteringText);\n  if (!property) {\n    if (!freeTextFiltering.disabled) {\n      // For free text filtering, we allow ! as a shortcut for !:\n      const freeTextOperators =\n        freeTextFiltering.operators.indexOf('!:') >= 0\n          ? ['!', ...freeTextFiltering.operators]\n          : freeTextFiltering.operators;\n      const operator = matchOperator(freeTextOperators, filteringText);\n      if (operator) {\n        return {\n          step: 'free-text',\n          operator: operator === '!' ? '!:' : operator,\n          value: removeOperator(filteringText, operator),\n        };\n      }\n    }\n\n    return {\n      step: 'free-text',\n      value: filteringText,\n    };\n  }\n\n  const allowedOps = getAllowedOperators(property);\n\n  const textWithoutProperty = filteringText.substring(property.propertyLabel.length);\n  const operator = matchOperator(allowedOps, trimStart(textWithoutProperty));\n  if (operator) {\n    return {\n      step: 'property',\n      property,\n      operator,\n      value: removeOperator(textWithoutProperty, operator),\n    };\n  }\n\n  const operatorPrefix = matchOperatorPrefix(allowedOps, trimStart(textWithoutProperty));\n  if (operatorPrefix !== null) {\n    return { step: 'operator', property, operatorPrefix };\n  }\n\n  return {\n    step: 'free-text',\n    value: filteringText,\n  };\n};\n\ninterface OptionGroup<T> {\n  label: string;\n  options: T[];\n}\n\nexport const getAllValueSuggestions = (\n  filteringOptions: readonly InternalFilteringOption[],\n  operator: ComparisonOperator | undefined = '=',\n  i18nStrings: I18nStringsController,\n  customGroupsText: readonly GroupText[]\n) => {\n  const defaultGroup: OptionGroup<AutosuggestProps.Option> = {\n    label: i18nStrings.groupValuesText ?? '',\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<AutosuggestProps.Option> } = {};\n  filteringOptions.forEach(filteringOption => {\n    const property = filteringOption.property;\n    // given option refers to a non-existent filtering property\n    if (!property) {\n      return;\n    }\n    // this option's filtering property does not support current operator\n    if (getAllowedOperators(property).indexOf(operator) === -1) {\n      return;\n    }\n    if (property.propertyGroup && !customGroups[property.propertyGroup]) {\n      const label = customGroupsText.reduce<string>(\n        (acc, customGroup) => (customGroup.group === property.propertyGroup ? customGroup.values : acc),\n        ''\n      );\n      customGroups[property.propertyGroup] = {\n        label,\n        options: [],\n      };\n    }\n    const propertyGroup = property.propertyGroup ? customGroups[property.propertyGroup] : defaultGroup;\n    propertyGroup.options.push({\n      value: property.propertyLabel + ' ' + (operator || '=') + ' ' + filteringOption.value,\n      label: filteringOption.label,\n      __labelPrefix: property.propertyLabel + ' ' + (operator || '='),\n    });\n  });\n  return [defaultGroup, ...Object.keys(customGroups).map(group => customGroups[group])];\n};\n\nconst filteringPropertyToAutosuggestOption = (filteringProperty: InternalFilteringProperty) => ({\n  value: filteringProperty.propertyLabel,\n  label: filteringProperty.propertyLabel,\n  keepOpenOnSelect: true,\n});\n\nexport function getPropertySuggestions<T>(\n  filteringProperties: readonly InternalFilteringProperty[],\n  customGroupsText: readonly GroupText[],\n  i18nStrings: I18nStringsController,\n  filteringPropertyToOption: (filteringProperty: InternalFilteringProperty) => T\n) {\n  const defaultGroup: OptionGroup<T> = {\n    label: i18nStrings.groupPropertiesText ?? '',\n    options: [],\n  };\n  const customGroups: { [K in string]: OptionGroup<T> } = {};\n\n  filteringProperties.forEach(filteringProperty => {\n    const { propertyGroup } = filteringProperty;\n    let optionsGroup = defaultGroup;\n    if (propertyGroup) {\n      if (!customGroups[propertyGroup]) {\n        const label = customGroupsText.reduce<string>(\n          (acc, customGroup) => (customGroup.group === propertyGroup ? customGroup.properties : acc),\n          ''\n        );\n        customGroups[propertyGroup] = { options: [], label };\n      }\n      optionsGroup = customGroups[propertyGroup];\n    }\n    optionsGroup.options.push(filteringPropertyToOption(filteringProperty));\n  });\n  const defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];\n  const customGroupsArray = Object.keys(customGroups).map(groupKey => customGroups[groupKey]);\n  return [...defaultGroupArray, ...customGroupsArray];\n}\n\nexport const getAutosuggestOptions = (\n  parsedText: ParsedText,\n  filteringProperties: readonly InternalFilteringProperty[],\n  filteringOptions: readonly InternalFilteringOption[],\n  customGroupsText: readonly GroupText[],\n  i18nStrings: I18nStringsController\n) => {\n  switch (parsedText.step) {\n    case 'property': {\n      const { propertyLabel, groupValuesLabel } = parsedText.property;\n      const options = filteringOptions.filter(o => o.property === parsedText.property);\n      return {\n        filterText: parsedText.value,\n        options: [\n          {\n            options: options.map(({ label, value }) => ({\n              value: propertyLabel + ' ' + parsedText.operator + ' ' + value,\n              label: label,\n              __labelPrefix: propertyLabel + ' ' + parsedText.operator,\n            })),\n            label: groupValuesLabel,\n          },\n        ],\n      };\n    }\n    case 'operator': {\n      return {\n        filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,\n        options: [\n          ...getPropertySuggestions(\n            filteringProperties,\n            customGroupsText,\n            i18nStrings,\n            filteringPropertyToAutosuggestOption\n          ),\n          {\n            options: getAllowedOperators(parsedText.property).map(value => ({\n              value: parsedText.property.propertyLabel + ' ' + value + ' ',\n              label: parsedText.property.propertyLabel + ' ' + value,\n              description: operatorToDescription(value, i18nStrings),\n              keepOpenOnSelect: true,\n            })),\n            label: i18nStrings.operatorsText,\n          },\n        ],\n      };\n    }\n    case 'free-text': {\n      const needsValueSuggestions = !!parsedText.value;\n      const needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');\n      return {\n        filterText: parsedText.value,\n        options: [\n          ...(needsPropertySuggestions\n            ? getPropertySuggestions(\n                filteringProperties,\n                customGroupsText,\n                i18nStrings,\n                filteringPropertyToAutosuggestOption\n              )\n            : []),\n          ...(needsValueSuggestions\n            ? getAllValueSuggestions(filteringOptions, parsedText.operator, i18nStrings, customGroupsText)\n            : []),\n        ],\n      };\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}