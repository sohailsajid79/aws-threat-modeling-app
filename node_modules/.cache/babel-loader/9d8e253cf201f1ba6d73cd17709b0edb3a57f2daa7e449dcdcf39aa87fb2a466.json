{"ast":null,"code":"/* eslint-disable header/header */\n// Source https://stackoverflow.com/a/65186378/16648714\nexport function createOneSideRoundedRectPath({\n  x,\n  y,\n  width,\n  height\n}, radius, side) {\n  const coordinates = [{\n    x,\n    y\n  }, {\n    x: x + width,\n    y\n  }, {\n    x: x + width,\n    y: y + height\n  }, {\n    x: x,\n    y: y + height\n  }];\n  // Starting from the target side.\n  const startIndex = {\n    left: 2,\n    right: 0,\n    top: 3,\n    bottom: 1\n  }[side];\n  let path = '';\n  for (let i = startIndex; i < startIndex + coordinates.length + 1; i++) {\n    const start = coordinates[i % coordinates.length];\n    const end = coordinates[(i + 1) % coordinates.length];\n    // Define curvature for the first 3 points to only add rounded corners to the first side.\n    const c = radius && i < startIndex + 3 ? Math.min(radius / Math.hypot(end.x - start.x, end.y - start.y), 0.5) : 0;\n    // Insert start point. When c=0 the start point is [start.x, start.y].\n    if (i === startIndex) {\n      path += `M${start.x * (1 - c) + end.x * c},${start.y * (1 - c) + end.y * c}`;\n    }\n    // Insert quadratic curve.\n    if (i > startIndex) {\n      path += `Q${start.x},${start.y} ${start.x * (1 - c) + end.x * c},${start.y * (1 - c) + end.y * c}`;\n    }\n    // Draw line to the end point. When c=0 the end point is [end.x, end.y].\n    if (i < startIndex + coordinates.length) {\n      path += `L${start.x * c + end.x * (1 - c)},${start.y * c + end.y * (1 - c)}`;\n    }\n  }\n  return path + 'Z';\n}","map":{"version":3,"names":["createOneSideRoundedRectPath","x","y","width","height","radius","side","coordinates","startIndex","left","right","top","bottom","path","i","length","start","end","c","Math","min","hypot"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/create-one-side-rounded-rect-path.ts"],"sourcesContent":["/* eslint-disable header/header */\n// Source https://stackoverflow.com/a/65186378/16648714\n\nexport function createOneSideRoundedRectPath(\n  { x, y, width, height }: { x: number; y: number; width: number; height: number },\n  radius: number,\n  side: 'left' | 'right' | 'top' | 'bottom'\n) {\n  const coordinates = [\n    { x, y },\n    { x: x + width, y },\n    { x: x + width, y: y + height },\n    { x: x, y: y + height },\n  ];\n\n  // Starting from the target side.\n  const startIndex = { left: 2, right: 0, top: 3, bottom: 1 }[side];\n\n  let path = '';\n  for (let i = startIndex; i < startIndex + coordinates.length + 1; i++) {\n    const start = coordinates[i % coordinates.length];\n    const end = coordinates[(i + 1) % coordinates.length];\n\n    // Define curvature for the first 3 points to only add rounded corners to the first side.\n    const c = radius && i < startIndex + 3 ? Math.min(radius / Math.hypot(end.x - start.x, end.y - start.y), 0.5) : 0;\n\n    // Insert start point. When c=0 the start point is [start.x, start.y].\n    if (i === startIndex) {\n      path += `M${start.x * (1 - c) + end.x * c},${start.y * (1 - c) + end.y * c}`;\n    }\n    // Insert quadratic curve.\n    if (i > startIndex) {\n      path += `Q${start.x},${start.y} ${start.x * (1 - c) + end.x * c},${start.y * (1 - c) + end.y * c}`;\n    }\n    // Draw line to the end point. When c=0 the end point is [end.x, end.y].\n    if (i < startIndex + coordinates.length) {\n      path += `L${start.x * c + end.x * (1 - c)},${start.y * c + end.y * (1 - c)}`;\n    }\n  }\n  return path + 'Z';\n}\n"],"mappings":"AAAA;AACA;AAEA,OAAM,SAAUA,4BAA4BA,CAC1C;EAAEC,CAAC;EAAEC,CAAC;EAAEC,KAAK;EAAEC;AAAM,CAA2D,EAChFC,MAAc,EACdC,IAAyC;EAEzC,MAAMC,WAAW,GAAG,CAClB;IAAEN,CAAC;IAAEC;EAAC,CAAE,EACR;IAAED,CAAC,EAAEA,CAAC,GAAGE,KAAK;IAAED;EAAC,CAAE,EACnB;IAAED,CAAC,EAAEA,CAAC,GAAGE,KAAK;IAAED,CAAC,EAAEA,CAAC,GAAGE;EAAM,CAAE,EAC/B;IAAEH,CAAC,EAAEA,CAAC;IAAEC,CAAC,EAAEA,CAAC,GAAGE;EAAM,CAAE,CACxB;EAED;EACA,MAAMI,UAAU,GAAG;IAAEC,IAAI,EAAE,CAAC;IAAEC,KAAK,EAAE,CAAC;IAAEC,GAAG,EAAE,CAAC;IAAEC,MAAM,EAAE;EAAC,CAAE,CAACN,IAAI,CAAC;EAEjE,IAAIO,IAAI,GAAG,EAAE;EACb,KAAK,IAAIC,CAAC,GAAGN,UAAU,EAAEM,CAAC,GAAGN,UAAU,GAAGD,WAAW,CAACQ,MAAM,GAAG,CAAC,EAAED,CAAC,EAAE,EAAE;IACrE,MAAME,KAAK,GAAGT,WAAW,CAACO,CAAC,GAAGP,WAAW,CAACQ,MAAM,CAAC;IACjD,MAAME,GAAG,GAAGV,WAAW,CAAC,CAACO,CAAC,GAAG,CAAC,IAAIP,WAAW,CAACQ,MAAM,CAAC;IAErD;IACA,MAAMG,CAAC,GAAGb,MAAM,IAAIS,CAAC,GAAGN,UAAU,GAAG,CAAC,GAAGW,IAAI,CAACC,GAAG,CAACf,MAAM,GAAGc,IAAI,CAACE,KAAK,CAACJ,GAAG,CAAChB,CAAC,GAAGe,KAAK,CAACf,CAAC,EAAEgB,GAAG,CAACf,CAAC,GAAGc,KAAK,CAACd,CAAC,CAAC,EAAE,GAAG,CAAC,GAAG,CAAC;IAEjH;IACA,IAAIY,CAAC,KAAKN,UAAU,EAAE;MACpBK,IAAI,IAAI,IAAIG,KAAK,CAACf,CAAC,IAAI,CAAC,GAAGiB,CAAC,CAAC,GAAGD,GAAG,CAAChB,CAAC,GAAGiB,CAAC,IAAIF,KAAK,CAACd,CAAC,IAAI,CAAC,GAAGgB,CAAC,CAAC,GAAGD,GAAG,CAACf,CAAC,GAAGgB,CAAC,EAAE;;IAE9E;IACA,IAAIJ,CAAC,GAAGN,UAAU,EAAE;MAClBK,IAAI,IAAI,IAAIG,KAAK,CAACf,CAAC,IAAIe,KAAK,CAACd,CAAC,IAAIc,KAAK,CAACf,CAAC,IAAI,CAAC,GAAGiB,CAAC,CAAC,GAAGD,GAAG,CAAChB,CAAC,GAAGiB,CAAC,IAAIF,KAAK,CAACd,CAAC,IAAI,CAAC,GAAGgB,CAAC,CAAC,GAAGD,GAAG,CAACf,CAAC,GAAGgB,CAAC,EAAE;;IAEpG;IACA,IAAIJ,CAAC,GAAGN,UAAU,GAAGD,WAAW,CAACQ,MAAM,EAAE;MACvCF,IAAI,IAAI,IAAIG,KAAK,CAACf,CAAC,GAAGiB,CAAC,GAAGD,GAAG,CAAChB,CAAC,IAAI,CAAC,GAAGiB,CAAC,CAAC,IAAIF,KAAK,CAACd,CAAC,GAAGgB,CAAC,GAAGD,GAAG,CAACf,CAAC,IAAI,CAAC,GAAGgB,CAAC,CAAC,EAAE;;;EAGhF,OAAOL,IAAI,GAAG,GAAG;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}