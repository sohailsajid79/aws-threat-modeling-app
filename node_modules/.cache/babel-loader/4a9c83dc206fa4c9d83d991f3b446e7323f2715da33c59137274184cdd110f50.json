{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nfunction iterateTableCells(table, func) {\n  table.querySelectorAll('tr').forEach((row, rowIndex) => {\n    row.querySelectorAll('td').forEach((cell, cellIndex) => {\n      func(cell, rowIndex, cellIndex);\n    });\n  });\n}\n/**\n * This hook is used to navigate between table cells using the keyboard arrow keys.\n * All the functionality is implemented in the hook, so the table component does not\n * need to implement any keyboard event handlers.\n * @param enable - Toggle functionality of the hook\n * @param tableRoot - A ref to a table container. Ideally the root element of the table (<table>); tbody is also acceptable.\n * @param columnDefinitions - The column definitions for the table.\n * @param numRows - The number of rows in the table.\n */\nfunction useTableFocusNavigation({\n  enableKeyboardNavigation,\n  selectionType,\n  tableRoot,\n  columnDefinitions,\n  numRows\n}) {\n  const focusableColumns = useMemo(() => {\n    const cols = columnDefinitions.map(column => !!column.editConfig);\n    if (selectionType) {\n      cols.unshift(false);\n    }\n    return cols;\n  }, [columnDefinitions, selectionType]);\n  const maxColumnIndex = focusableColumns.length - 1;\n  const minColumnIndex = selectionType ? 1 : 0;\n  const focusCell = useCallback((rowIndex, columnIndex) => {\n    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {\n      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {\n        var _a;\n        if (rIndex === rowIndex && cIndex === columnIndex) {\n          const editButton = cell.querySelector('button:last-child');\n          if (editButton) {\n            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);\n            scrollElementIntoView(editButton);\n          }\n        }\n      });\n    }\n  }, [tableRoot]);\n  const shiftFocus = useCallback((vertical, horizontal) => {\n    var _a;\n    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('td:focus-within');\n    if (!focusedCell) {\n      return;\n    }\n    const columnIndex = focusedCell.cellIndex;\n    const rowIndex = focusedCell.parentElement.rowIndex;\n    let newRowIndex = rowIndex;\n    let newColumnIndex = columnIndex;\n    if (vertical !== 0) {\n      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));\n    }\n    if (horizontal !== 0) {\n      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {\n        newColumnIndex += horizontal;\n        if (focusableColumns[newColumnIndex]) {\n          break;\n        }\n      }\n    }\n    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {\n      focusCell(newRowIndex, newColumnIndex);\n    }\n  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);\n  const handleArrowKeyEvents = useCallback(event => {\n    var _a, _b;\n    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = \"true\"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest('[data-inline-editing-active]'));\n    if (abort) {\n      return;\n    }\n    switch (event.key) {\n      case 'ArrowUp':\n        event.preventDefault();\n        shiftFocus(-1, 0);\n        break;\n      case 'ArrowDown':\n        event.preventDefault();\n        shiftFocus(1, 0);\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        shiftFocus(0, -1);\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        shiftFocus(0, 1);\n        break;\n      // istanbul ignore next (default case = do nothing, not testable)\n      default:\n        return;\n    }\n  }, [shiftFocus, tableRoot]);\n  useEffect(() => {\n    if (!tableRoot.current || enableKeyboardNavigation) {\n      return;\n    }\n    const tableElement = tableRoot.current;\n    tableRoot.current.addEventListener('keydown', handleArrowKeyEvents);\n    return () => tableElement && tableElement.removeEventListener('keydown', handleArrowKeyEvents);\n  }, [enableKeyboardNavigation, focusableColumns, handleArrowKeyEvents, tableRoot]);\n}\nexport default useTableFocusNavigation;","map":{"version":3,"names":["useCallback","useEffect","useMemo","scrollElementIntoView","iterateTableCells","table","func","querySelectorAll","forEach","row","rowIndex","cell","cellIndex","useTableFocusNavigation","enableKeyboardNavigation","selectionType","tableRoot","columnDefinitions","numRows","focusableColumns","cols","map","column","editConfig","unshift","maxColumnIndex","length","minColumnIndex","focusCell","columnIndex","current","rIndex","cIndex","editButton","querySelector","_a","focus","call","shiftFocus","vertical","horizontal","focusedCell","parentElement","newRowIndex","newColumnIndex","Math","min","max","handleArrowKeyEvents","event","abort","_b","document","activeElement","closest","key","preventDefault","tableElement","addEventListener","removeEventListener"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/table/use-table-focus-navigation.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RefObject, useCallback, useEffect, useMemo } from 'react';\n\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { TableProps } from './interfaces';\n\nfunction iterateTableCells<T extends HTMLElement>(\n  table: T,\n  func: (cell: HTMLTableCellElement, rowIndex: number, columnIndex: number) => void\n) {\n  table.querySelectorAll('tr').forEach((row: HTMLTableRowElement, rowIndex: number) => {\n    row.querySelectorAll('td').forEach((cell, cellIndex) => {\n      func(cell, rowIndex, cellIndex);\n    });\n  });\n}\n\ninterface TableFocusNavigationProps<T> {\n  enableKeyboardNavigation?: boolean;\n  selectionType: TableProps['selectionType'];\n  tableRoot: RefObject<HTMLTableElement>;\n  columnDefinitions: Readonly<T[]>;\n  numRows: number;\n}\n\n/**\n * This hook is used to navigate between table cells using the keyboard arrow keys.\n * All the functionality is implemented in the hook, so the table component does not\n * need to implement any keyboard event handlers.\n * @param enable - Toggle functionality of the hook\n * @param tableRoot - A ref to a table container. Ideally the root element of the table (<table>); tbody is also acceptable.\n * @param columnDefinitions - The column definitions for the table.\n * @param numRows - The number of rows in the table.\n */\nfunction useTableFocusNavigation<T extends { editConfig?: TableProps.EditConfig<any> }>({\n  enableKeyboardNavigation,\n  selectionType,\n  tableRoot,\n  columnDefinitions,\n  numRows,\n}: TableFocusNavigationProps<T>) {\n  const focusableColumns = useMemo(() => {\n    const cols = columnDefinitions.map(column => !!column.editConfig);\n    if (selectionType) {\n      cols.unshift(false);\n    }\n    return cols;\n  }, [columnDefinitions, selectionType]);\n\n  const maxColumnIndex = focusableColumns.length - 1;\n  const minColumnIndex = selectionType ? 1 : 0;\n\n  const focusCell = useCallback(\n    (rowIndex: number, columnIndex: number) => {\n      if (tableRoot?.current) {\n        iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {\n          if (rIndex === rowIndex && cIndex === columnIndex) {\n            const editButton = cell.querySelector('button:last-child') as HTMLButtonElement | null;\n\n            if (editButton) {\n              editButton.focus?.();\n              scrollElementIntoView(editButton);\n            }\n          }\n        });\n      }\n    },\n    [tableRoot]\n  );\n\n  const shiftFocus = useCallback(\n    (vertical: -1 | 0 | 1, horizontal: -1 | 0 | 1) => {\n      const focusedCell = tableRoot.current?.querySelector<HTMLTableCellElement>('td:focus-within');\n      if (!focusedCell) {\n        return;\n      }\n\n      const columnIndex = focusedCell.cellIndex;\n      const rowIndex = (focusedCell.parentElement as HTMLTableRowElement).rowIndex;\n\n      let newRowIndex = rowIndex;\n      let newColumnIndex = columnIndex;\n\n      if (vertical !== 0) {\n        newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));\n      }\n\n      if (horizontal !== 0) {\n        while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {\n          newColumnIndex += horizontal;\n          if (focusableColumns[newColumnIndex]) {\n            break;\n          }\n        }\n      }\n\n      if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {\n        focusCell(newRowIndex, newColumnIndex);\n      }\n    },\n    [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]\n  );\n\n  const handleArrowKeyEvents = useCallback(\n    (event: KeyboardEvent) => {\n      const abort =\n        !!tableRoot.current?.querySelector('[data-inline-editing-active = \"true\"]') ||\n        !document.activeElement?.closest('[data-inline-editing-active]');\n\n      if (abort) {\n        return;\n      }\n      switch (event.key) {\n        case 'ArrowUp':\n          event.preventDefault();\n          shiftFocus(-1, 0);\n          break;\n        case 'ArrowDown':\n          event.preventDefault();\n          shiftFocus(1, 0);\n          break;\n        case 'ArrowLeft':\n          event.preventDefault();\n          shiftFocus(0, -1);\n          break;\n        case 'ArrowRight':\n          event.preventDefault();\n          shiftFocus(0, 1);\n          break;\n        // istanbul ignore next (default case = do nothing, not testable)\n        default:\n          return;\n      }\n    },\n    [shiftFocus, tableRoot]\n  );\n\n  useEffect(() => {\n    if (!tableRoot.current || enableKeyboardNavigation) {\n      return;\n    }\n\n    const tableElement = tableRoot.current;\n    tableRoot.current.addEventListener('keydown', handleArrowKeyEvents);\n\n    return () => tableElement && tableElement.removeEventListener('keydown', handleArrowKeyEvents);\n  }, [enableKeyboardNavigation, focusableColumns, handleArrowKeyEvents, tableRoot]);\n}\n\nexport default useTableFocusNavigation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}