{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef {import('../matters.js').Info} Info\n * @typedef {import('../matters.js').Matter} Matter\n * @typedef {import('../matters.js').Options} Options\n */\n\nimport { markdownLineEnding, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\nimport { matters } from '../matters.js';\n\n/**\n * Create an extension for `micromark` to enable frontmatter syntax.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable frontmatter syntax.\n */\nexport function frontmatter(options) {\n  const listOfMatters = matters(options);\n  /** @type {ConstructRecord} */\n  const flow = {};\n  let index = -1;\n  while (++index < listOfMatters.length) {\n    const matter = listOfMatters[index];\n    const code = fence(matter, 'open').charCodeAt(0);\n    const construct = createConstruct(matter);\n    const existing = flow[code];\n    if (Array.isArray(existing)) {\n      existing.push(construct);\n    } else {\n      // Never a single object, always an array.\n      flow[code] = [construct];\n    }\n  }\n  return {\n    flow\n  };\n}\n\n/**\n * @param {Matter} matter\n * @returns {Construct}\n */\nfunction createConstruct(matter) {\n  const anywhere = matter.anywhere;\n  const frontmatterType = /** @type {TokenType} */matter.type;\n  const fenceType = /** @type {TokenType} */frontmatterType + 'Fence';\n  const sequenceType = /** @type {TokenType} */fenceType + 'Sequence';\n  const valueType = /** @type {TokenType} */frontmatterType + 'Value';\n  const closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  };\n\n  /**\n   * Fence to look for.\n   *\n   * @type {string}\n   */\n  let buffer;\n  let bufferIndex = 0;\n  return {\n    tokenize: tokenizeFrontmatter,\n    concrete: true\n  };\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFrontmatter(effects, ok, nok) {\n    const self = this;\n    return start;\n\n    /**\n     * Start of frontmatter.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      const position = self.now();\n      if (\n      // Indent not allowed.\n      position.column === 1 && (\n      // Normally, only allowed in first line.\n      position.line === 1 || anywhere)) {\n        buffer = fence(matter, 'open');\n        bufferIndex = 0;\n        if (code === buffer.charCodeAt(bufferIndex)) {\n          effects.enter(frontmatterType);\n          effects.enter(fenceType);\n          effects.enter(sequenceType);\n          return openSequence(code);\n        }\n      }\n      return nok(code);\n    }\n\n    /**\n     * In open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType);\n        if (markdownSpace(code)) {\n          effects.enter(types.whitespace);\n          return openSequenceWhitespace(code);\n        }\n        return openAfter(code);\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code);\n        return openSequence;\n      }\n      return nok(code);\n    }\n\n    /**\n     * In whitespace after open sequence.\n     *\n     * ```markdown\n     * > | ---␠\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return openSequenceWhitespace;\n      }\n      effects.exit(types.whitespace);\n      return openAfter(code);\n    }\n\n    /**\n     * After open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openAfter(code) {\n      if (markdownLineEnding(code)) {\n        effects.exit(fenceType);\n        effects.enter(types.lineEnding);\n        effects.consume(code);\n        effects.exit(types.lineEnding);\n        // Get ready for closing fence.\n        buffer = fence(matter, 'close');\n        bufferIndex = 0;\n        return effects.attempt(closingFenceConstruct, after, contentStart);\n      }\n\n      // EOF is not okay.\n      return nok(code);\n    }\n\n    /**\n     * Start of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentStart(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        return contentEnd(code);\n      }\n      effects.enter(valueType);\n      return contentInside(code);\n    }\n\n    /**\n     * In content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentInside(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(valueType);\n        return contentEnd(code);\n      }\n      effects.consume(code);\n      return contentInside;\n    }\n\n    /**\n     * End of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *                   ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentEnd(code) {\n      // Require a closing fence.\n      if (code === codes.eof) {\n        return nok(code);\n      }\n\n      // Can only be an eol.\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return effects.attempt(closingFenceConstruct, after, contentStart);\n    }\n\n    /**\n     * After frontmatter.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      // `code` must be eol/eof.\n      effects.exit(frontmatterType);\n      return ok(code);\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let bufferIndex = 0;\n    return closeStart;\n\n    /**\n     * Start of close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeStart(code) {\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.enter(fenceType);\n        effects.enter(sequenceType);\n        return closeSequence(code);\n      }\n      return nok(code);\n    }\n\n    /**\n     * In close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType);\n        if (markdownSpace(code)) {\n          effects.enter(types.whitespace);\n          return closeSequenceWhitespace(code);\n        }\n        return closeAfter(code);\n      }\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code);\n        return closeSequence;\n      }\n      return nok(code);\n    }\n\n    /**\n     * In whitespace after close sequence.\n     *\n     * ```markdown\n     * > | ---\n     *   | title: \"Venus\"\n     *   | ---␠\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code);\n        return closeSequenceWhitespace;\n      }\n      effects.exit(types.whitespace);\n      return closeAfter(code);\n    }\n\n    /**\n     * After close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(fenceType);\n        return ok(code);\n      }\n      return nok(code);\n    }\n  }\n}\n\n/**\n * @param {Matter} matter\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction fence(matter, prop) {\n  return matter.marker ? pick(matter.marker, prop).repeat(3) :\n  // @ts-expect-error: They’re mutually exclusive.\n  pick(matter.fence, prop);\n}\n\n/**\n * @param {Info | string} schema\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop];\n}","map":{"version":3,"names":["markdownLineEnding","markdownSpace","codes","types","matters","frontmatter","options","listOfMatters","flow","index","length","matter","code","fence","charCodeAt","construct","createConstruct","existing","Array","isArray","push","anywhere","frontmatterType","type","fenceType","sequenceType","valueType","closingFenceConstruct","tokenize","tokenizeClosingFence","partial","buffer","bufferIndex","tokenizeFrontmatter","concrete","effects","ok","nok","self","start","position","now","column","line","enter","openSequence","exit","whitespace","openSequenceWhitespace","openAfter","consume","lineEnding","attempt","after","contentStart","eof","contentEnd","contentInside","closeStart","closeSequence","closeSequenceWhitespace","closeAfter","prop","marker","pick","repeat","schema"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/micromark-extension-frontmatter/dev/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenType} TokenType\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n *\n * @typedef {import('../matters.js').Info} Info\n * @typedef {import('../matters.js').Matter} Matter\n * @typedef {import('../matters.js').Options} Options\n */\n\nimport {markdownLineEnding, markdownSpace} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\nimport {matters} from '../matters.js'\n\n/**\n * Create an extension for `micromark` to enable frontmatter syntax.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration.\n * @returns {Extension}\n *   Extension for `micromark` that can be passed in `extensions`, to\n *   enable frontmatter syntax.\n */\nexport function frontmatter(options) {\n  const listOfMatters = matters(options)\n  /** @type {ConstructRecord} */\n  const flow = {}\n  let index = -1\n\n  while (++index < listOfMatters.length) {\n    const matter = listOfMatters[index]\n    const code = fence(matter, 'open').charCodeAt(0)\n    const construct = createConstruct(matter)\n    const existing = flow[code]\n\n    if (Array.isArray(existing)) {\n      existing.push(construct)\n    } else {\n      // Never a single object, always an array.\n      flow[code] = [construct]\n    }\n  }\n\n  return {flow}\n}\n\n/**\n * @param {Matter} matter\n * @returns {Construct}\n */\nfunction createConstruct(matter) {\n  const anywhere = matter.anywhere\n  const frontmatterType = /** @type {TokenType} */ (matter.type)\n  const fenceType = /** @type {TokenType} */ (frontmatterType + 'Fence')\n  const sequenceType = /** @type {TokenType} */ (fenceType + 'Sequence')\n  const valueType = /** @type {TokenType} */ (frontmatterType + 'Value')\n  const closingFenceConstruct = {tokenize: tokenizeClosingFence, partial: true}\n\n  /**\n   * Fence to look for.\n   *\n   * @type {string}\n   */\n  let buffer\n  let bufferIndex = 0\n\n  return {tokenize: tokenizeFrontmatter, concrete: true}\n\n  /**\n   * @this {TokenizeContext}\n   * @type {Tokenizer}\n   */\n  function tokenizeFrontmatter(effects, ok, nok) {\n    const self = this\n\n    return start\n\n    /**\n     * Start of frontmatter.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function start(code) {\n      const position = self.now()\n\n      if (\n        // Indent not allowed.\n        position.column === 1 &&\n        // Normally, only allowed in first line.\n        (position.line === 1 || anywhere)\n      ) {\n        buffer = fence(matter, 'open')\n        bufferIndex = 0\n\n        if (code === buffer.charCodeAt(bufferIndex)) {\n          effects.enter(frontmatterType)\n          effects.enter(fenceType)\n          effects.enter(sequenceType)\n          return openSequence(code)\n        }\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *     ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType)\n\n        if (markdownSpace(code)) {\n          effects.enter(types.whitespace)\n          return openSequenceWhitespace(code)\n        }\n\n        return openAfter(code)\n      }\n\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code)\n        return openSequence\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In whitespace after open sequence.\n     *\n     * ```markdown\n     * > | ---␠\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code)\n        return openSequenceWhitespace\n      }\n\n      effects.exit(types.whitespace)\n      return openAfter(code)\n    }\n\n    /**\n     * After open sequence.\n     *\n     * ```markdown\n     * > | ---\n     *        ^\n     *   | title: \"Venus\"\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function openAfter(code) {\n      if (markdownLineEnding(code)) {\n        effects.exit(fenceType)\n        effects.enter(types.lineEnding)\n        effects.consume(code)\n        effects.exit(types.lineEnding)\n        // Get ready for closing fence.\n        buffer = fence(matter, 'close')\n        bufferIndex = 0\n        return effects.attempt(closingFenceConstruct, after, contentStart)\n      }\n\n      // EOF is not okay.\n      return nok(code)\n    }\n\n    /**\n     * Start of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentStart(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        return contentEnd(code)\n      }\n\n      effects.enter(valueType)\n      return contentInside(code)\n    }\n\n    /**\n     * In content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *     ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentInside(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(valueType)\n        return contentEnd(code)\n      }\n\n      effects.consume(code)\n      return contentInside\n    }\n\n    /**\n     * End of content chunk.\n     *\n     * ```markdown\n     *   | ---\n     * > | title: \"Venus\"\n     *                   ^\n     *   | ---\n     * ```\n     *\n     * @type {State}\n     */\n    function contentEnd(code) {\n      // Require a closing fence.\n      if (code === codes.eof) {\n        return nok(code)\n      }\n\n      // Can only be an eol.\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return effects.attempt(closingFenceConstruct, after, contentStart)\n    }\n\n    /**\n     * After frontmatter.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function after(code) {\n      // `code` must be eol/eof.\n      effects.exit(frontmatterType)\n      return ok(code)\n    }\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let bufferIndex = 0\n\n    return closeStart\n\n    /**\n     * Start of close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeStart(code) {\n      if (code === buffer.charCodeAt(bufferIndex)) {\n        effects.enter(fenceType)\n        effects.enter(sequenceType)\n        return closeSequence(code)\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *     ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequence(code) {\n      if (bufferIndex === buffer.length) {\n        effects.exit(sequenceType)\n\n        if (markdownSpace(code)) {\n          effects.enter(types.whitespace)\n          return closeSequenceWhitespace(code)\n        }\n\n        return closeAfter(code)\n      }\n\n      if (code === buffer.charCodeAt(bufferIndex++)) {\n        effects.consume(code)\n        return closeSequence\n      }\n\n      return nok(code)\n    }\n\n    /**\n     * In whitespace after close sequence.\n     *\n     * ```markdown\n     * > | ---\n     *   | title: \"Venus\"\n     *   | ---␠\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeSequenceWhitespace(code) {\n      if (markdownSpace(code)) {\n        effects.consume(code)\n        return closeSequenceWhitespace\n      }\n\n      effects.exit(types.whitespace)\n      return closeAfter(code)\n    }\n\n    /**\n     * After close sequence.\n     *\n     * ```markdown\n     *   | ---\n     *   | title: \"Venus\"\n     * > | ---\n     *        ^\n     * ```\n     *\n     * @type {State}\n     */\n    function closeAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit(fenceType)\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/**\n * @param {Matter} matter\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction fence(matter, prop) {\n  return matter.marker\n    ? pick(matter.marker, prop).repeat(3)\n    : // @ts-expect-error: They’re mutually exclusive.\n      pick(matter.fence, prop)\n}\n\n/**\n * @param {Info | string} schema\n * @param {'open' | 'close'} prop\n * @returns {string}\n */\nfunction pick(schema, prop) {\n  return typeof schema === 'string' ? schema : schema[prop]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}