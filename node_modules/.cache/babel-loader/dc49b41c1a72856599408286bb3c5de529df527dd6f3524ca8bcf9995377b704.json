{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\nimport clsx from 'clsx';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { createOneSideRoundedRectPath } from './create-one-side-rounded-rect-path';\nimport { getKeyValue, matchesX } from './utils';\nimport styles from './styles.css.js';\nexport default function BarSeries(_ref) {\n  let {\n    axis,\n    series,\n    color,\n    xScale,\n    yScale,\n    highlighted,\n    dimmed,\n    highlightedGroupIndex,\n    totalSeriesCount,\n    seriesIndex,\n    plotSize,\n    chartAreaClipPath,\n    stackedBarValues,\n    isRtl\n  } = _ref;\n  const isRefresh = useVisualRefresh();\n  const isStacked = !!stackedBarValues;\n  const isVertical = axis === 'x';\n  const xCoordinates = (() => {\n    var _a;\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n    const yContinuosScale = yScale.d3Scale;\n    const xPoints = series.data.map(_ref2 => {\n      let {\n        x\n      } = _ref2;\n      return xScale.d3Scale(x) || NaN;\n    });\n    const zeroY = (_a = yScale.d3Scale(0)) !== null && _a !== void 0 ? _a : NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n    let barWidth = xScale.d3Scale.bandwidth();\n    const PADDING = 4;\n    const MINWIDTH = 4;\n    if (!isStacked && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n    return xPoints.map((x, i) => {\n      var _a, _b, _c, _d;\n      const d = series.data[i];\n      const key = getKeyValue(d.x);\n      let barX = x;\n      let yValue = d.y;\n      let isRoundedStart = !isStacked;\n      let isRoundedEnd = !isStacked;\n      // Stacked bars\n      if (isStacked) {\n        const allXValues = (_a = stackedBarValues.get(key)) !== null && _a !== void 0 ? _a : new Map();\n        yValue = (_b = allXValues.get(seriesIndex)) !== null && _b !== void 0 ? _b : 0;\n        const allXValuesSorted = Array.from(allXValues.values()).sort((a, b) => a - b);\n        isRoundedStart = yValue === allXValuesSorted[0];\n        isRoundedEnd = yValue === allXValuesSorted[allXValuesSorted.length - 1];\n      }\n      // Regular grouped bars\n      else if (totalSeriesCount > 1) {\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n      return {\n        x: barX,\n        y: (_c = yContinuosScale(yValue)) !== null && _c !== void 0 ? _c : NaN,\n        width: barWidth,\n        height: Math.abs(((_d = yContinuosScale(d.y)) !== null && _d !== void 0 ? _d : NaN) - baseY),\n        isRoundedStart,\n        isRoundedEnd\n      };\n    });\n  })();\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n  return React.createElement(\"g\", {\n    \"aria-label\": series.title,\n    clipPath: `url(#${chartAreaClipPath})`,\n    className: clsx(styles.series, styles['series--bar'], {\n      [styles['series--highlighted']]: highlighted,\n      [styles['series--dimmed']]: dimmed\n    })\n  }, xCoordinates.map((_ref3, i) => {\n    let {\n      x,\n      y,\n      width,\n      height,\n      isRoundedStart,\n      isRoundedEnd\n    } = _ref3;\n    if (!isFinite(x) || !isFinite(height)) {\n      return;\n    }\n    // Create margins between stacked series but only when series data is not too small.\n    const baseHeightOffset = isStacked ? 3 : 0;\n    const isSmallBar = height < 4;\n    const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n    const widthOffset = 2;\n    const rx = isRefresh ? isSmallBar ? 2 : 4 : 0;\n    const placement = isVertical ? {\n      x: x + widthOffset / 2,\n      y: y + heightOffset / 2,\n      width: width - widthOffset,\n      height: height - heightOffset\n    } : {\n      x: y - (!isRtl ? height : 0) + heightOffset / 2,\n      y: x + widthOffset / 2,\n      width: height - heightOffset,\n      height: width - widthOffset\n    };\n    const className = clsx(styles.series__rect, {\n      [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x)\n    });\n    const styleProps = {\n      fill: color,\n      className\n    };\n    let side = 'none';\n    if (isRoundedStart && isRoundedEnd) {\n      side = 'all';\n    } else if (!isRoundedStart && !isRoundedEnd) {\n      side = 'none';\n    } else if (isVertical) {\n      side = isRoundedStart ? 'bottom' : 'top';\n    } else if (!isRtl) {\n      side = isRoundedStart ? 'left' : 'right';\n    } else {\n      side = isRoundedStart ? 'right' : 'left';\n    }\n    if (side === 'all') {\n      return React.createElement(\"rect\", Object.assign({\n        key: i\n      }, placement, styleProps, {\n        rx: rx\n      }));\n    }\n    if (side === 'none') {\n      return React.createElement(\"rect\", Object.assign({\n        key: i\n      }, placement, styleProps, {\n        rx: 0\n      }));\n    }\n    return React.createElement(\"path\", Object.assign({\n      key: i,\n      d: createOneSideRoundedRectPath(placement, rx, side)\n    }, styleProps));\n  }));\n}","map":{"version":3,"names":["React","clsx","useVisualRefresh","createOneSideRoundedRectPath","getKeyValue","matchesX","styles","BarSeries","_ref","axis","series","color","xScale","yScale","highlighted","dimmed","highlightedGroupIndex","totalSeriesCount","seriesIndex","plotSize","chartAreaClipPath","stackedBarValues","isRtl","isRefresh","isStacked","isVertical","xCoordinates","type","isCategorical","yContinuosScale","d3Scale","xPoints","data","map","_ref2","x","NaN","zeroY","_a","baseY","isFinite","Math","min","barWidth","bandwidth","PADDING","MINWIDTH","max","i","d","key","barX","yValue","y","isRoundedStart","isRoundedEnd","allXValues","get","Map","_b","allXValuesSorted","Array","from","values","sort","a","b","length","_c","width","height","abs","_d","highlightedXValue","domain","createElement","title","clipPath","className","_ref3","baseHeightOffset","isSmallBar","heightOffset","widthOffset","rx","placement","series__rect","styleProps","fill","side","Object","assign"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/bar-series.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\nimport clsx from 'clsx';\n\nimport { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport { ScaleContinuousNumeric, ScaleTime } from '../internal/vendor/d3-scale';\nimport { createOneSideRoundedRectPath } from './create-one-side-rounded-rect-path';\nimport { ChartDataTypes, MixedLineBarChartProps } from './interfaces';\nimport { getKeyValue, matchesX, StackedBarValues } from './utils';\n\nimport styles from './styles.css.js';\n\nexport interface BarSeriesProps<T> {\n  axis: 'x' | 'y';\n\n  series: MixedLineBarChartProps.BarDataSeries<T>;\n\n  color: string;\n  totalSeriesCount: number;\n  seriesIndex: number;\n\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n\n  plotSize: number;\n  chartAreaClipPath: string;\n\n  highlighted: boolean;\n  dimmed: boolean;\n  highlightedGroupIndex: number | null;\n\n  // Contains values to be used for stacked bars.\n  stackedBarValues?: StackedBarValues;\n\n  isRtl?: boolean;\n}\n\nexport default function BarSeries<T extends ChartDataTypes>({\n  axis,\n  series,\n  color,\n  xScale,\n  yScale,\n  highlighted,\n  dimmed,\n  highlightedGroupIndex,\n  totalSeriesCount,\n  seriesIndex,\n  plotSize,\n  chartAreaClipPath,\n  stackedBarValues,\n  isRtl,\n}: BarSeriesProps<T>) {\n  const isRefresh = useVisualRefresh();\n  const isStacked = !!stackedBarValues;\n  const isVertical = axis === 'x';\n\n  const xCoordinates = (() => {\n    if (series.type !== 'bar' || !xScale.isCategorical()) {\n      return [];\n    }\n\n    const yContinuosScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number> = yScale.d3Scale;\n    const xPoints = (series.data as ReadonlyArray<MixedLineBarChartProps.Datum<ChartDataTypes>>).map(\n      ({ x }) => xScale.d3Scale(x) || NaN\n    );\n\n    const zeroY = yScale.d3Scale(0) ?? NaN;\n    const baseY = isFinite(zeroY) ? Math.min(plotSize, zeroY) : plotSize;\n\n    let barWidth = xScale.d3Scale.bandwidth();\n\n    const PADDING = 4;\n    const MINWIDTH = 4;\n\n    if (!isStacked && totalSeriesCount > 1) {\n      // Regular grouped bars\n      barWidth = (barWidth - (totalSeriesCount - 1) * PADDING) / totalSeriesCount;\n      barWidth = Math.max(barWidth, MINWIDTH);\n    }\n\n    return xPoints.map((x, i) => {\n      const d = series.data[i];\n      const key = getKeyValue(d.x);\n      let barX = x;\n      let yValue = d.y;\n      let isRoundedStart = !isStacked;\n      let isRoundedEnd = !isStacked;\n\n      // Stacked bars\n      if (isStacked) {\n        const allXValues = stackedBarValues.get(key) ?? new Map();\n        yValue = allXValues.get(seriesIndex) ?? 0;\n        const allXValuesSorted = Array.from(allXValues.values()).sort((a, b) => a - b);\n        isRoundedStart = yValue === allXValuesSorted[0];\n        isRoundedEnd = yValue === allXValuesSorted[allXValuesSorted.length - 1];\n      }\n      // Regular grouped bars\n      else if (totalSeriesCount > 1) {\n        barX += seriesIndex * (barWidth + PADDING);\n      }\n\n      // Account for negative values growing \"down\" instead of \"up\"\n      yValue = yValue < 0 ? yValue - d.y : yValue;\n\n      return {\n        x: barX,\n        y: yContinuosScale(yValue) ?? NaN,\n        width: barWidth,\n        height: Math.abs((yContinuosScale(d.y) ?? NaN) - baseY),\n        isRoundedStart,\n        isRoundedEnd,\n      };\n    });\n  })();\n\n  const highlightedXValue = highlightedGroupIndex !== null ? xScale.domain[highlightedGroupIndex] : null;\n\n  return (\n    <g\n      aria-label={series.title}\n      clipPath={`url(#${chartAreaClipPath})`}\n      className={clsx(styles.series, styles['series--bar'], {\n        [styles['series--highlighted']]: highlighted,\n        [styles['series--dimmed']]: dimmed,\n      })}\n    >\n      {xCoordinates.map(({ x, y, width, height, isRoundedStart, isRoundedEnd }, i) => {\n        if (!isFinite(x) || !isFinite(height)) {\n          return;\n        }\n\n        // Create margins between stacked series but only when series data is not too small.\n        const baseHeightOffset = isStacked ? 3 : 0;\n        const isSmallBar = height < 4;\n        const heightOffset = isSmallBar ? 0 : baseHeightOffset;\n        const widthOffset = 2;\n\n        const rx = isRefresh ? (isSmallBar ? 2 : 4) : 0;\n        const placement = isVertical\n          ? {\n              x: x + widthOffset / 2,\n              y: y + heightOffset / 2,\n              width: width - widthOffset,\n              height: height - heightOffset,\n            }\n          : {\n              x: y - (!isRtl ? height : 0) + heightOffset / 2,\n              y: x + widthOffset / 2,\n              width: height - heightOffset,\n              height: width - widthOffset,\n            };\n\n        const className = clsx(styles.series__rect, {\n          [styles['series--dimmed']]: highlightedXValue !== null && !matchesX(highlightedXValue, series.data[i].x),\n        });\n        const styleProps = { fill: color, className };\n\n        let side: 'left' | 'right' | 'top' | 'bottom' | 'all' | 'none' = 'none';\n        if (isRoundedStart && isRoundedEnd) {\n          side = 'all';\n        } else if (!isRoundedStart && !isRoundedEnd) {\n          side = 'none';\n        } else if (isVertical) {\n          side = isRoundedStart ? 'bottom' : 'top';\n        } else if (!isRtl) {\n          side = isRoundedStart ? 'left' : 'right';\n        } else {\n          side = isRoundedStart ? 'right' : 'left';\n        }\n\n        if (side === 'all') {\n          return <rect key={i} {...placement} {...styleProps} rx={rx} />;\n        }\n        if (side === 'none') {\n          return <rect key={i} {...placement} {...styleProps} rx={0} />;\n        }\n        return <path key={i} d={createOneSideRoundedRectPath(placement, rx, side)} {...styleProps} />;\n      })}\n    </g>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}