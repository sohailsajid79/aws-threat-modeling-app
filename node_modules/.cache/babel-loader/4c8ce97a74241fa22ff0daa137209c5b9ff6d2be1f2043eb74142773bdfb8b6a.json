{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, useContext, useEffect, useRef, useState } from 'react';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { setElementWidths } from './column-widths-utils';\nexport const DEFAULT_COLUMN_WIDTH = 120;\nfunction readWidths(getCell, visibleColumns) {\n  const result = new Map();\n  for (let index = 0; index < visibleColumns.length; index++) {\n    const column = visibleColumns[index];\n    let width = column.width || 0;\n    const minWidth = column.minWidth || width || DEFAULT_COLUMN_WIDTH;\n    if (!width &&\n    // read width from the DOM if it is missing in the config\n    index !== visibleColumns.length - 1 // skip reading for the last column, because it expands to fully fit the container\n    ) {\n      const colEl = getCell(column.id);\n      width = colEl ? getLogicalBoundingClientRect(colEl).inlineSize : DEFAULT_COLUMN_WIDTH;\n    }\n    result.set(column.id, Math.max(width, minWidth));\n  }\n  return result;\n}\nfunction updateWidths(visibleColumns, oldWidths, newWidth, columnId) {\n  const column = visibleColumns.find(column => column.id === columnId);\n  const minWidth = typeof (column === null || column === void 0 ? void 0 : column.minWidth) === 'number' ? column.minWidth : DEFAULT_COLUMN_WIDTH;\n  newWidth = Math.max(newWidth, minWidth);\n  if (oldWidths.get(columnId) === newWidth) {\n    return oldWidths;\n  }\n  const newWidths = new Map(oldWidths);\n  newWidths.set(columnId, newWidth);\n  return newWidths;\n}\nconst WidthsContext = createContext({\n  getColumnStyles: () => ({}),\n  columnWidths: new Map(),\n  updateColumn: () => {},\n  setCell: () => {}\n});\nexport function ColumnWidthsProvider({\n  visibleColumns,\n  resizableColumns,\n  containerRef,\n  children\n}) {\n  const visibleColumnsRef = useRef(null);\n  const containerWidthRef = useRef(0);\n  const [columnWidths, setColumnWidths] = useState(null);\n  const cellsRef = useRef(new Map());\n  const stickyCellsRef = useRef(new Map());\n  const getCell = columnId => {\n    var _a;\n    return (_a = cellsRef.current.get(columnId)) !== null && _a !== void 0 ? _a : null;\n  };\n  const setCell = (sticky, columnId, node) => {\n    const ref = sticky ? stickyCellsRef : cellsRef;\n    if (node) {\n      ref.current.set(columnId, node);\n    } else {\n      ref.current.delete(columnId);\n    }\n  };\n  const getColumnStyles = (sticky, columnId) => {\n    var _a, _b, _c;\n    const column = visibleColumns.find(column => column.id === columnId);\n    if (!column) {\n      return {};\n    }\n    if (sticky) {\n      return {\n        width: ((_a = cellsRef.current.get(column.id)) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().width) || ((_b = columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) !== null && _b !== void 0 ? _b : column.width)\n      };\n    }\n    if (resizableColumns && columnWidths) {\n      const isLastColumn = column.id === ((_c = visibleColumns[visibleColumns.length - 1]) === null || _c === void 0 ? void 0 : _c.id);\n      const totalWidth = visibleColumns.reduce((sum, {\n        id\n      }) => sum + (columnWidths.get(id) || DEFAULT_COLUMN_WIDTH), 0);\n      if (isLastColumn && containerWidthRef.current > totalWidth) {\n        return {\n          width: 'auto',\n          minWidth: column === null || column === void 0 ? void 0 : column.minWidth\n        };\n      } else {\n        return {\n          width: columnWidths.get(column.id),\n          minWidth: column === null || column === void 0 ? void 0 : column.minWidth\n        };\n      }\n    }\n    return {\n      width: column.width,\n      minWidth: column.minWidth,\n      maxWidth: !resizableColumns ? column.maxWidth : undefined\n    };\n  };\n  // Imperatively sets width style for a cell avoiding React state.\n  // This allows setting the style as soon container's size change is observed.\n  const updateColumnWidths = useStableCallback(() => {\n    for (const {\n      id\n    } of visibleColumns) {\n      const element = cellsRef.current.get(id);\n      if (element) {\n        setElementWidths(element, getColumnStyles(false, id));\n      }\n    }\n    // Sticky column widths must be synchronized once all real column widths are assigned.\n    for (const {\n      id\n    } of visibleColumns) {\n      const element = stickyCellsRef.current.get(id);\n      if (element) {\n        setElementWidths(element, getColumnStyles(true, id));\n      }\n    }\n  });\n  // Observes container size and requests an update to the last cell width as it depends on the container's width.\n  useResizeObserver(containerRef, ({\n    contentBoxWidth: containerWidth\n  }) => {\n    containerWidthRef.current = containerWidth;\n    requestAnimationFrame(() => updateColumnWidths());\n  });\n  // The widths of the dynamically added columns (after the first render) if not set explicitly\n  // will default to the DEFAULT_COLUMN_WIDTH.\n  useEffect(() => {\n    updateColumnWidths();\n    if (!resizableColumns) {\n      return;\n    }\n    let updated = false;\n    const newColumnWidths = new Map(columnWidths);\n    const lastVisible = visibleColumnsRef.current;\n    if (lastVisible) {\n      for (let index = 0; index < visibleColumns.length; index++) {\n        const column = visibleColumns[index];\n        if (!(columnWidths === null || columnWidths === void 0 ? void 0 : columnWidths.get(column.id)) && lastVisible.indexOf(column.id) === -1) {\n          updated = true;\n          newColumnWidths.set(column.id, column.width || DEFAULT_COLUMN_WIDTH);\n        }\n      }\n      if (updated) {\n        setColumnWidths(newColumnWidths);\n      }\n    }\n    visibleColumnsRef.current = visibleColumns.map(column => column.id);\n  }, [columnWidths, resizableColumns, visibleColumns, updateColumnWidths]);\n  // Read the actual column widths after the first render to employ the browser defaults for\n  // those columns without explicit width.\n  useEffect(() => {\n    if (!resizableColumns) {\n      return;\n    }\n    setColumnWidths(() => readWidths(getCell, visibleColumns));\n    // This code is intended to run only at the first render and should not re-run when table props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  function updateColumn(columnId, newWidth) {\n    setColumnWidths(columnWidths => updateWidths(visibleColumns, columnWidths !== null && columnWidths !== void 0 ? columnWidths : new Map(), newWidth, columnId));\n  }\n  return React.createElement(WidthsContext.Provider, {\n    value: {\n      getColumnStyles,\n      columnWidths: columnWidths !== null && columnWidths !== void 0 ? columnWidths : new Map(),\n      updateColumn,\n      setCell\n    }\n  }, children);\n}\nexport function useColumnWidths() {\n  return useContext(WidthsContext);\n}","map":{"version":3,"names":["React","createContext","useContext","useEffect","useRef","useState","useResizeObserver","useStableCallback","getLogicalBoundingClientRect","setElementWidths","DEFAULT_COLUMN_WIDTH","readWidths","getCell","visibleColumns","result","Map","index","length","column","width","minWidth","colEl","id","inlineSize","set","Math","max","updateWidths","oldWidths","newWidth","columnId","find","get","newWidths","WidthsContext","getColumnStyles","columnWidths","updateColumn","setCell","ColumnWidthsProvider","resizableColumns","containerRef","children","visibleColumnsRef","containerWidthRef","setColumnWidths","cellsRef","stickyCellsRef","_a","current","sticky","node","ref","delete","getBoundingClientRect","_b","isLastColumn","_c","totalWidth","reduce","sum","maxWidth","undefined","updateColumnWidths","element","contentBoxWidth","containerWidth","requestAnimationFrame","updated","newColumnWidths","lastVisible","indexOf","map","createElement","Provider","value","useColumnWidths"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/table/use-column-widths.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, useContext, useEffect, useRef, useState } from 'react';\n\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { setElementWidths } from './column-widths-utils';\n\nexport const DEFAULT_COLUMN_WIDTH = 120;\n\nexport interface ColumnWidthDefinition {\n  id: PropertyKey;\n  minWidth?: string | number;\n  maxWidth?: string | number;\n  width?: string | number;\n}\n\nfunction readWidths(\n  getCell: (columnId: PropertyKey) => null | HTMLElement,\n  visibleColumns: readonly ColumnWidthDefinition[]\n) {\n  const result = new Map<PropertyKey, number>();\n  for (let index = 0; index < visibleColumns.length; index++) {\n    const column = visibleColumns[index];\n    let width = (column.width as number) || 0;\n    const minWidth = (column.minWidth as number) || width || DEFAULT_COLUMN_WIDTH;\n    if (\n      !width && // read width from the DOM if it is missing in the config\n      index !== visibleColumns.length - 1 // skip reading for the last column, because it expands to fully fit the container\n    ) {\n      const colEl = getCell(column.id);\n      width = colEl ? getLogicalBoundingClientRect(colEl).inlineSize : DEFAULT_COLUMN_WIDTH;\n    }\n    result.set(column.id, Math.max(width, minWidth));\n  }\n  return result;\n}\n\nfunction updateWidths(\n  visibleColumns: readonly ColumnWidthDefinition[],\n  oldWidths: Map<PropertyKey, number>,\n  newWidth: number,\n  columnId: PropertyKey\n) {\n  const column = visibleColumns.find(column => column.id === columnId);\n  const minWidth = typeof column?.minWidth === 'number' ? column.minWidth : DEFAULT_COLUMN_WIDTH;\n  newWidth = Math.max(newWidth, minWidth);\n  if (oldWidths.get(columnId) === newWidth) {\n    return oldWidths;\n  }\n  const newWidths = new Map(oldWidths);\n  newWidths.set(columnId, newWidth);\n  return newWidths;\n}\n\ninterface WidthsContext {\n  getColumnStyles(sticky: boolean, columnId: PropertyKey): React.CSSProperties;\n  columnWidths: Map<PropertyKey, number>;\n  updateColumn: (columnId: PropertyKey, newWidth: number) => void;\n  setCell: (sticky: boolean, columnId: PropertyKey, node: null | HTMLElement) => void;\n}\n\nconst WidthsContext = createContext<WidthsContext>({\n  getColumnStyles: () => ({}),\n  columnWidths: new Map(),\n  updateColumn: () => {},\n  setCell: () => {},\n});\n\ninterface WidthProviderProps {\n  visibleColumns: readonly ColumnWidthDefinition[];\n  resizableColumns: boolean | undefined;\n  containerRef: React.RefObject<HTMLElement>;\n  children: React.ReactNode;\n}\n\nexport function ColumnWidthsProvider({ visibleColumns, resizableColumns, containerRef, children }: WidthProviderProps) {\n  const visibleColumnsRef = useRef<PropertyKey[] | null>(null);\n  const containerWidthRef = useRef(0);\n  const [columnWidths, setColumnWidths] = useState<null | Map<PropertyKey, number>>(null);\n\n  const cellsRef = useRef(new Map<PropertyKey, HTMLElement>());\n  const stickyCellsRef = useRef(new Map<PropertyKey, HTMLElement>());\n  const getCell = (columnId: PropertyKey): null | HTMLElement => cellsRef.current.get(columnId) ?? null;\n  const setCell = (sticky: boolean, columnId: PropertyKey, node: null | HTMLElement) => {\n    const ref = sticky ? stickyCellsRef : cellsRef;\n    if (node) {\n      ref.current.set(columnId, node);\n    } else {\n      ref.current.delete(columnId);\n    }\n  };\n\n  const getColumnStyles = (sticky: boolean, columnId: PropertyKey): React.CSSProperties => {\n    const column = visibleColumns.find(column => column.id === columnId);\n    if (!column) {\n      return {};\n    }\n\n    if (sticky) {\n      return {\n        width:\n          cellsRef.current.get(column.id)?.getBoundingClientRect().width ||\n          (columnWidths?.get(column.id) ?? column.width),\n      };\n    }\n\n    if (resizableColumns && columnWidths) {\n      const isLastColumn = column.id === visibleColumns[visibleColumns.length - 1]?.id;\n      const totalWidth = visibleColumns.reduce(\n        (sum, { id }) => sum + (columnWidths.get(id) || DEFAULT_COLUMN_WIDTH),\n        0\n      );\n      if (isLastColumn && containerWidthRef.current > totalWidth) {\n        return { width: 'auto', minWidth: column?.minWidth };\n      } else {\n        return { width: columnWidths.get(column.id), minWidth: column?.minWidth };\n      }\n    }\n    return {\n      width: column.width,\n      minWidth: column.minWidth,\n      maxWidth: !resizableColumns ? column.maxWidth : undefined,\n    };\n  };\n\n  // Imperatively sets width style for a cell avoiding React state.\n  // This allows setting the style as soon container's size change is observed.\n  const updateColumnWidths = useStableCallback(() => {\n    for (const { id } of visibleColumns) {\n      const element = cellsRef.current.get(id);\n      if (element) {\n        setElementWidths(element, getColumnStyles(false, id));\n      }\n    }\n    // Sticky column widths must be synchronized once all real column widths are assigned.\n    for (const { id } of visibleColumns) {\n      const element = stickyCellsRef.current.get(id);\n      if (element) {\n        setElementWidths(element, getColumnStyles(true, id));\n      }\n    }\n  });\n\n  // Observes container size and requests an update to the last cell width as it depends on the container's width.\n  useResizeObserver(containerRef, ({ contentBoxWidth: containerWidth }) => {\n    containerWidthRef.current = containerWidth;\n    requestAnimationFrame(() => updateColumnWidths());\n  });\n\n  // The widths of the dynamically added columns (after the first render) if not set explicitly\n  // will default to the DEFAULT_COLUMN_WIDTH.\n  useEffect(() => {\n    updateColumnWidths();\n\n    if (!resizableColumns) {\n      return;\n    }\n    let updated = false;\n    const newColumnWidths = new Map(columnWidths);\n    const lastVisible = visibleColumnsRef.current;\n    if (lastVisible) {\n      for (let index = 0; index < visibleColumns.length; index++) {\n        const column = visibleColumns[index];\n        if (!columnWidths?.get(column.id) && lastVisible.indexOf(column.id) === -1) {\n          updated = true;\n          newColumnWidths.set(column.id, (column.width as number) || DEFAULT_COLUMN_WIDTH);\n        }\n      }\n      if (updated) {\n        setColumnWidths(newColumnWidths);\n      }\n    }\n    visibleColumnsRef.current = visibleColumns.map(column => column.id);\n  }, [columnWidths, resizableColumns, visibleColumns, updateColumnWidths]);\n\n  // Read the actual column widths after the first render to employ the browser defaults for\n  // those columns without explicit width.\n  useEffect(() => {\n    if (!resizableColumns) {\n      return;\n    }\n    setColumnWidths(() => readWidths(getCell, visibleColumns));\n    // This code is intended to run only at the first render and should not re-run when table props change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  function updateColumn(columnId: PropertyKey, newWidth: number) {\n    setColumnWidths(columnWidths => updateWidths(visibleColumns, columnWidths ?? new Map(), newWidth, columnId));\n  }\n\n  return (\n    <WidthsContext.Provider value={{ getColumnStyles, columnWidths: columnWidths ?? new Map(), updateColumn, setCell }}>\n      {children}\n    </WidthsContext.Provider>\n  );\n}\n\nexport function useColumnWidths() {\n  return useContext(WidthsContext);\n}\n"],"mappings":"AAAA;AACA;AACA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,UAAU,EAAEC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAErF,SAASC,iBAAiB,EAAEC,iBAAiB,QAAQ,+CAA+C;AACpG,SAASC,4BAA4B,QAAQ,+CAA+C;AAE5F,SAASC,gBAAgB,QAAQ,uBAAuB;AAExD,OAAO,MAAMC,oBAAoB,GAAG,GAAG;AASvC,SAASC,UAAUA,CACjBC,OAAsD,EACtDC,cAAgD;EAEhD,MAAMC,MAAM,GAAG,IAAIC,GAAG,EAAuB;EAC7C,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,cAAc,CAACI,MAAM,EAAED,KAAK,EAAE,EAAE;IAC1D,MAAME,MAAM,GAAGL,cAAc,CAACG,KAAK,CAAC;IACpC,IAAIG,KAAK,GAAID,MAAM,CAACC,KAAgB,IAAI,CAAC;IACzC,MAAMC,QAAQ,GAAIF,MAAM,CAACE,QAAmB,IAAID,KAAK,IAAIT,oBAAoB;IAC7E,IACE,CAACS,KAAK;IAAI;IACVH,KAAK,KAAKH,cAAc,CAACI,MAAM,GAAG,CAAC,CAAC;IAAA,EACpC;MACA,MAAMI,KAAK,GAAGT,OAAO,CAACM,MAAM,CAACI,EAAE,CAAC;MAChCH,KAAK,GAAGE,KAAK,GAAGb,4BAA4B,CAACa,KAAK,CAAC,CAACE,UAAU,GAAGb,oBAAoB;;IAEvFI,MAAM,CAACU,GAAG,CAACN,MAAM,CAACI,EAAE,EAAEG,IAAI,CAACC,GAAG,CAACP,KAAK,EAAEC,QAAQ,CAAC,CAAC;;EAElD,OAAON,MAAM;AACf;AAEA,SAASa,YAAYA,CACnBd,cAAgD,EAChDe,SAAmC,EACnCC,QAAgB,EAChBC,QAAqB;EAErB,MAAMZ,MAAM,GAAGL,cAAc,CAACkB,IAAI,CAACb,MAAM,IAAIA,MAAM,CAACI,EAAE,KAAKQ,QAAQ,CAAC;EACpE,MAAMV,QAAQ,GAAG,QAAOF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE,QAAQ,MAAK,QAAQ,GAAGF,MAAM,CAACE,QAAQ,GAAGV,oBAAoB;EAC9FmB,QAAQ,GAAGJ,IAAI,CAACC,GAAG,CAACG,QAAQ,EAAET,QAAQ,CAAC;EACvC,IAAIQ,SAAS,CAACI,GAAG,CAACF,QAAQ,CAAC,KAAKD,QAAQ,EAAE;IACxC,OAAOD,SAAS;;EAElB,MAAMK,SAAS,GAAG,IAAIlB,GAAG,CAACa,SAAS,CAAC;EACpCK,SAAS,CAACT,GAAG,CAACM,QAAQ,EAAED,QAAQ,CAAC;EACjC,OAAOI,SAAS;AAClB;AASA,MAAMC,aAAa,GAAGjC,aAAa,CAAgB;EACjDkC,eAAe,EAAEA,CAAA,MAAO,EAAE,CAAC;EAC3BC,YAAY,EAAE,IAAIrB,GAAG,EAAE;EACvBsB,YAAY,EAAEA,CAAA,KAAK,CAAE,CAAC;EACtBC,OAAO,EAAEA,CAAA,KAAK,CAAE;CACjB,CAAC;AASF,OAAM,SAAUC,oBAAoBA,CAAC;EAAE1B,cAAc;EAAE2B,gBAAgB;EAAEC,YAAY;EAAEC;AAAQ,CAAsB;EACnH,MAAMC,iBAAiB,GAAGvC,MAAM,CAAuB,IAAI,CAAC;EAC5D,MAAMwC,iBAAiB,GAAGxC,MAAM,CAAC,CAAC,CAAC;EACnC,MAAM,CAACgC,YAAY,EAAES,eAAe,CAAC,GAAGxC,QAAQ,CAAkC,IAAI,CAAC;EAEvF,MAAMyC,QAAQ,GAAG1C,MAAM,CAAC,IAAIW,GAAG,EAA4B,CAAC;EAC5D,MAAMgC,cAAc,GAAG3C,MAAM,CAAC,IAAIW,GAAG,EAA4B,CAAC;EAClE,MAAMH,OAAO,GAAIkB,QAAqB,IAAwB;IAAA,IAAAkB,EAAA;IAAC,QAAAA,EAAA,GAAAF,QAAQ,CAACG,OAAO,CAACjB,GAAG,CAACF,QAAQ,CAAC,cAAAkB,EAAA,cAAAA,EAAA,GAAI,IAAI;EAAA;EACrG,MAAMV,OAAO,GAAGA,CAACY,MAAe,EAAEpB,QAAqB,EAAEqB,IAAwB,KAAI;IACnF,MAAMC,GAAG,GAAGF,MAAM,GAAGH,cAAc,GAAGD,QAAQ;IAC9C,IAAIK,IAAI,EAAE;MACRC,GAAG,CAACH,OAAO,CAACzB,GAAG,CAACM,QAAQ,EAAEqB,IAAI,CAAC;KAChC,MAAM;MACLC,GAAG,CAACH,OAAO,CAACI,MAAM,CAACvB,QAAQ,CAAC;;EAEhC,CAAC;EAED,MAAMK,eAAe,GAAGA,CAACe,MAAe,EAAEpB,QAAqB,KAAyB;;IACtF,MAAMZ,MAAM,GAAGL,cAAc,CAACkB,IAAI,CAACb,MAAM,IAAIA,MAAM,CAACI,EAAE,KAAKQ,QAAQ,CAAC;IACpE,IAAI,CAACZ,MAAM,EAAE;MACX,OAAO,EAAE;;IAGX,IAAIgC,MAAM,EAAE;MACV,OAAO;QACL/B,KAAK,EACH,EAAA6B,EAAA,GAAAF,QAAQ,CAACG,OAAO,CAACjB,GAAG,CAACd,MAAM,CAACI,EAAE,CAAC,cAAA0B,EAAA,uBAAAA,EAAA,CAAEM,qBAAqB,GAAGnC,KAAK,MAC7D,CAAAoC,EAAA,GAAAnB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEJ,GAAG,CAACd,MAAM,CAACI,EAAE,CAAC,cAAAiC,EAAA,cAAAA,EAAA,GAAIrC,MAAM,CAACC,KAAK;OAChD;;IAGH,IAAIqB,gBAAgB,IAAIJ,YAAY,EAAE;MACpC,MAAMoB,YAAY,GAAGtC,MAAM,CAACI,EAAE,MAAK,CAAAmC,EAAA,GAAA5C,cAAc,CAACA,cAAc,CAACI,MAAM,GAAG,CAAC,CAAC,cAAAwC,EAAA,uBAAAA,EAAA,CAAEnC,EAAE;MAChF,MAAMoC,UAAU,GAAG7C,cAAc,CAAC8C,MAAM,CACtC,CAACC,GAAG,EAAE;QAAEtC;MAAE,CAAE,KAAKsC,GAAG,IAAIxB,YAAY,CAACJ,GAAG,CAACV,EAAE,CAAC,IAAIZ,oBAAoB,CAAC,EACrE,CAAC,CACF;MACD,IAAI8C,YAAY,IAAIZ,iBAAiB,CAACK,OAAO,GAAGS,UAAU,EAAE;QAC1D,OAAO;UAAEvC,KAAK,EAAE,MAAM;UAAEC,QAAQ,EAAEF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE;QAAQ,CAAE;OACrD,MAAM;QACL,OAAO;UAAED,KAAK,EAAEiB,YAAY,CAACJ,GAAG,CAACd,MAAM,CAACI,EAAE,CAAC;UAAEF,QAAQ,EAAEF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEE;QAAQ,CAAE;;;IAG7E,OAAO;MACLD,KAAK,EAAED,MAAM,CAACC,KAAK;MACnBC,QAAQ,EAAEF,MAAM,CAACE,QAAQ;MACzByC,QAAQ,EAAE,CAACrB,gBAAgB,GAAGtB,MAAM,CAAC2C,QAAQ,GAAGC;KACjD;EACH,CAAC;EAED;EACA;EACA,MAAMC,kBAAkB,GAAGxD,iBAAiB,CAAC,MAAK;IAChD,KAAK,MAAM;MAAEe;IAAE,CAAE,IAAIT,cAAc,EAAE;MACnC,MAAMmD,OAAO,GAAGlB,QAAQ,CAACG,OAAO,CAACjB,GAAG,CAACV,EAAE,CAAC;MACxC,IAAI0C,OAAO,EAAE;QACXvD,gBAAgB,CAACuD,OAAO,EAAE7B,eAAe,CAAC,KAAK,EAAEb,EAAE,CAAC,CAAC;;;IAGzD;IACA,KAAK,MAAM;MAAEA;IAAE,CAAE,IAAIT,cAAc,EAAE;MACnC,MAAMmD,OAAO,GAAGjB,cAAc,CAACE,OAAO,CAACjB,GAAG,CAACV,EAAE,CAAC;MAC9C,IAAI0C,OAAO,EAAE;QACXvD,gBAAgB,CAACuD,OAAO,EAAE7B,eAAe,CAAC,IAAI,EAAEb,EAAE,CAAC,CAAC;;;EAG1D,CAAC,CAAC;EAEF;EACAhB,iBAAiB,CAACmC,YAAY,EAAE,CAAC;IAAEwB,eAAe,EAAEC;EAAc,CAAE,KAAI;IACtEtB,iBAAiB,CAACK,OAAO,GAAGiB,cAAc;IAC1CC,qBAAqB,CAAC,MAAMJ,kBAAkB,EAAE,CAAC;EACnD,CAAC,CAAC;EAEF;EACA;EACA5D,SAAS,CAAC,MAAK;IACb4D,kBAAkB,EAAE;IAEpB,IAAI,CAACvB,gBAAgB,EAAE;MACrB;;IAEF,IAAI4B,OAAO,GAAG,KAAK;IACnB,MAAMC,eAAe,GAAG,IAAItD,GAAG,CAACqB,YAAY,CAAC;IAC7C,MAAMkC,WAAW,GAAG3B,iBAAiB,CAACM,OAAO;IAC7C,IAAIqB,WAAW,EAAE;MACf,KAAK,IAAItD,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,cAAc,CAACI,MAAM,EAAED,KAAK,EAAE,EAAE;QAC1D,MAAME,MAAM,GAAGL,cAAc,CAACG,KAAK,CAAC;QACpC,IAAI,EAACoB,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEJ,GAAG,CAACd,MAAM,CAACI,EAAE,CAAC,KAAIgD,WAAW,CAACC,OAAO,CAACrD,MAAM,CAACI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE;UAC1E8C,OAAO,GAAG,IAAI;UACdC,eAAe,CAAC7C,GAAG,CAACN,MAAM,CAACI,EAAE,EAAGJ,MAAM,CAACC,KAAgB,IAAIT,oBAAoB,CAAC;;;MAGpF,IAAI0D,OAAO,EAAE;QACXvB,eAAe,CAACwB,eAAe,CAAC;;;IAGpC1B,iBAAiB,CAACM,OAAO,GAAGpC,cAAc,CAAC2D,GAAG,CAACtD,MAAM,IAAIA,MAAM,CAACI,EAAE,CAAC;EACrE,CAAC,EAAE,CAACc,YAAY,EAAEI,gBAAgB,EAAE3B,cAAc,EAAEkD,kBAAkB,CAAC,CAAC;EAExE;EACA;EACA5D,SAAS,CAAC,MAAK;IACb,IAAI,CAACqC,gBAAgB,EAAE;MACrB;;IAEFK,eAAe,CAAC,MAAMlC,UAAU,CAACC,OAAO,EAAEC,cAAc,CAAC,CAAC;IAC1D;IACA;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,SAASwB,YAAYA,CAACP,QAAqB,EAAED,QAAgB;IAC3DgB,eAAe,CAACT,YAAY,IAAIT,YAAY,CAACd,cAAc,EAAEuB,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAI,IAAIrB,GAAG,EAAE,EAAEc,QAAQ,EAAEC,QAAQ,CAAC,CAAC;EAC9G;EAEA,OACE9B,KAAA,CAAAyE,aAAA,CAACvC,aAAa,CAACwC,QAAQ;IAACC,KAAK,EAAE;MAAExC,eAAe;MAAEC,YAAY,EAAEA,YAAY,aAAZA,YAAY,cAAZA,YAAY,GAAI,IAAIrB,GAAG,EAAE;MAAEsB,YAAY;MAAEC;IAAO;EAAE,GAC/GI,QAAQ,CACc;AAE7B;AAEA,OAAM,SAAUkC,eAAeA,CAAA;EAC7B,OAAO1E,UAAU,CAACgC,aAAa,CAAC;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}