{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { isYThreshold } from '../utils';\nimport styles from '../styles.css.js';\nconst MAX_HOVER_MARGIN = 6;\nconst POPOVER_DEADZONE = 12;\nexport function useMouseHover({\n  plotRef,\n  popoverRef,\n  scaledSeries,\n  barGroups,\n  highlightPoint,\n  highlightGroup,\n  clearHighlightedSeries,\n  isGroupNavigation,\n  isHandlersDisabled,\n  highlightX\n}) {\n  const isMouseOverPopover = event => {\n    var _a;\n    if ((_a = popoverRef.current) === null || _a === void 0 ? void 0 : _a.firstChild) {\n      const popoverPosition = popoverRef.current.firstChild.getBoundingClientRect();\n      if (event.clientX > popoverPosition.x - POPOVER_DEADZONE && event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE && event.clientY > popoverPosition.y - POPOVER_DEADZONE && event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE) {\n        return true;\n      }\n    }\n    return false;\n  };\n  const onSeriesMouseMove = event => {\n    var _a, _b;\n    const svgRect = event.target.getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const closestX = scaledSeries.map(v => v.x).reduce((prev, curr) => Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev, -Infinity);\n    if (isFinite(closestX)) {\n      const offsetY = event.clientY - svgRect.top;\n      const closestY = scaledSeries.filter(v => v.x === closestX || isYThreshold(v.series)).map(v => v.y).reduce((prev, curr) => Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev, -Infinity);\n      if (isFinite(closestY) && Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN && Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN) {\n        const [{\n          color,\n          datum,\n          series\n        }] = scaledSeries.filter(s => (s.x === closestX || isYThreshold(s.series)) && s.y === closestY);\n        highlightPoint({\n          x: closestX,\n          y: closestY,\n          color,\n          datum,\n          series\n        });\n      } else {\n        let datumX = null;\n        for (const point of scaledSeries) {\n          if (point.x === closestX) {\n            datumX = (_b = (_a = point.datum) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : null;\n            break;\n          }\n        }\n        highlightX({\n          scaledX: closestX,\n          label: datumX\n        });\n      }\n    }\n  };\n  const onGroupMouseMove = event => {\n    const svgRect = event.target.getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const offsetY = event.clientY - svgRect.top;\n    // If hovering over some group - highlight it.\n    for (let groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      const {\n        position: {\n          x,\n          y,\n          width,\n          height\n        }\n      } = barGroups[groupIndex];\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n  const onSVGMouseMove = event => {\n    if (event.target === plotRef.current.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n  const onSVGMouseOut = event => {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (!nodeContains(plotRef.current.svg, event.relatedTarget) || event.relatedTarget && event.relatedTarget.classList.contains(styles.series)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  const onPopoverLeave = event => {\n    if (!isHandlersDisabled && nodeContains(plotRef.current.svg, event.relatedTarget)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n  return {\n    onSVGMouseMove,\n    onSVGMouseOut,\n    onPopoverLeave\n  };\n}","map":{"version":3,"names":["nodeContains","isYThreshold","styles","MAX_HOVER_MARGIN","POPOVER_DEADZONE","useMouseHover","plotRef","popoverRef","scaledSeries","barGroups","highlightPoint","highlightGroup","clearHighlightedSeries","isGroupNavigation","isHandlersDisabled","highlightX","isMouseOverPopover","event","_a","current","firstChild","popoverPosition","getBoundingClientRect","clientX","x","width","clientY","y","height","onSeriesMouseMove","svgRect","target","offsetX","left","closestX","map","v","reduce","prev","curr","Math","abs","Infinity","isFinite","offsetY","top","closestY","filter","series","color","datum","s","datumX","point","_b","scaledX","label","onGroupMouseMove","groupIndex","length","position","onSVGMouseMove","svg","onSVGMouseOut","relatedTarget","classList","contains","onPopoverLeave"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/mixed-line-bar-chart/hooks/use-mouse-hover.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\n\nimport { ChartPlotRef } from '../../internal/components/chart-plot';\nimport { VerticalMarkerX } from '../interfaces';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { isYThreshold } from '../utils';\n\nimport styles from '../styles.css.js';\n\nconst MAX_HOVER_MARGIN = 6;\nconst POPOVER_DEADZONE = 12;\n\nexport interface UseMouseHoverProps<T> {\n  plotRef: React.RefObject<ChartPlotRef>;\n  popoverRef: React.RefObject<HTMLElement>;\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n  barGroups: ScaledBarGroup<T>[];\n  highlightPoint: (point: ScaledPoint<T> | null) => void;\n  highlightGroup: (groupIndex: number) => void;\n  clearHighlightedSeries: () => void;\n  isGroupNavigation: boolean;\n  isHandlersDisabled: boolean;\n  highlightX: (verticalMarker: VerticalMarkerX<T> | null) => void;\n}\n\nexport function useMouseHover<T>({\n  plotRef,\n  popoverRef,\n  scaledSeries,\n  barGroups,\n  highlightPoint,\n  highlightGroup,\n  clearHighlightedSeries,\n  isGroupNavigation,\n  isHandlersDisabled,\n  highlightX,\n}: UseMouseHoverProps<T>) {\n  const isMouseOverPopover = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (popoverRef.current?.firstChild) {\n      const popoverPosition = (popoverRef.current.firstChild as HTMLElement).getBoundingClientRect();\n      if (\n        event.clientX > popoverPosition.x - POPOVER_DEADZONE &&\n        event.clientX < popoverPosition.x + popoverPosition.width + POPOVER_DEADZONE &&\n        event.clientY > popoverPosition.y - POPOVER_DEADZONE &&\n        event.clientY < popoverPosition.y + popoverPosition.height + POPOVER_DEADZONE\n      ) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  const onSeriesMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n\n    const closestX = scaledSeries\n      .map(v => v.x)\n      .reduce((prev, curr) => (Math.abs(curr - offsetX) < Math.abs(prev - offsetX) ? curr : prev), -Infinity);\n\n    if (isFinite(closestX)) {\n      const offsetY = event.clientY - svgRect.top;\n      const closestY = scaledSeries\n        .filter(v => v.x === closestX || isYThreshold(v.series))\n        .map(v => v.y)\n        .reduce((prev, curr) => (Math.abs(curr - offsetY) < Math.abs(prev - offsetY) ? curr : prev), -Infinity);\n\n      if (\n        isFinite(closestY) &&\n        Math.abs(offsetX - closestX) < MAX_HOVER_MARGIN &&\n        Math.abs(offsetY - closestY) < MAX_HOVER_MARGIN\n      ) {\n        const [{ color, datum, series }] = scaledSeries.filter(\n          s => (s.x === closestX || isYThreshold(s.series)) && s.y === closestY\n        );\n        highlightPoint({ x: closestX, y: closestY, color, datum, series });\n      } else {\n        let datumX = null;\n        for (const point of scaledSeries) {\n          if (point.x === closestX) {\n            datumX = point.datum?.x ?? null;\n            break;\n          }\n        }\n        highlightX({ scaledX: closestX, label: datumX });\n      }\n    }\n  };\n\n  const onGroupMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    const svgRect = (event.target as SVGElement).getBoundingClientRect();\n    const offsetX = event.clientX - svgRect.left;\n    const offsetY = event.clientY - svgRect.top;\n\n    // If hovering over some group - highlight it.\n    for (let groupIndex = 0; groupIndex < barGroups.length; groupIndex++) {\n      const {\n        position: { x, y, width, height },\n      } = barGroups[groupIndex];\n\n      if (x <= offsetX && offsetX <= x + width && y <= offsetY && offsetY <= y + height) {\n        highlightGroup(groupIndex);\n        return;\n      }\n    }\n    // Otherwise - clear the highlight.\n    clearHighlightedSeries();\n  };\n\n  const onSVGMouseMove = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (event.target === plotRef.current!.svg && !isHandlersDisabled && !isMouseOverPopover(event)) {\n      if (isGroupNavigation) {\n        onGroupMouseMove(event);\n      } else if (scaledSeries.length > 0) {\n        onSeriesMouseMove(event);\n      }\n    }\n  };\n\n  const onSVGMouseOut = (event: React.MouseEvent<SVGElement, MouseEvent>) => {\n    if (isHandlersDisabled || isMouseOverPopover(event)) {\n      return;\n    }\n    if (\n      !nodeContains(plotRef.current!.svg, event.relatedTarget) ||\n      (event.relatedTarget && (event.relatedTarget as Element).classList.contains(styles.series))\n    ) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  const onPopoverLeave = (event: React.MouseEvent) => {\n    if (!isHandlersDisabled && nodeContains(plotRef.current!.svg, event.relatedTarget)) {\n      highlightX(null);\n      clearHighlightedSeries();\n    }\n  };\n\n  return { onSVGMouseMove, onSVGMouseOut, onPopoverLeave };\n}\n"],"mappings":"AAAA;AACA;AACA,SAASA,YAAY,QAAQ,0CAA0C;AAMvE,SAASC,YAAY,QAAQ,UAAU;AAEvC,OAAOC,MAAM,MAAM,kBAAkB;AAErC,MAAMC,gBAAgB,GAAG,CAAC;AAC1B,MAAMC,gBAAgB,GAAG,EAAE;AAe3B,OAAM,SAAUC,aAAaA,CAAI;EAC/BC,OAAO;EACPC,UAAU;EACVC,YAAY;EACZC,SAAS;EACTC,cAAc;EACdC,cAAc;EACdC,sBAAsB;EACtBC,iBAAiB;EACjBC,kBAAkB;EAClBC;AAAU,CACY;EACtB,MAAMC,kBAAkB,GAAIC,KAA+C,IAAI;;IAC7E,IAAI,CAAAC,EAAA,GAAAX,UAAU,CAACY,OAAO,cAAAD,EAAA,uBAAAA,EAAA,CAAEE,UAAU,EAAE;MAClC,MAAMC,eAAe,GAAId,UAAU,CAACY,OAAO,CAACC,UAA0B,CAACE,qBAAqB,EAAE;MAC9F,IACEL,KAAK,CAACM,OAAO,GAAGF,eAAe,CAACG,CAAC,GAAGpB,gBAAgB,IACpDa,KAAK,CAACM,OAAO,GAAGF,eAAe,CAACG,CAAC,GAAGH,eAAe,CAACI,KAAK,GAAGrB,gBAAgB,IAC5Ea,KAAK,CAACS,OAAO,GAAGL,eAAe,CAACM,CAAC,GAAGvB,gBAAgB,IACpDa,KAAK,CAACS,OAAO,GAAGL,eAAe,CAACM,CAAC,GAAGN,eAAe,CAACO,MAAM,GAAGxB,gBAAgB,EAC7E;QACA,OAAO,IAAI;;;IAGf,OAAO,KAAK;EACd,CAAC;EAED,MAAMyB,iBAAiB,GAAIZ,KAA+C,IAAI;;IAC5E,MAAMa,OAAO,GAAIb,KAAK,CAACc,MAAqB,CAACT,qBAAqB,EAAE;IACpE,MAAMU,OAAO,GAAGf,KAAK,CAACM,OAAO,GAAGO,OAAO,CAACG,IAAI;IAE5C,MAAMC,QAAQ,GAAG1B,YAAY,CAC1B2B,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACZ,CAAC,CAAC,CACba,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAMC,IAAI,CAACC,GAAG,CAACF,IAAI,GAAGP,OAAO,CAAC,GAAGQ,IAAI,CAACC,GAAG,CAACH,IAAI,GAAGN,OAAO,CAAC,GAAGO,IAAI,GAAGD,IAAK,EAAE,CAACI,QAAQ,CAAC;IAEzG,IAAIC,QAAQ,CAACT,QAAQ,CAAC,EAAE;MACtB,MAAMU,OAAO,GAAG3B,KAAK,CAACS,OAAO,GAAGI,OAAO,CAACe,GAAG;MAC3C,MAAMC,QAAQ,GAAGtC,YAAY,CAC1BuC,MAAM,CAACX,CAAC,IAAIA,CAAC,CAACZ,CAAC,KAAKU,QAAQ,IAAIjC,YAAY,CAACmC,CAAC,CAACY,MAAM,CAAC,CAAC,CACvDb,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACT,CAAC,CAAC,CACbU,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,KAAMC,IAAI,CAACC,GAAG,CAACF,IAAI,GAAGK,OAAO,CAAC,GAAGJ,IAAI,CAACC,GAAG,CAACH,IAAI,GAAGM,OAAO,CAAC,GAAGL,IAAI,GAAGD,IAAK,EAAE,CAACI,QAAQ,CAAC;MAEzG,IACEC,QAAQ,CAACG,QAAQ,CAAC,IAClBN,IAAI,CAACC,GAAG,CAACT,OAAO,GAAGE,QAAQ,CAAC,GAAG/B,gBAAgB,IAC/CqC,IAAI,CAACC,GAAG,CAACG,OAAO,GAAGE,QAAQ,CAAC,GAAG3C,gBAAgB,EAC/C;QACA,MAAM,CAAC;UAAE8C,KAAK;UAAEC,KAAK;UAAEF;QAAM,CAAE,CAAC,GAAGxC,YAAY,CAACuC,MAAM,CACpDI,CAAC,IAAI,CAACA,CAAC,CAAC3B,CAAC,KAAKU,QAAQ,IAAIjC,YAAY,CAACkD,CAAC,CAACH,MAAM,CAAC,KAAKG,CAAC,CAACxB,CAAC,KAAKmB,QAAQ,CACtE;QACDpC,cAAc,CAAC;UAAEc,CAAC,EAAEU,QAAQ;UAAEP,CAAC,EAAEmB,QAAQ;UAAEG,KAAK;UAAEC,KAAK;UAAEF;QAAM,CAAE,CAAC;OACnE,MAAM;QACL,IAAII,MAAM,GAAG,IAAI;QACjB,KAAK,MAAMC,KAAK,IAAI7C,YAAY,EAAE;UAChC,IAAI6C,KAAK,CAAC7B,CAAC,KAAKU,QAAQ,EAAE;YACxBkB,MAAM,GAAG,CAAAE,EAAA,IAAApC,EAAA,GAAAmC,KAAK,CAACH,KAAK,cAAAhC,EAAA,uBAAAA,EAAA,CAAEM,CAAC,cAAA8B,EAAA,cAAAA,EAAA,GAAI,IAAI;YAC/B;;;QAGJvC,UAAU,CAAC;UAAEwC,OAAO,EAAErB,QAAQ;UAAEsB,KAAK,EAAEJ;QAAM,CAAE,CAAC;;;EAGtD,CAAC;EAED,MAAMK,gBAAgB,GAAIxC,KAA+C,IAAI;IAC3E,MAAMa,OAAO,GAAIb,KAAK,CAACc,MAAqB,CAACT,qBAAqB,EAAE;IACpE,MAAMU,OAAO,GAAGf,KAAK,CAACM,OAAO,GAAGO,OAAO,CAACG,IAAI;IAC5C,MAAMW,OAAO,GAAG3B,KAAK,CAACS,OAAO,GAAGI,OAAO,CAACe,GAAG;IAE3C;IACA,KAAK,IAAIa,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAGjD,SAAS,CAACkD,MAAM,EAAED,UAAU,EAAE,EAAE;MACpE,MAAM;QACJE,QAAQ,EAAE;UAAEpC,CAAC;UAAEG,CAAC;UAAEF,KAAK;UAAEG;QAAM;MAAE,CAClC,GAAGnB,SAAS,CAACiD,UAAU,CAAC;MAEzB,IAAIlC,CAAC,IAAIQ,OAAO,IAAIA,OAAO,IAAIR,CAAC,GAAGC,KAAK,IAAIE,CAAC,IAAIiB,OAAO,IAAIA,OAAO,IAAIjB,CAAC,GAAGC,MAAM,EAAE;QACjFjB,cAAc,CAAC+C,UAAU,CAAC;QAC1B;;;IAGJ;IACA9C,sBAAsB,EAAE;EAC1B,CAAC;EAED,MAAMiD,cAAc,GAAI5C,KAA+C,IAAI;IACzE,IAAIA,KAAK,CAACc,MAAM,KAAKzB,OAAO,CAACa,OAAQ,CAAC2C,GAAG,IAAI,CAAChD,kBAAkB,IAAI,CAACE,kBAAkB,CAACC,KAAK,CAAC,EAAE;MAC9F,IAAIJ,iBAAiB,EAAE;QACrB4C,gBAAgB,CAACxC,KAAK,CAAC;OACxB,MAAM,IAAIT,YAAY,CAACmD,MAAM,GAAG,CAAC,EAAE;QAClC9B,iBAAiB,CAACZ,KAAK,CAAC;;;EAG9B,CAAC;EAED,MAAM8C,aAAa,GAAI9C,KAA+C,IAAI;IACxE,IAAIH,kBAAkB,IAAIE,kBAAkB,CAACC,KAAK,CAAC,EAAE;MACnD;;IAEF,IACE,CAACjB,YAAY,CAACM,OAAO,CAACa,OAAQ,CAAC2C,GAAG,EAAE7C,KAAK,CAAC+C,aAAa,CAAC,IACvD/C,KAAK,CAAC+C,aAAa,IAAK/C,KAAK,CAAC+C,aAAyB,CAACC,SAAS,CAACC,QAAQ,CAAChE,MAAM,CAAC8C,MAAM,CAAE,EAC3F;MACAjC,UAAU,CAAC,IAAI,CAAC;MAChBH,sBAAsB,EAAE;;EAE5B,CAAC;EAED,MAAMuD,cAAc,GAAIlD,KAAuB,IAAI;IACjD,IAAI,CAACH,kBAAkB,IAAId,YAAY,CAACM,OAAO,CAACa,OAAQ,CAAC2C,GAAG,EAAE7C,KAAK,CAAC+C,aAAa,CAAC,EAAE;MAClFjD,UAAU,CAAC,IAAI,CAAC;MAChBH,sBAAsB,EAAE;;EAE5B,CAAC;EAED,OAAO;IAAEiD,cAAc;IAAEE,aAAa;IAAEI;EAAc,CAAE;AAC1D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}