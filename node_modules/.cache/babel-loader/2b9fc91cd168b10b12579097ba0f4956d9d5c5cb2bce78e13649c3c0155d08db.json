{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { arc } from 'd3-shape';\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\nimport ResponsiveText from './responsive-text';\nimport { balanceLabelNodes, computeSmartAngle } from './utils';\nimport styles from './styles.css.js';\nfunction LabelElement({\n  x,\n  y,\n  hideTitles,\n  hideDescriptions,\n  rightSide,\n  title,\n  description,\n  containerBoundaries\n}) {\n  return React.createElement(\"g\", {\n    className: styles['label-text'],\n    transform: \"\",\n    \"data-x\": x,\n    \"data-y\": y\n  }, !hideTitles && React.createElement(ResponsiveText, {\n    x: x,\n    y: y,\n    rightSide: rightSide,\n    containerBoundaries: containerBoundaries\n  }, title), !hideDescriptions && description && React.createElement(ResponsiveText, {\n    x: x,\n    y: y + (hideTitles ? 0 : 18),\n    rightSide: rightSide,\n    className: styles.label__description,\n    containerBoundaries: containerBoundaries\n  }, description));\n}\nexport default ({\n  pieData,\n  dimensions,\n  highlightedSegment,\n  segmentDescription,\n  visibleDataSum,\n  hideTitles,\n  hideDescriptions,\n  containerRef\n}) => {\n  const containerBoundaries = useElementBoundaries(containerRef);\n  const shouldOptimizeLabels = containerBoundaries.right - containerBoundaries.left - (dimensions.outerRadius + dimensions.innerLabelPadding) * 2 < 300;\n  const markers = useMemo(() => {\n    const {\n      outerRadius: radius,\n      innerLabelPadding\n    } = dimensions;\n    // More arc factories for the label positioning\n    const arcMarkerStart = arc().innerRadius(radius - 1).outerRadius(radius - 1);\n    const arcMarkerBreak = arc().innerRadius(radius + innerLabelPadding).outerRadius(radius + innerLabelPadding);\n    return pieData.map((datum, i) => {\n      const labelDatum = pieData[i];\n      const smartAngle = computeSmartAngle(labelDatum.startAngle, labelDatum.endAngle, shouldOptimizeLabels);\n      // Make the marker line longer if the segment is closer to the top or bottom of the chart\n      const lineExtension = 0.5 * Math.cos(2 * smartAngle) + 0.5;\n      arcMarkerBreak.outerRadius(radius + 20 * lineExtension);\n      arcMarkerBreak.innerRadius(radius + 20 * lineExtension);\n      const [startX, startY] = arcMarkerStart.centroid(Object.assign(Object.assign({}, datum), {\n        startAngle: smartAngle,\n        endAngle: smartAngle\n      }));\n      const [breakX, breakY] = arcMarkerBreak.centroid(Object.assign(Object.assign({}, datum), {\n        startAngle: smartAngle,\n        endAngle: smartAngle\n      }));\n      const rightSide = smartAngle < Math.PI;\n      const endX = shouldOptimizeLabels ? breakX + 20 * (rightSide ? 1 : -1) : (radius + 20) * (rightSide ? 1 : -1);\n      const textX = endX + 5 * (rightSide ? 1 : -1);\n      return {\n        startX,\n        startY,\n        breakX,\n        breakY,\n        endX,\n        endY: breakY,\n        textX,\n        textY: breakY,\n        rightSide,\n        datum\n      };\n    });\n  }, [pieData, dimensions, shouldOptimizeLabels]);\n  const rootRef = useRef(null);\n  useLayoutEffect(() => {\n    if (!rootRef.current) {\n      return;\n    }\n    // Relax labels that are overlapping\n    const labelNodes = rootRef.current.querySelectorAll(`.${styles['label-text']}`);\n    balanceLabelNodes(labelNodes, markers, false, dimensions.outerRadius + dimensions.innerLabelPadding);\n    balanceLabelNodes(labelNodes, markers, true, dimensions.outerRadius + dimensions.innerLabelPadding);\n  }, [markers, pieData, dimensions]);\n  return React.createElement(\"g\", {\n    className: styles.markers,\n    \"aria-hidden\": \"true\",\n    ref: rootRef\n  }, markers.map(({\n    startX,\n    startY,\n    breakX,\n    breakY,\n    endX,\n    endY,\n    textX,\n    textY,\n    rightSide,\n    datum\n  }) => {\n    const segment = datum.data.datum;\n    const description = segmentDescription === null || segmentDescription === void 0 ? void 0 : segmentDescription(segment, visibleDataSum);\n    if (hideTitles && !description || hideDescriptions && !segment.title) {\n      return null;\n    }\n    return React.createElement(\"g\", {\n      key: datum.data.index,\n      className: clsx(styles.label, {\n        [styles['label--highlighted']]: highlightedSegment === segment,\n        [styles['label--dimmed']]: highlightedSegment !== null && highlightedSegment !== segment,\n        [styles['label--align-right']]: !rightSide\n      })\n    }, React.createElement(\"line\", {\n      x1: startX,\n      y1: startY,\n      x2: breakX,\n      y2: breakY\n    }), React.createElement(\"line\", {\n      x1: breakX,\n      y1: breakY,\n      x2: endX,\n      y2: endY,\n      className: styles['label-line']\n    }), React.createElement(LabelElement, {\n      x: textX,\n      y: textY,\n      rightSide: rightSide,\n      title: segment.title,\n      description: description,\n      hideTitles: hideTitles,\n      hideDescriptions: hideDescriptions,\n      containerBoundaries: containerBoundaries\n    }));\n  }));\n};\nfunction useElementBoundaries(ref) {\n  const [state, setState] = useState({\n    left: 0,\n    right: 0\n  });\n  useResizeObserver(ref, entry => {\n    const elementRect = entry.target.getBoundingClientRect();\n    setState({\n      left: elementRect.left,\n      right: elementRect.right\n    });\n  });\n  return state;\n}","map":{"version":3,"names":["React","useLayoutEffect","useMemo","useRef","useState","clsx","arc","useResizeObserver","ResponsiveText","balanceLabelNodes","computeSmartAngle","styles","LabelElement","x","y","hideTitles","hideDescriptions","rightSide","title","description","containerBoundaries","createElement","className","transform","label__description","pieData","dimensions","highlightedSegment","segmentDescription","visibleDataSum","containerRef","useElementBoundaries","shouldOptimizeLabels","right","left","outerRadius","innerLabelPadding","markers","radius","arcMarkerStart","innerRadius","arcMarkerBreak","map","datum","i","labelDatum","smartAngle","startAngle","endAngle","lineExtension","Math","cos","startX","startY","centroid","Object","assign","breakX","breakY","PI","endX","textX","endY","textY","rootRef","current","labelNodes","querySelectorAll","ref","segment","data","key","index","label","x1","y1","x2","y2","state","setState","entry","elementRect","target","getBoundingClientRect"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/pie-chart/labels.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport { arc, PieArcDatum } from 'd3-shape';\n\nimport { useResizeObserver } from '@cloudscape-design/component-toolkit/internal';\n\nimport { PieChartProps } from './interfaces';\nimport { InternalChartDatum } from './pie-chart';\nimport ResponsiveText from './responsive-text';\nimport { balanceLabelNodes, computeSmartAngle, Dimension } from './utils';\n\nimport styles from './styles.css.js';\n\nexport interface LabelsProps<T> {\n  pieData: PieArcDatum<InternalChartDatum<T>>[];\n  visibleDataSum: number;\n  dimensions: Dimension;\n  hideTitles: boolean;\n  hideDescriptions: boolean;\n  highlightedSegment: PieChartProps.Datum | null;\n  segmentDescription?: PieChartProps.SegmentDescriptionFunction<T>;\n  containerRef: React.RefObject<HTMLDivElement>;\n}\n\ninterface LabelElementProps {\n  x: number;\n  y: number;\n  rightSide: boolean;\n  hideTitles: boolean;\n  hideDescriptions: boolean;\n  title: PieChartProps.Datum['title'];\n  description?: string;\n  containerBoundaries: null | { left: number; right: number };\n}\n\nfunction LabelElement({\n  x,\n  y,\n  hideTitles,\n  hideDescriptions,\n  rightSide,\n  title,\n  description,\n  containerBoundaries,\n}: LabelElementProps) {\n  return (\n    <g className={styles['label-text']} transform=\"\" data-x={x} data-y={y}>\n      {!hideTitles && (\n        <ResponsiveText x={x} y={y} rightSide={rightSide} containerBoundaries={containerBoundaries}>\n          {title}\n        </ResponsiveText>\n      )}\n      {!hideDescriptions && description && (\n        <ResponsiveText\n          x={x}\n          y={y + (hideTitles ? 0 : 18)}\n          rightSide={rightSide}\n          className={styles.label__description}\n          containerBoundaries={containerBoundaries}\n        >\n          {description}\n        </ResponsiveText>\n      )}\n    </g>\n  );\n}\n\nexport default <T extends PieChartProps.Datum>({\n  pieData,\n  dimensions,\n  highlightedSegment,\n  segmentDescription,\n  visibleDataSum,\n  hideTitles,\n  hideDescriptions,\n  containerRef,\n}: LabelsProps<T>) => {\n  const containerBoundaries = useElementBoundaries(containerRef);\n  const shouldOptimizeLabels =\n    containerBoundaries.right - containerBoundaries.left - (dimensions.outerRadius + dimensions.innerLabelPadding) * 2 <\n    300;\n  const markers = useMemo(() => {\n    const { outerRadius: radius, innerLabelPadding } = dimensions;\n\n    // More arc factories for the label positioning\n    const arcMarkerStart = arc<PieArcDatum<any>>()\n      .innerRadius(radius - 1)\n      .outerRadius(radius - 1);\n\n    const arcMarkerBreak = arc<PieArcDatum<any>>()\n      .innerRadius(radius + innerLabelPadding)\n      .outerRadius(radius + innerLabelPadding);\n\n    return pieData.map((datum, i) => {\n      const labelDatum = pieData[i];\n      const smartAngle = computeSmartAngle(labelDatum.startAngle, labelDatum.endAngle, shouldOptimizeLabels);\n\n      // Make the marker line longer if the segment is closer to the top or bottom of the chart\n      const lineExtension = 0.5 * Math.cos(2 * smartAngle) + 0.5;\n      arcMarkerBreak.outerRadius(radius + 20 * lineExtension);\n      arcMarkerBreak.innerRadius(radius + 20 * lineExtension);\n      const [startX, startY] = arcMarkerStart.centroid({ ...datum, startAngle: smartAngle, endAngle: smartAngle });\n      const [breakX, breakY] = arcMarkerBreak.centroid({ ...datum, startAngle: smartAngle, endAngle: smartAngle });\n\n      const rightSide = smartAngle < Math.PI;\n      const endX = shouldOptimizeLabels ? breakX + 20 * (rightSide ? 1 : -1) : (radius + 20) * (rightSide ? 1 : -1);\n      const textX = endX + 5 * (rightSide ? 1 : -1);\n\n      return {\n        startX,\n        startY,\n        breakX,\n        breakY,\n        endX,\n        endY: breakY,\n        textX,\n        textY: breakY,\n        rightSide,\n        datum,\n      };\n    });\n  }, [pieData, dimensions, shouldOptimizeLabels]);\n\n  const rootRef = useRef<SVGGElement>(null);\n\n  useLayoutEffect(() => {\n    if (!rootRef.current) {\n      return;\n    }\n\n    // Relax labels that are overlapping\n    const labelNodes = rootRef.current.querySelectorAll<SVGGElement>(`.${styles['label-text']}`);\n    balanceLabelNodes(labelNodes, markers, false, dimensions.outerRadius + dimensions.innerLabelPadding);\n    balanceLabelNodes(labelNodes, markers, true, dimensions.outerRadius + dimensions.innerLabelPadding);\n  }, [markers, pieData, dimensions]);\n\n  return (\n    <g className={styles.markers} aria-hidden=\"true\" ref={rootRef}>\n      {markers.map(({ startX, startY, breakX, breakY, endX, endY, textX, textY, rightSide, datum }) => {\n        const segment = datum.data.datum;\n        const description = segmentDescription?.(segment, visibleDataSum);\n        if ((hideTitles && !description) || (hideDescriptions && !segment.title)) {\n          return null;\n        }\n        return (\n          <g\n            key={datum.data.index}\n            className={clsx(styles.label, {\n              [styles['label--highlighted']]: highlightedSegment === segment,\n              [styles['label--dimmed']]: highlightedSegment !== null && highlightedSegment !== segment,\n              [styles['label--align-right']]: !rightSide,\n            })}\n          >\n            <line x1={startX} y1={startY} x2={breakX} y2={breakY} />\n            <line x1={breakX} y1={breakY} x2={endX} y2={endY} className={styles['label-line']} />\n            <LabelElement\n              x={textX}\n              y={textY}\n              rightSide={rightSide}\n              title={segment.title}\n              description={description}\n              hideTitles={hideTitles}\n              hideDescriptions={hideDescriptions}\n              containerBoundaries={containerBoundaries}\n            />\n          </g>\n        );\n      })}\n    </g>\n  );\n};\n\nfunction useElementBoundaries(ref: React.RefObject<HTMLElement>): { left: number; right: number } {\n  const [state, setState] = useState({ left: 0, right: 0 });\n  useResizeObserver(ref, entry => {\n    const elementRect = entry.target.getBoundingClientRect();\n    setState({ left: elementRect.left, right: elementRect.right });\n  });\n  return state;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}