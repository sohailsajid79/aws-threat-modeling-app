{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { __rest } from \"tslib\";\n/* eslint-disable @cloudscape-design/prefer-live-region */\nimport React, { memo, useEffect, useRef } from 'react';\nimport clsx from 'clsx';\nimport ScreenreaderOnly from '../screenreader-only';\nimport styles from './styles.css.js';\n/**\n * The live region is hidden in the layout, but visible for screen readers.\n * It's purpose it to announce changes e.g. when custom navigation logic is used.\n *\n * The way live region works differently in different browsers and screen readers and\n * it is recommended to manually test every new implementation.\n *\n * If you notice there are different words being merged together,\n * check if there are text nodes not being wrapped in elements, like:\n * ```\n * <LiveRegion>\n *   {title}\n *   <span><Details /></span>\n * </LiveRegion>\n * ```\n *\n * To fix, wrap \"title\" in an element:\n * ```\n * <LiveRegion>\n *   <span>{title}</span>\n *   <span><Details /></span>\n * </LiveRegion>\n * ```\n *\n * Or create a single text node if possible:\n * ```\n * <LiveRegion>\n *   {`${title} ${details}`}\n * </LiveRegion>\n * ```\n *\n * The live region is always atomic, because non-atomic regions can be treated by screen readers\n * differently and produce unexpected results. To imitate non-atomic announcements simply use\n * multiple live regions:\n * ```\n * <>\n *   <LiveRegion>{title}</LiveRegion>\n *   <LiveRegion><Details /></LiveRegion>\n * </>\n * ```\n *\n * If you place interactive content inside the LiveRegion, the content will still be\n * interactive (e.g. as a tab stop). Consider using the `source` property instead.\n */\nexport default memo(LiveRegion);\nfunction LiveRegion(_a) {\n  var {\n      assertive = false,\n      delay = 10,\n      visible = false,\n      tagName: TagName = 'span',\n      children,\n      id,\n      source\n    } = _a,\n    restProps = __rest(_a, [\"assertive\", \"delay\", \"visible\", \"tagName\", \"children\", \"id\", \"source\"]);\n  const sourceRef = useRef(null);\n  const targetRef = useRef(null);\n  /*\n    When React state changes, React often produces too many DOM updates, causing NVDA to\n    issue many announcements for the same logical event (See https://github.com/nvaccess/nvda/issues/7996).\n       The code below imitates a debouncing, scheduling a callback every time new React state\n    update is detected. When a callback resolves, it copies content from a muted element\n    to the live region, which is recognized by screen readers as an update.\n       If the use case requires no announcement to be ignored, use delay = 0, but ensure it\n    does not impact the performance. If it does, prefer using a string as children prop.\n  */\n  useEffect(() => {\n    function getSourceContent() {\n      if (source) {\n        return source.map(item => {\n          if (!item) {\n            return undefined;\n          }\n          if (typeof item === 'string') {\n            return item;\n          }\n          if (item.current) {\n            return extractInnerText(item.current);\n          }\n        }).filter(Boolean).join(' ');\n      }\n      if (sourceRef.current) {\n        return extractInnerText(sourceRef.current);\n      }\n    }\n    function updateLiveRegion() {\n      const sourceContent = getSourceContent();\n      if (targetRef.current && sourceContent) {\n        const targetContent = extractInnerText(targetRef.current);\n        if (targetContent !== sourceContent) {\n          // The aria-atomic does not work properly in Voice Over, causing\n          // certain parts of the content to be ignored. To fix that,\n          // we assign the source text content as a single node.\n          targetRef.current.innerText = sourceContent;\n        }\n      }\n    }\n    let timeoutId;\n    if (delay) {\n      timeoutId = setTimeout(updateLiveRegion, delay);\n    } else {\n      updateLiveRegion();\n    }\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n  return React.createElement(React.Fragment, null, visible && !source && React.createElement(TagName, {\n    ref: sourceRef,\n    id: id,\n    className: styles.source\n  }, children), React.createElement(ScreenreaderOnly, Object.assign({}, restProps, {\n    className: clsx(styles.root, restProps.className)\n  }), !visible && !source && React.createElement(TagName, {\n    ref: sourceRef,\n    \"aria-hidden\": \"true\",\n    className: styles.source\n  }, children), React.createElement(\"span\", {\n    ref: targetRef,\n    \"aria-atomic\": \"true\",\n    \"aria-live\": assertive ? 'assertive' : 'polite'\n  })));\n}\n// This only extracts text content from the node including all its children which is enough for now.\n// To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n// ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\nfunction extractInnerText(node) {\n  return (node.innerText || '').replace(/\\s+/g, ' ').trim();\n}","map":{"version":3,"names":["React","memo","useEffect","useRef","clsx","ScreenreaderOnly","styles","LiveRegion","_a","assertive","delay","visible","tagName","TagName","children","id","source","restProps","__rest","sourceRef","targetRef","getSourceContent","map","item","undefined","current","extractInnerText","filter","Boolean","join","updateLiveRegion","sourceContent","targetContent","innerText","timeoutId","setTimeout","clearTimeout","createElement","Fragment","ref","className","Object","assign","root","node","replace","trim"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/components/live-region/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @cloudscape-design/prefer-live-region */\n\nimport React, { memo, useEffect, useRef } from 'react';\nimport clsx from 'clsx';\n\nimport ScreenreaderOnly, { ScreenreaderOnlyProps } from '../screenreader-only';\n\nimport styles from './styles.css.js';\n\nexport interface LiveRegionProps extends ScreenreaderOnlyProps {\n  assertive?: boolean;\n  delay?: number;\n  visible?: boolean;\n  tagName?: 'span' | 'div';\n  id?: string;\n  /**\n   * Use a list of strings and/or existing DOM elements for building the\n   * announcement text. This avoids rendering separate content just for this\n   * LiveRegion.\n   *\n   * If this property is set, the `children` will be ignored.\n   */\n  source?: Array<string | React.RefObject<HTMLElement> | undefined>;\n}\n\n/**\n * The live region is hidden in the layout, but visible for screen readers.\n * It's purpose it to announce changes e.g. when custom navigation logic is used.\n *\n * The way live region works differently in different browsers and screen readers and\n * it is recommended to manually test every new implementation.\n *\n * If you notice there are different words being merged together,\n * check if there are text nodes not being wrapped in elements, like:\n * ```\n * <LiveRegion>\n *   {title}\n *   <span><Details /></span>\n * </LiveRegion>\n * ```\n *\n * To fix, wrap \"title\" in an element:\n * ```\n * <LiveRegion>\n *   <span>{title}</span>\n *   <span><Details /></span>\n * </LiveRegion>\n * ```\n *\n * Or create a single text node if possible:\n * ```\n * <LiveRegion>\n *   {`${title} ${details}`}\n * </LiveRegion>\n * ```\n *\n * The live region is always atomic, because non-atomic regions can be treated by screen readers\n * differently and produce unexpected results. To imitate non-atomic announcements simply use\n * multiple live regions:\n * ```\n * <>\n *   <LiveRegion>{title}</LiveRegion>\n *   <LiveRegion><Details /></LiveRegion>\n * </>\n * ```\n *\n * If you place interactive content inside the LiveRegion, the content will still be\n * interactive (e.g. as a tab stop). Consider using the `source` property instead.\n */\nexport default memo(LiveRegion);\n\nfunction LiveRegion({\n  assertive = false,\n  delay = 10,\n  visible = false,\n  tagName: TagName = 'span',\n  children,\n  id,\n  source,\n  ...restProps\n}: LiveRegionProps) {\n  const sourceRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n  const targetRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n\n  /*\n    When React state changes, React often produces too many DOM updates, causing NVDA to\n    issue many announcements for the same logical event (See https://github.com/nvaccess/nvda/issues/7996).\n\n    The code below imitates a debouncing, scheduling a callback every time new React state\n    update is detected. When a callback resolves, it copies content from a muted element\n    to the live region, which is recognized by screen readers as an update.\n\n    If the use case requires no announcement to be ignored, use delay = 0, but ensure it\n    does not impact the performance. If it does, prefer using a string as children prop.\n  */\n  useEffect(() => {\n    function getSourceContent() {\n      if (source) {\n        return source\n          .map(item => {\n            if (!item) {\n              return undefined;\n            }\n            if (typeof item === 'string') {\n              return item;\n            }\n            if (item.current) {\n              return extractInnerText(item.current);\n            }\n          })\n          .filter(Boolean)\n          .join(' ');\n      }\n\n      if (sourceRef.current) {\n        return extractInnerText(sourceRef.current);\n      }\n    }\n    function updateLiveRegion() {\n      const sourceContent = getSourceContent();\n\n      if (targetRef.current && sourceContent) {\n        const targetContent = extractInnerText(targetRef.current);\n        if (targetContent !== sourceContent) {\n          // The aria-atomic does not work properly in Voice Over, causing\n          // certain parts of the content to be ignored. To fix that,\n          // we assign the source text content as a single node.\n          targetRef.current.innerText = sourceContent;\n        }\n      }\n    }\n\n    let timeoutId: null | number;\n    if (delay) {\n      timeoutId = setTimeout(updateLiveRegion, delay);\n    } else {\n      updateLiveRegion();\n    }\n\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n\n  return (\n    <>\n      {visible && !source && (\n        <TagName ref={sourceRef} id={id} className={styles.source}>\n          {children}\n        </TagName>\n      )}\n\n      <ScreenreaderOnly {...restProps} className={clsx(styles.root, restProps.className)}>\n        {!visible && !source && (\n          <TagName ref={sourceRef} aria-hidden=\"true\" className={styles.source}>\n            {children}\n          </TagName>\n        )}\n\n        <span ref={targetRef} aria-atomic=\"true\" aria-live={assertive ? 'assertive' : 'polite'}></span>\n      </ScreenreaderOnly>\n    </>\n  );\n}\n\n// This only extracts text content from the node including all its children which is enough for now.\n// To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n// ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\nfunction extractInnerText(node: HTMLElement) {\n  return (node.innerText || '').replace(/\\s+/g, ' ').trim();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}