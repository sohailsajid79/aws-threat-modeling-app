{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { MIN_COL_SPAN, MIN_ROW_SPAN } from \"../constants\";\n/**\n * The function produces grid layout from board items and given number of columns.\n * The positional data is taken from the items when available or the default placement is used otherwise.\n */\nexport function interpretItems(items, columns) {\n  const layoutItems = [];\n  const columnHeights = Array(columns).fill(0);\n  function getColumnSpan(item) {\n    var _a;\n    const minColumnSpan = getMinColumnSpan(item, columns);\n    const columnSpan = (_a = item.columnSpan) !== null && _a !== void 0 ? _a : getDefaultColumnSpan(item, columns);\n    return Math.min(columns, Math.max(minColumnSpan, columnSpan));\n  }\n  function getRowSpan(item) {\n    var _a;\n    const minRowSpan = getMinRowSpan(item);\n    const rowSpan = (_a = item.rowSpan) !== null && _a !== void 0 ? _a : getDefaultRowSpan(item);\n    return Math.max(minRowSpan, rowSpan);\n  }\n  function getColumnOffset(item, currentOffset) {\n    var _a, _b;\n    const columnSpan = getColumnSpan(item);\n    const rowSpan = getRowSpan(item);\n    const columnOffset = (_b = (_a = item.columnOffset) === null || _a === void 0 ? void 0 : _a[columns]) !== null && _b !== void 0 ? _b : findOptimalColumnOffset(currentOffset, columnSpan, rowSpan);\n    return columnOffset + columnSpan <= columns ? columnOffset : 0;\n  }\n  function findOptimalColumnOffset(currentColumnOffset, columnSpan, rowSpan) {\n    for (let colOffset = currentColumnOffset; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    for (let colOffset = 0; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    return currentColumnOffset;\n  }\n  function getRowOffset(columnOffset, columnSpan) {\n    let rowOffset = 0;\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      rowOffset = Math.max(rowOffset, columnHeights[col]);\n    }\n    return rowOffset;\n  }\n  for (let index = 0, columnOffset = 0, rowOffset = 0; index < items.length; index++, rowOffset = 0) {\n    const columnSpan = getColumnSpan(items[index]);\n    const rowSpan = getRowSpan(items[index]);\n    columnOffset = getColumnOffset(items[index], columnOffset);\n    rowOffset = getRowOffset(columnOffset, columnSpan);\n    layoutItems.push({\n      id: items[index].id,\n      width: columnSpan,\n      height: rowSpan,\n      x: columnOffset,\n      y: rowOffset\n    });\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      columnHeights[col] = rowOffset + rowSpan;\n    }\n    columnOffset += columnSpan;\n  }\n  layoutItems.sort(itemComparator);\n  return {\n    items: layoutItems,\n    columns,\n    rows: getRowOffset(0, columns)\n  };\n}\n/**\n * The function produces new items from the current state and updated grid layout.\n * The positional data for the given number of columns is preserved as is while the other layouts are partially invalidated.\n */\nexport function transformItems(sourceItems, gridLayout, resizeTarget) {\n  const itemById = new Map(sourceItems.map(item => [item.id, item]));\n  const getItem = itemId => {\n    const item = itemById.get(itemId);\n    if (!item) {\n      throw new Error(\"Invariant violation: no matching source item found.\");\n    }\n    return item;\n  };\n  const sortedLayout = gridLayout.items.slice().sort(itemComparator);\n  const items = [];\n  let changeFromIndex = sortedLayout.findIndex(({\n    id\n  }, index) => id !== sourceItems[index].id || id === resizeTarget);\n  changeFromIndex = changeFromIndex !== -1 ? changeFromIndex : sortedLayout.length;\n  for (let index = 0; index < sortedLayout.length; index++) {\n    const {\n      id,\n      x,\n      width,\n      height\n    } = sortedLayout[index];\n    const item = {\n      ...getItem(id)\n    };\n    if (index >= changeFromIndex) {\n      item.columnOffset = undefined;\n    }\n    item.columnOffset = {\n      ...item.columnOffset,\n      [gridLayout.columns]: x\n    };\n    if (item.id === resizeTarget) {\n      item.columnSpan = width;\n      item.rowSpan = height;\n    }\n    items.push(item);\n  }\n  return items;\n}\nexport function createPlaceholdersLayout(rows, columns) {\n  const layoutItems = [];\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < columns; col++) {\n      layoutItems.push({\n        id: `awsui-placeholder-${row}-${col}`,\n        x: col,\n        y: row,\n        width: 1,\n        height: 1\n      });\n    }\n  }\n  return {\n    items: layoutItems,\n    columns,\n    rows\n  };\n}\nexport function getMinColumnSpan(item, columns) {\n  var _a, _b;\n  return Math.min(columns, Math.max(MIN_COL_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getDefaultColumnSpan(item, columns) {\n  var _a, _b;\n  return Math.min(columns, Math.max(getMinColumnSpan(item, columns), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultColumnSpan) !== null && _b !== void 0 ? _b : 0));\n}\nexport function getMinRowSpan(item) {\n  var _a, _b;\n  return Math.max(MIN_ROW_SPAN, (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.minRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nexport function getDefaultRowSpan(item) {\n  var _a, _b;\n  return Math.max(getMinRowSpan(item), (_b = (_a = item.definition) === null || _a === void 0 ? void 0 : _a.defaultRowSpan) !== null && _b !== void 0 ? _b : 0);\n}\nfunction itemComparator(a, b) {\n  if (a.y !== b.y) {\n    return a.y > b.y ? 1 : -1;\n  }\n  return a.x > b.x ? 1 : -1;\n}","map":{"version":3,"names":["MIN_COL_SPAN","MIN_ROW_SPAN","interpretItems","items","columns","layoutItems","columnHeights","Array","fill","getColumnSpan","item","minColumnSpan","getMinColumnSpan","columnSpan","_a","getDefaultColumnSpan","Math","min","max","getRowSpan","minRowSpan","getMinRowSpan","rowSpan","getDefaultRowSpan","getColumnOffset","currentOffset","columnOffset","_b","findOptimalColumnOffset","currentColumnOffset","colOffset","getRowOffset","rowOffset","col","index","length","push","id","width","height","x","y","sort","itemComparator","rows","transformItems","sourceItems","gridLayout","resizeTarget","itemById","Map","map","getItem","itemId","get","Error","sortedLayout","slice","changeFromIndex","findIndex","undefined","createPlaceholdersLayout","row","definition","defaultColumnSpan","defaultRowSpan","a","b"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/internal/utils/layout.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { MIN_COL_SPAN, MIN_ROW_SPAN } from \"../constants\";\nimport { BoardItemDefinition, GridLayout, GridLayoutItem, ItemId } from \"../interfaces\";\n\ntype Item<D = unknown> = BoardItemDefinition<D>;\n\n/**\n * The function produces grid layout from board items and given number of columns.\n * The positional data is taken from the items when available or the default placement is used otherwise.\n */\nexport function interpretItems(items: readonly Item[], columns: number): GridLayout {\n  const layoutItems: GridLayoutItem[] = [];\n  const columnHeights = Array(columns).fill(0);\n\n  function getColumnSpan(item: Item): number {\n    const minColumnSpan = getMinColumnSpan(item, columns);\n    const columnSpan = item.columnSpan ?? getDefaultColumnSpan(item, columns);\n    return Math.min(columns, Math.max(minColumnSpan, columnSpan));\n  }\n\n  function getRowSpan(item: Item): number {\n    const minRowSpan = getMinRowSpan(item);\n    const rowSpan = item.rowSpan ?? getDefaultRowSpan(item);\n    return Math.max(minRowSpan, rowSpan);\n  }\n\n  function getColumnOffset(item: Item, currentOffset: number): number {\n    const columnSpan = getColumnSpan(item);\n    const rowSpan = getRowSpan(item);\n    const columnOffset = item.columnOffset?.[columns] ?? findOptimalColumnOffset(currentOffset, columnSpan, rowSpan);\n    return columnOffset + columnSpan <= columns ? columnOffset : 0;\n  }\n\n  function findOptimalColumnOffset(currentColumnOffset: number, columnSpan: number, rowSpan: number): number {\n    for (let colOffset = currentColumnOffset; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    for (let colOffset = 0; colOffset + columnSpan <= columns; colOffset++) {\n      if (getRowOffset(colOffset, columnSpan) + rowSpan <= getRowOffset(0, columns)) {\n        return colOffset;\n      }\n    }\n    return currentColumnOffset;\n  }\n\n  function getRowOffset(columnOffset: number, columnSpan: number) {\n    let rowOffset = 0;\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      rowOffset = Math.max(rowOffset, columnHeights[col]);\n    }\n    return rowOffset;\n  }\n\n  for (let index = 0, columnOffset = 0, rowOffset = 0; index < items.length; index++, rowOffset = 0) {\n    const columnSpan = getColumnSpan(items[index]);\n    const rowSpan = getRowSpan(items[index]);\n    columnOffset = getColumnOffset(items[index], columnOffset);\n    rowOffset = getRowOffset(columnOffset, columnSpan);\n\n    layoutItems.push({ id: items[index].id, width: columnSpan, height: rowSpan, x: columnOffset, y: rowOffset });\n\n    for (let col = columnOffset; col < columnOffset + columnSpan; col++) {\n      columnHeights[col] = rowOffset + rowSpan;\n    }\n\n    columnOffset += columnSpan;\n  }\n\n  layoutItems.sort(itemComparator);\n\n  return { items: layoutItems, columns, rows: getRowOffset(0, columns) };\n}\n\n/**\n * The function produces new items from the current state and updated grid layout.\n * The positional data for the given number of columns is preserved as is while the other layouts are partially invalidated.\n */\nexport function transformItems<D>(\n  sourceItems: readonly BoardItemDefinition<D>[],\n  gridLayout: GridLayout,\n  resizeTarget: null | ItemId,\n): readonly BoardItemDefinition<D>[] {\n  const itemById = new Map(sourceItems.map((item) => [item.id, item]));\n  const getItem = (itemId: ItemId) => {\n    const item = itemById.get(itemId);\n    if (!item) {\n      throw new Error(\"Invariant violation: no matching source item found.\");\n    }\n    return item;\n  };\n\n  const sortedLayout = gridLayout.items.slice().sort(itemComparator);\n\n  const items: BoardItemDefinition<D>[] = [];\n\n  let changeFromIndex = sortedLayout.findIndex(({ id }, index) => id !== sourceItems[index].id || id === resizeTarget);\n  changeFromIndex = changeFromIndex !== -1 ? changeFromIndex : sortedLayout.length;\n\n  for (let index = 0; index < sortedLayout.length; index++) {\n    const { id, x, width, height } = sortedLayout[index];\n\n    const item = { ...getItem(id) };\n\n    if (index >= changeFromIndex) {\n      item.columnOffset = undefined;\n    }\n    item.columnOffset = { ...item.columnOffset, [gridLayout.columns]: x };\n\n    if (item.id === resizeTarget) {\n      item.columnSpan = width;\n      item.rowSpan = height;\n    }\n\n    items.push(item);\n  }\n\n  return items;\n}\n\nexport function createPlaceholdersLayout(rows: number, columns: number): GridLayout {\n  const layoutItems: GridLayoutItem[] = [];\n\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < columns; col++) {\n      layoutItems.push({ id: `awsui-placeholder-${row}-${col}`, x: col, y: row, width: 1, height: 1 });\n    }\n  }\n\n  return { items: layoutItems, columns, rows };\n}\n\nexport function getMinColumnSpan(item: Item, columns: number) {\n  return Math.min(columns, Math.max(MIN_COL_SPAN, item.definition?.minColumnSpan ?? 0));\n}\n\nexport function getDefaultColumnSpan(item: Item, columns: number) {\n  return Math.min(columns, Math.max(getMinColumnSpan(item, columns), item.definition?.defaultColumnSpan ?? 0));\n}\n\nexport function getMinRowSpan(item: Item) {\n  return Math.max(MIN_ROW_SPAN, item.definition?.minRowSpan ?? 0);\n}\n\nexport function getDefaultRowSpan(item: Item) {\n  return Math.max(getMinRowSpan(item), item.definition?.defaultRowSpan ?? 0);\n}\n\nfunction itemComparator(a: GridLayoutItem, b: GridLayoutItem) {\n  if (a.y !== b.y) {\n    return a.y > b.y ? 1 : -1;\n  }\n  return a.x > b.x ? 1 : -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}