{"ast":null,"code":"/**\n * @typedef {'toml' | 'yaml'} Preset\n *   Known name of a frontmatter style.\n *\n * @typedef Info\n *   Sequence.\n *\n *   Depending on how this structure is used, it reflects a marker or a fence.\n * @property {string} close\n *   Closing.\n * @property {string} open\n *   Opening.\n *\n * @typedef MatterProps\n *   Fields describing a kind of matter.\n * @property {string} type\n *   Node type to tokenize as.\n * @property {boolean | null | undefined} [anywhere=false]\n *   Whether matter can be found anywhere in the document, normally, only matter\n *   at the start of the document is recognized.\n *\n *   > ðŸ‘‰ **Note**: using this is a terrible idea.\n *   > Itâ€™s called frontmatter, not matter-in-the-middle or so.\n *   > This makes your markdown less portable.\n *\n * @typedef MarkerProps\n *   Marker configuration.\n * @property {Info | string} marker\n *   Character repeated 3 times, used as complete fences.\n *\n *   For example the character `'-'` will result in `'---'` being used as the\n *   fence\n *   Pass `open` and `close` to specify different characters for opening and\n *   closing fences.\n * @property {never} [fence]\n *   If `marker` is set, `fence` must not be set.\n *\n * @typedef FenceProps\n *   Fence configuration.\n * @property {Info | string} fence\n *   Complete fences.\n *\n *   This can be used when fences contain different characters or lengths\n *   other than 3.\n *   Pass `open` and `close` to interface to specify different characters for opening and\n *   closing fences.\n * @property {never} [marker]\n *   If `fence` is set, `marker` must not be set.\n *\n * @typedef {(MatterProps & FenceProps) | (MatterProps & MarkerProps)} Matter\n *   Fields describing a kind of matter.\n *\n *   > ðŸ‘‰ **Note**: using `anywhere` is a terrible idea.\n *   > Itâ€™s called frontmatter, not matter-in-the-middle or so.\n *   > This makes your markdown less portable.\n *\n *   > ðŸ‘‰ **Note**: `marker` and `fence` are mutually exclusive.\n *   > If `marker` is set, `fence` must not be set, and vice versa.\n *\n * @typedef {Matter | Preset | Array<Matter | Preset>} Options\n *   Configuration.\n */\n\nimport { fault } from 'fault';\nconst own = {}.hasOwnProperty;\nconst markers = {\n  yaml: '-',\n  toml: '+'\n};\n\n/**\n * Simplify options by normalizing them to an array of matters.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration (default: `'yaml'`).\n * @returns {Array<Matter>}\n *   List of matters.\n */\nexport function toMatters(options) {\n  /** @type {Array<Matter>} */\n  const result = [];\n  let index = -1;\n\n  /** @type {Array<Matter | Preset>} */\n  const presetsOrMatters = Array.isArray(options) ? options : options ? [options] : ['yaml'];\n  while (++index < presetsOrMatters.length) {\n    result[index] = matter(presetsOrMatters[index]);\n  }\n  return result;\n}\n\n/**\n * Simplify an option.\n *\n * @param {Matter | Preset} option\n *   Configuration.\n * @returns {Matter}\n *   Matter.\n */\nfunction matter(option) {\n  let result = option;\n  if (typeof result === 'string') {\n    if (!own.call(markers, result)) {\n      throw fault('Missing matter definition for `%s`', result);\n    }\n    result = {\n      type: result,\n      marker: markers[result]\n    };\n  } else if (typeof result !== 'object') {\n    throw fault('Expected matter to be an object, not `%j`', result);\n  }\n  if (!own.call(result, 'type')) {\n    throw fault('Missing `type` in matter `%j`', result);\n  }\n  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {\n    throw fault('Missing `marker` or `fence` in matter `%j`', result);\n  }\n  return result;\n}","map":{"version":3,"names":["fault","own","hasOwnProperty","markers","yaml","toml","toMatters","options","result","index","presetsOrMatters","Array","isArray","length","matter","option","call","type","marker"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/mdast-util-frontmatter/node_modules/micromark-extension-frontmatter/lib/to-matters.js"],"sourcesContent":["/**\n * @typedef {'toml' | 'yaml'} Preset\n *   Known name of a frontmatter style.\n *\n * @typedef Info\n *   Sequence.\n *\n *   Depending on how this structure is used, it reflects a marker or a fence.\n * @property {string} close\n *   Closing.\n * @property {string} open\n *   Opening.\n *\n * @typedef MatterProps\n *   Fields describing a kind of matter.\n * @property {string} type\n *   Node type to tokenize as.\n * @property {boolean | null | undefined} [anywhere=false]\n *   Whether matter can be found anywhere in the document, normally, only matter\n *   at the start of the document is recognized.\n *\n *   > ðŸ‘‰ **Note**: using this is a terrible idea.\n *   > Itâ€™s called frontmatter, not matter-in-the-middle or so.\n *   > This makes your markdown less portable.\n *\n * @typedef MarkerProps\n *   Marker configuration.\n * @property {Info | string} marker\n *   Character repeated 3 times, used as complete fences.\n *\n *   For example the character `'-'` will result in `'---'` being used as the\n *   fence\n *   Pass `open` and `close` to specify different characters for opening and\n *   closing fences.\n * @property {never} [fence]\n *   If `marker` is set, `fence` must not be set.\n *\n * @typedef FenceProps\n *   Fence configuration.\n * @property {Info | string} fence\n *   Complete fences.\n *\n *   This can be used when fences contain different characters or lengths\n *   other than 3.\n *   Pass `open` and `close` to interface to specify different characters for opening and\n *   closing fences.\n * @property {never} [marker]\n *   If `fence` is set, `marker` must not be set.\n *\n * @typedef {(MatterProps & FenceProps) | (MatterProps & MarkerProps)} Matter\n *   Fields describing a kind of matter.\n *\n *   > ðŸ‘‰ **Note**: using `anywhere` is a terrible idea.\n *   > Itâ€™s called frontmatter, not matter-in-the-middle or so.\n *   > This makes your markdown less portable.\n *\n *   > ðŸ‘‰ **Note**: `marker` and `fence` are mutually exclusive.\n *   > If `marker` is set, `fence` must not be set, and vice versa.\n *\n * @typedef {Matter | Preset | Array<Matter | Preset>} Options\n *   Configuration.\n */\n\nimport {fault} from 'fault'\nconst own = {}.hasOwnProperty\nconst markers = {\n  yaml: '-',\n  toml: '+'\n}\n\n/**\n * Simplify options by normalizing them to an array of matters.\n *\n * @param {Options | null | undefined} [options='yaml']\n *   Configuration (default: `'yaml'`).\n * @returns {Array<Matter>}\n *   List of matters.\n */\nexport function toMatters(options) {\n  /** @type {Array<Matter>} */\n  const result = []\n  let index = -1\n\n  /** @type {Array<Matter | Preset>} */\n  const presetsOrMatters = Array.isArray(options)\n    ? options\n    : options\n    ? [options]\n    : ['yaml']\n  while (++index < presetsOrMatters.length) {\n    result[index] = matter(presetsOrMatters[index])\n  }\n  return result\n}\n\n/**\n * Simplify an option.\n *\n * @param {Matter | Preset} option\n *   Configuration.\n * @returns {Matter}\n *   Matter.\n */\nfunction matter(option) {\n  let result = option\n  if (typeof result === 'string') {\n    if (!own.call(markers, result)) {\n      throw fault('Missing matter definition for `%s`', result)\n    }\n    result = {\n      type: result,\n      marker: markers[result]\n    }\n  } else if (typeof result !== 'object') {\n    throw fault('Expected matter to be an object, not `%j`', result)\n  }\n  if (!own.call(result, 'type')) {\n    throw fault('Missing `type` in matter `%j`', result)\n  }\n  if (!own.call(result, 'fence') && !own.call(result, 'marker')) {\n    throw fault('Missing `marker` or `fence` in matter `%j`', result)\n  }\n  return result\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,KAAK,QAAO,OAAO;AAC3B,MAAMC,GAAG,GAAG,CAAC,CAAC,CAACC,cAAc;AAC7B,MAAMC,OAAO,GAAG;EACdC,IAAI,EAAE,GAAG;EACTC,IAAI,EAAE;AACR,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,OAAO,EAAE;EACjC;EACA,MAAMC,MAAM,GAAG,EAAE;EACjB,IAAIC,KAAK,GAAG,CAAC,CAAC;;EAEd;EACA,MAAMC,gBAAgB,GAAGC,KAAK,CAACC,OAAO,CAACL,OAAO,CAAC,GAC3CA,OAAO,GACPA,OAAO,GACP,CAACA,OAAO,CAAC,GACT,CAAC,MAAM,CAAC;EACZ,OAAO,EAAEE,KAAK,GAAGC,gBAAgB,CAACG,MAAM,EAAE;IACxCL,MAAM,CAACC,KAAK,CAAC,GAAGK,MAAM,CAACJ,gBAAgB,CAACD,KAAK,CAAC,CAAC;EACjD;EACA,OAAOD,MAAM;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASM,MAAMA,CAACC,MAAM,EAAE;EACtB,IAAIP,MAAM,GAAGO,MAAM;EACnB,IAAI,OAAOP,MAAM,KAAK,QAAQ,EAAE;IAC9B,IAAI,CAACP,GAAG,CAACe,IAAI,CAACb,OAAO,EAAEK,MAAM,CAAC,EAAE;MAC9B,MAAMR,KAAK,CAAC,oCAAoC,EAAEQ,MAAM,CAAC;IAC3D;IACAA,MAAM,GAAG;MACPS,IAAI,EAAET,MAAM;MACZU,MAAM,EAAEf,OAAO,CAACK,MAAM;IACxB,CAAC;EACH,CAAC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACrC,MAAMR,KAAK,CAAC,2CAA2C,EAAEQ,MAAM,CAAC;EAClE;EACA,IAAI,CAACP,GAAG,CAACe,IAAI,CAACR,MAAM,EAAE,MAAM,CAAC,EAAE;IAC7B,MAAMR,KAAK,CAAC,+BAA+B,EAAEQ,MAAM,CAAC;EACtD;EACA,IAAI,CAACP,GAAG,CAACe,IAAI,CAACR,MAAM,EAAE,OAAO,CAAC,IAAI,CAACP,GAAG,CAACe,IAAI,CAACR,MAAM,EAAE,QAAQ,CAAC,EAAE;IAC7D,MAAMR,KAAK,CAAC,4CAA4C,EAAEQ,MAAM,CAAC;EACnE;EACA,OAAOA,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}