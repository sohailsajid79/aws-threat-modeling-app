{"ast":null,"code":"const ARROW_OFFSET = 12;\nexport const PRIORITY_MAPPING = {\n  top: ['top-center', 'top-right', 'top-left', 'bottom-center', 'bottom-right', 'bottom-left', 'right-top', 'right-bottom', 'left-top', 'left-bottom'],\n  bottom: ['bottom-center', 'bottom-right', 'bottom-left', 'top-center', 'top-right', 'top-left', 'right-top', 'right-bottom', 'left-top', 'left-bottom'],\n  left: ['left-top', 'left-bottom', 'right-top', 'right-bottom', 'bottom-center', 'top-center', 'bottom-left', 'top-left', 'bottom-right', 'top-right'],\n  right: ['right-top', 'right-bottom', 'left-top', 'left-bottom', 'bottom-center', 'top-center', 'bottom-right', 'top-right', 'bottom-left', 'top-left']\n};\nconst RECTANGLE_CALCULATIONS = {\n  'top-center': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'top-right': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'top-left': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'bottom-center': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'bottom-right': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'bottom-left': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'right-top': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'right-bottom': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'left-top': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  },\n  'left-bottom': ({\n    body,\n    trigger,\n    arrow\n  }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize\n    };\n  }\n};\nfunction fitIntoContainer(inner, outer) {\n  let {\n    insetInlineStart,\n    inlineSize,\n    insetBlockStart,\n    blockSize\n  } = inner;\n  // Adjust left boundary.\n  if (insetInlineStart < outer.insetInlineStart) {\n    inlineSize = insetInlineStart + inlineSize - outer.insetInlineStart;\n    insetInlineStart = outer.insetInlineStart;\n  }\n  // Adjust right boundary.\n  else if (insetInlineStart + inlineSize > outer.insetInlineStart + outer.inlineSize) {\n    inlineSize = outer.insetInlineStart + outer.inlineSize - insetInlineStart;\n  }\n  // Adjust top boundary.\n  if (insetBlockStart < outer.insetBlockStart) {\n    blockSize = insetBlockStart + blockSize - outer.insetBlockStart;\n    insetBlockStart = outer.insetBlockStart;\n  }\n  // Adjust bottom boundary.\n  else if (insetBlockStart + blockSize > outer.insetBlockStart + outer.blockSize) {\n    blockSize = outer.insetBlockStart + outer.blockSize - insetBlockStart;\n  }\n  return {\n    insetInlineStart,\n    inlineSize,\n    insetBlockStart,\n    blockSize\n  };\n}\nfunction getTallestRect(rect1, rect2) {\n  return rect1.blockSize >= rect2.blockSize ? rect1 : rect2;\n}\nfunction getIntersection(rectangles) {\n  let boundingBox = null;\n  for (const currentRect of rectangles) {\n    if (!boundingBox) {\n      boundingBox = currentRect;\n      continue;\n    }\n    const insetInlineStart = Math.max(boundingBox.insetInlineStart, currentRect.insetInlineStart);\n    const insetBlockStart = Math.max(boundingBox.insetBlockStart, currentRect.insetBlockStart);\n    const insetInlineEnd = Math.min(boundingBox.insetInlineStart + boundingBox.inlineSize, currentRect.insetInlineStart + currentRect.inlineSize);\n    const insetBlockEnd = Math.min(boundingBox.insetBlockStart + boundingBox.blockSize, currentRect.insetBlockStart + currentRect.blockSize);\n    if (insetInlineEnd < insetInlineStart || insetBlockEnd < insetBlockStart) {\n      return null;\n    }\n    boundingBox = {\n      insetInlineStart,\n      insetBlockStart,\n      inlineSize: insetInlineEnd - insetInlineStart,\n      blockSize: insetBlockEnd - insetBlockStart\n    };\n  }\n  return boundingBox;\n}\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles) {\n  const boundingBox = getIntersection(rectangles);\n  return boundingBox && boundingBox.blockSize * boundingBox.inlineSize;\n}\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition({\n  preferredPosition,\n  fixedInternalPosition,\n  trigger,\n  arrow,\n  body,\n  container,\n  viewport,\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal,\n  allowVerticalOverflow\n}) {\n  let bestOption = null;\n  // If a fixed internal position is passed, only consider this one.\n  const preferredInternalPositions = fixedInternalPosition ? [fixedInternalPosition] : PRIORITY_MAPPING[preferredPosition];\n  // Attempt to position the popover based on the priority list for this position.\n  for (const internalPosition of preferredInternalPositions) {\n    const rect = RECTANGLE_CALCULATIONS[internalPosition]({\n      body,\n      trigger,\n      arrow\n    });\n    const visibleArea = renderWithPortal ? getIntersection([rect, viewport]) : getIntersection([rect, viewport, container]);\n    const fitsWithoutOverflow = visibleArea && visibleArea.inlineSize === body.inlineSize && visibleArea.blockSize === body.blockSize;\n    if (fitsWithoutOverflow) {\n      return {\n        internalPosition,\n        rect\n      };\n    }\n    const newOption = {\n      rect,\n      internalPosition,\n      visibleArea\n    };\n    bestOption = getBestOption(newOption, bestOption);\n  }\n  // Use best possible placement.\n  const internalPosition = (bestOption === null || bestOption === void 0 ? void 0 : bestOption.internalPosition) || 'right-top';\n  // Get default rect for that placement.\n  const rect = RECTANGLE_CALCULATIONS[internalPosition]({\n    body,\n    trigger,\n    arrow\n  });\n  // Get largest possible rect that fits into the viewport or container.\n  // We allow the popover to overflow the viewport if allowVerticalOverflow is true _and_ the popover will be anchored to the top or the bottom.\n  // If it is anchored to the right or left, we consider that it should have enough vertical space so that applying scroll to it is a better option.\n  const tallestBoundingContainer = getTallestRect(viewport, container);\n  const boundingContainer = allowVerticalOverflow && isTopOrBottom(internalPosition) ? {\n    insetBlockStart: tallestBoundingContainer.insetBlockStart,\n    blockSize: tallestBoundingContainer.blockSize,\n    insetInlineStart: viewport.insetInlineStart,\n    inlineSize: viewport.inlineSize\n  } : viewport;\n  const optimizedRect = fitIntoContainer(rect, boundingContainer);\n  // If largest possible rect is shorter than original - set body scroll.\n  const scrollable = optimizedRect.blockSize < rect.blockSize;\n  return {\n    internalPosition,\n    rect: optimizedRect,\n    scrollable\n  };\n}\nfunction getBestOption(option1, option2) {\n  // Within calculatePosition, the only case where option2 will not be defined will be in the first call.\n  // The only case where the visibleArea of an option will be null is when the popover is totally outside of the viewport.\n  if (!(option2 === null || option2 === void 0 ? void 0 : option2.visibleArea)) {\n    return option1;\n  }\n  if (!option1.visibleArea) {\n    return option2;\n  }\n  // Only if none of the two options overflows horizontally, choose the best based on the visible height.\n  if (option1.visibleArea.inlineSize === option2.visibleArea.inlineSize) {\n    return option1.visibleArea.blockSize > option2.visibleArea.blockSize ? option1 : option2;\n  }\n  // Otherwise, choose the option that is less cut off horizontally.\n  return option1.visibleArea.inlineSize > option2.visibleArea.inlineSize ? option1 : option2;\n}\nexport function getOffsetDimensions(element) {\n  return {\n    offsetHeight: element.offsetHeight,\n    offsetWidth: element.offsetWidth\n  };\n}\nexport function getDimensions(element) {\n  const computedStyle = getComputedStyle(element);\n  return {\n    inlineSize: parseFloat(computedStyle.inlineSize),\n    blockSize: parseFloat(computedStyle.blockSize)\n  };\n}\nfunction isTopOrBottom(internalPosition) {\n  return ['top', 'bottom'].includes(internalPosition.split('-')[0]);\n}\nexport function isCenterOutside(child, parent) {\n  const childCenter = child.insetBlockStart + child.blockSize / 2;\n  const overflowsBlockStart = childCenter < parent.insetBlockStart;\n  const overflowsBlockEnd = childCenter > parent.insetBlockEnd;\n  return overflowsBlockStart || overflowsBlockEnd;\n}","map":{"version":3,"names":["ARROW_OFFSET","PRIORITY_MAPPING","top","bottom","left","right","RECTANGLE_CALCULATIONS","top-center","body","trigger","arrow","insetBlockStart","blockSize","insetInlineStart","inlineSize","top-right","top-left","bottom-center","bottom-right","bottom-left","right-top","right-bottom","left-top","left-bottom","fitIntoContainer","inner","outer","getTallestRect","rect1","rect2","getIntersection","rectangles","boundingBox","currentRect","Math","max","insetInlineEnd","min","insetBlockEnd","intersectRectangles","calculatePosition","preferredPosition","fixedInternalPosition","container","viewport","renderWithPortal","allowVerticalOverflow","bestOption","preferredInternalPositions","internalPosition","rect","visibleArea","fitsWithoutOverflow","newOption","getBestOption","tallestBoundingContainer","boundingContainer","isTopOrBottom","optimizedRect","scrollable","option1","option2","getOffsetDimensions","element","offsetHeight","offsetWidth","getDimensions","computedStyle","getComputedStyle","parseFloat","includes","split","isCenterOutside","child","parent","childCenter","overflowsBlockStart","overflowsBlockEnd"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/popover/utils/positions.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { BoundingBox, Dimensions, InternalPosition, PopoverProps, Rect } from '../interfaces';\n\n// A structure describing how the popover should be positioned\ninterface CalculatedPosition {\n  scrollable?: boolean;\n  internalPosition: InternalPosition;\n  rect: BoundingBox;\n}\n\ninterface ElementGroup {\n  body: Dimensions;\n  trigger: BoundingBox;\n  arrow: Dimensions;\n}\n\nconst ARROW_OFFSET = 12;\n\nexport const PRIORITY_MAPPING: Record<PopoverProps.Position, InternalPosition[]> = {\n  top: [\n    'top-center',\n    'top-right',\n    'top-left',\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  bottom: [\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'top-center',\n    'top-right',\n    'top-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  left: [\n    'left-top',\n    'left-bottom',\n    'right-top',\n    'right-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-left',\n    'top-left',\n    'bottom-right',\n    'top-right',\n  ],\n  right: [\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-right',\n    'top-right',\n    'bottom-left',\n    'top-left',\n  ],\n};\n\nconst RECTANGLE_CALCULATIONS: Record<InternalPosition, (r: ElementGroup) => BoundingBox> = {\n  'top-center': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'top-right': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'top-left': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart:\n        trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-center': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-right': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-left': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart:\n        trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'right-top': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'right-bottom': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart:\n        trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'left-top': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'left-bottom': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart:\n        trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n};\n\nfunction fitIntoContainer(inner: BoundingBox, outer: BoundingBox): BoundingBox {\n  let { insetInlineStart, inlineSize, insetBlockStart, blockSize } = inner;\n\n  // Adjust left boundary.\n  if (insetInlineStart < outer.insetInlineStart) {\n    inlineSize = insetInlineStart + inlineSize - outer.insetInlineStart;\n    insetInlineStart = outer.insetInlineStart;\n  }\n  // Adjust right boundary.\n  else if (insetInlineStart + inlineSize > outer.insetInlineStart + outer.inlineSize) {\n    inlineSize = outer.insetInlineStart + outer.inlineSize - insetInlineStart;\n  }\n  // Adjust top boundary.\n  if (insetBlockStart < outer.insetBlockStart) {\n    blockSize = insetBlockStart + blockSize - outer.insetBlockStart;\n    insetBlockStart = outer.insetBlockStart;\n  }\n  // Adjust bottom boundary.\n  else if (insetBlockStart + blockSize > outer.insetBlockStart + outer.blockSize) {\n    blockSize = outer.insetBlockStart + outer.blockSize - insetBlockStart;\n  }\n\n  return { insetInlineStart, inlineSize, insetBlockStart, blockSize };\n}\n\nfunction getTallestRect(rect1: BoundingBox, rect2: BoundingBox): BoundingBox {\n  return rect1.blockSize >= rect2.blockSize ? rect1 : rect2;\n}\n\nfunction getIntersection(rectangles: BoundingBox[]): BoundingBox | null {\n  let boundingBox: BoundingBox | null = null;\n  for (const currentRect of rectangles) {\n    if (!boundingBox) {\n      boundingBox = currentRect;\n      continue;\n    }\n    const insetInlineStart = Math.max(boundingBox.insetInlineStart, currentRect.insetInlineStart);\n    const insetBlockStart = Math.max(boundingBox.insetBlockStart, currentRect.insetBlockStart);\n    const insetInlineEnd = Math.min(\n      boundingBox.insetInlineStart + boundingBox.inlineSize,\n      currentRect.insetInlineStart + currentRect.inlineSize\n    );\n    const insetBlockEnd = Math.min(\n      boundingBox.insetBlockStart + boundingBox.blockSize,\n      currentRect.insetBlockStart + currentRect.blockSize\n    );\n\n    if (insetInlineEnd < insetInlineStart || insetBlockEnd < insetBlockStart) {\n      return null;\n    }\n    boundingBox = {\n      insetInlineStart,\n      insetBlockStart,\n      inlineSize: insetInlineEnd - insetInlineStart,\n      blockSize: insetBlockEnd - insetBlockStart,\n    };\n  }\n  return boundingBox;\n}\n\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles: BoundingBox[]): number | null {\n  const boundingBox: BoundingBox | null = getIntersection(rectangles);\n  return boundingBox && boundingBox.blockSize * boundingBox.inlineSize;\n}\n\ntype CandidatePosition = CalculatedPosition & { visibleArea: BoundingBox | null };\n\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition({\n  preferredPosition,\n  fixedInternalPosition,\n  trigger,\n  arrow,\n  body,\n  container,\n  viewport,\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal,\n  allowVerticalOverflow,\n}: {\n  preferredPosition: PopoverProps.Position;\n  fixedInternalPosition?: InternalPosition;\n  trigger: BoundingBox;\n  arrow: Dimensions;\n  body: Dimensions;\n  container: BoundingBox;\n  viewport: BoundingBox;\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal?: boolean;\n  allowVerticalOverflow?: boolean;\n}): CalculatedPosition {\n  let bestOption: CandidatePosition | null = null;\n\n  // If a fixed internal position is passed, only consider this one.\n  const preferredInternalPositions = fixedInternalPosition\n    ? [fixedInternalPosition]\n    : PRIORITY_MAPPING[preferredPosition];\n\n  // Attempt to position the popover based on the priority list for this position.\n  for (const internalPosition of preferredInternalPositions) {\n    const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n    const visibleArea = renderWithPortal\n      ? getIntersection([rect, viewport])\n      : getIntersection([rect, viewport, container]);\n\n    const fitsWithoutOverflow =\n      visibleArea && visibleArea.inlineSize === body.inlineSize && visibleArea.blockSize === body.blockSize;\n\n    if (fitsWithoutOverflow) {\n      return { internalPosition, rect };\n    }\n\n    const newOption = { rect, internalPosition, visibleArea };\n    bestOption = getBestOption(newOption, bestOption);\n  }\n\n  // Use best possible placement.\n  const internalPosition = bestOption?.internalPosition || 'right-top';\n  // Get default rect for that placement.\n  const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n\n  // Get largest possible rect that fits into the viewport or container.\n\n  // We allow the popover to overflow the viewport if allowVerticalOverflow is true _and_ the popover will be anchored to the top or the bottom.\n  // If it is anchored to the right or left, we consider that it should have enough vertical space so that applying scroll to it is a better option.\n  const tallestBoundingContainer = getTallestRect(viewport, container);\n  const boundingContainer =\n    allowVerticalOverflow && isTopOrBottom(internalPosition)\n      ? {\n          insetBlockStart: tallestBoundingContainer.insetBlockStart,\n          blockSize: tallestBoundingContainer.blockSize,\n          insetInlineStart: viewport.insetInlineStart,\n          inlineSize: viewport.inlineSize,\n        }\n      : viewport;\n\n  const optimizedRect = fitIntoContainer(rect, boundingContainer);\n\n  // If largest possible rect is shorter than original - set body scroll.\n  const scrollable = optimizedRect.blockSize < rect.blockSize;\n\n  return { internalPosition, rect: optimizedRect, scrollable };\n}\n\nfunction getBestOption(option1: CandidatePosition, option2: CandidatePosition | null) {\n  // Within calculatePosition, the only case where option2 will not be defined will be in the first call.\n  // The only case where the visibleArea of an option will be null is when the popover is totally outside of the viewport.\n  if (!option2?.visibleArea) {\n    return option1;\n  }\n  if (!option1.visibleArea) {\n    return option2;\n  }\n  // Only if none of the two options overflows horizontally, choose the best based on the visible height.\n  if (option1.visibleArea.inlineSize === option2.visibleArea.inlineSize) {\n    return option1.visibleArea.blockSize > option2.visibleArea.blockSize ? option1 : option2;\n  }\n  // Otherwise, choose the option that is less cut off horizontally.\n  return option1.visibleArea.inlineSize > option2.visibleArea.inlineSize ? option1 : option2;\n}\n\nexport function getOffsetDimensions(element: HTMLElement) {\n  return { offsetHeight: element.offsetHeight, offsetWidth: element.offsetWidth };\n}\n\nexport function getDimensions(element: HTMLElement) {\n  const computedStyle = getComputedStyle(element);\n  return {\n    inlineSize: parseFloat(computedStyle.inlineSize),\n    blockSize: parseFloat(computedStyle.blockSize),\n  };\n}\n\nfunction isTopOrBottom(internalPosition: InternalPosition) {\n  return ['top', 'bottom'].includes(internalPosition.split('-')[0]);\n}\n\nexport function isCenterOutside(child: Rect, parent: Rect) {\n  const childCenter = child.insetBlockStart + child.blockSize / 2;\n  const overflowsBlockStart = childCenter < parent.insetBlockStart;\n  const overflowsBlockEnd = childCenter > parent.insetBlockEnd;\n  return overflowsBlockStart || overflowsBlockEnd;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}