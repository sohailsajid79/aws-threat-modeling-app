{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEndingOrSpace, markdownLineEnding, markdownSpace } from 'micromark-util-character';\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n};\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n};\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this;\n  return open;\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n    // Exit if there’s stuff before.\n    self.previous !== null ||\n    // Exit if not in the first content that is the first child of a list\n    // item.\n    !self._gfmTasklistFirstContentOfListItem) {\n      return nok(code);\n    }\n    effects.enter('taskListCheck');\n    effects.enter('taskListCheckMarker');\n    effects.consume(code);\n    effects.exit('taskListCheckMarker');\n    return inside;\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueUnchecked');\n      return close;\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked');\n      effects.consume(code);\n      effects.exit('taskListCheckValueChecked');\n      return close;\n    }\n    return nok(code);\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker');\n      effects.consume(code);\n      effects.exit('taskListCheckMarker');\n      effects.exit('taskListCheck');\n      return after;\n    }\n    return nok(code);\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code);\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check({\n        tokenize: spaceThenNonSpace\n      }, ok, nok)(code);\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code);\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace');\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["factorySpace","markdownLineEndingOrSpace","markdownLineEnding","markdownSpace","tasklistCheck","tokenize","tokenizeTasklistCheck","gfmTaskListItem","text","effects","ok","nok","self","open","code","previous","_gfmTasklistFirstContentOfListItem","enter","consume","exit","inside","close","after","check","spaceThenNonSpace"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/@aws-northstar/ui/node_modules/micromark-extension-gfm-task-list-item/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n */\n\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEndingOrSpace,\n  markdownLineEnding,\n  markdownSpace\n} from 'micromark-util-character'\nconst tasklistCheck = {\n  tokenize: tokenizeTasklistCheck\n}\n\n// To do: next major: expose function to make extension.\n\n/**\n * Extension for `micromark` that can be passed in `extensions`, to\n * enable GFM task list items syntax.\n *\n * @type {Extension}\n */\nexport const gfmTaskListItem = {\n  text: {\n    [91]: tasklistCheck\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  const self = this\n  return open\n\n  /**\n   * At start of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *       ^\n   * ```\n   *\n   * @type {State}\n   */\n  function open(code) {\n    if (\n      // Exit if there’s stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  /**\n   * In task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *        ^\n   * ```\n   *\n   * @type {State}\n   */\n  function inside(code) {\n    // Currently we match how GH works in files.\n    // To match how GH works in comments, use `markdownSpace` (`[\\t ]`) instead\n    // of `markdownLineEndingOrSpace` (`[\\t\\n\\r ]`).\n    if (markdownLineEndingOrSpace(code)) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n    return nok(code)\n  }\n\n  /**\n   * At close of task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *         ^\n   * ```\n   *\n   * @type {State}\n   */\n  function close(code) {\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return after\n    }\n    return nok(code)\n  }\n\n  /**\n   * @type {State}\n   */\n  function after(code) {\n    // EOL in paragraph means there must be something else after it.\n    if (markdownLineEnding(code)) {\n      return ok(code)\n    }\n\n    // Space or tab?\n    // Check what comes after.\n    if (markdownSpace(code)) {\n      return effects.check(\n        {\n          tokenize: spaceThenNonSpace\n        },\n        ok,\n        nok\n      )(code)\n    }\n\n    // EOF, or non-whitespace, both wrong.\n    return nok(code)\n  }\n}\n\n/**\n * @this {TokenizeContext}\n * @type {Tokenizer}\n */\nfunction spaceThenNonSpace(effects, ok, nok) {\n  return factorySpace(effects, after, 'whitespace')\n\n  /**\n   * After whitespace, after task list item check.\n   *\n   * ```markdown\n   * > | * [x] y.\n   *           ^\n   * ```\n   *\n   * @type {State}\n   */\n  function after(code) {\n    // EOF means there was nothing, so bad.\n    // EOL means there’s content after it, so good.\n    // Impossible to have more spaces.\n    // Anything else is good.\n    return code === null ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}