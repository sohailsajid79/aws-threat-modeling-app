{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getIsRtl, getScrollInlineStart } from '@cloudscape-design/component-toolkit/internal';\nimport smoothScroll from './smooth-scroll';\nexport const onPaginationClick = (headerBarRef, direction) => {\n  if (!(headerBarRef === null || headerBarRef === void 0 ? void 0 : headerBarRef.current)) {\n    return;\n  }\n  const element = headerBarRef.current;\n  const {\n    scrollLeft,\n    scrollWidth,\n    offsetWidth\n  } = element;\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n  const scrollDistance = direction === 'forward' ? Math.min(Math.abs(scrollLeft) + paginatedSectionSize, scrollWidth - offsetWidth) : Math.max(Math.abs(scrollLeft) - paginatedSectionSize, 0);\n  // scroll destination needs to be a negative number if the direction is RTL\n  const scrollTo = getIsRtl(element) ? scrollDistance * -1 : scrollDistance;\n  smoothScroll(element, scrollTo);\n};\nexport const hasHorizontalOverflow = (headerBar, inlineStartOverflowButton) => {\n  const {\n    offsetWidth,\n    scrollWidth\n  } = headerBar;\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = inlineStartOverflowButton.current && 2 * inlineStartOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\nexport const hasInlineStartOverflow = headerBar => {\n  return getScrollInlineStart(headerBar) > 0;\n};\nexport const hasInlineEndOverflow = headerBar => {\n  return Math.ceil(getScrollInlineStart(headerBar)) < headerBar.scrollWidth - headerBar.offsetWidth;\n};\nexport const scrollIntoView = function (tabHeader, headerBar) {\n  let smooth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(updatedLeftScroll, tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin);\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};","map":{"version":3,"names":["getIsRtl","getScrollInlineStart","smoothScroll","onPaginationClick","headerBarRef","direction","current","element","scrollLeft","scrollWidth","offsetWidth","paginatedSectionSize","Math","ceil","clientWidth","scrollDistance","min","abs","max","scrollTo","hasHorizontalOverflow","headerBar","inlineStartOverflowButton","paginationButtonsWidth","hasInlineStartOverflow","hasInlineEndOverflow","scrollIntoView","tabHeader","smooth","arguments","length","undefined","margin","updatedLeftScroll","offsetLeft"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/src/tabs/scroll-utils.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getIsRtl, getScrollInlineStart } from '@cloudscape-design/component-toolkit/internal';\n\nimport smoothScroll from './smooth-scroll';\n\nexport const onPaginationClick = (\n  headerBarRef: React.RefObject<HTMLUListElement>,\n  direction: 'forward' | 'backward'\n): void => {\n  if (!headerBarRef?.current) {\n    return;\n  }\n  const element = headerBarRef.current;\n  const { scrollLeft, scrollWidth, offsetWidth } = element;\n\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  const scrollDistance =\n    direction === 'forward'\n      ? Math.min(Math.abs(scrollLeft) + paginatedSectionSize, scrollWidth - offsetWidth)\n      : Math.max(Math.abs(scrollLeft) - paginatedSectionSize, 0);\n\n  // scroll destination needs to be a negative number if the direction is RTL\n  const scrollTo = getIsRtl(element) ? scrollDistance * -1 : scrollDistance;\n\n  smoothScroll(element, scrollTo);\n};\n\nexport const hasHorizontalOverflow = (\n  headerBar: HTMLElement,\n  inlineStartOverflowButton: React.RefObject<HTMLElement>\n): boolean => {\n  const { offsetWidth, scrollWidth } = headerBar;\n\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = inlineStartOverflowButton.current && 2 * inlineStartOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\n\nexport const hasInlineStartOverflow = (headerBar: HTMLElement): boolean => {\n  return getScrollInlineStart(headerBar) > 0;\n};\n\nexport const hasInlineEndOverflow = (headerBar: HTMLElement): boolean => {\n  return Math.ceil(getScrollInlineStart(headerBar)) < headerBar.scrollWidth - headerBar.offsetWidth;\n};\n\nexport const scrollIntoView = (tabHeader: HTMLElement, headerBar: HTMLElement, smooth = true): void => {\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(\n    updatedLeftScroll,\n    tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin\n  );\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};\n"],"mappings":"AAAA;AACA;AACA,SAASA,QAAQ,EAAEC,oBAAoB,QAAQ,+CAA+C;AAE9F,OAAOC,YAAY,MAAM,iBAAiB;AAE1C,OAAO,MAAMC,iBAAiB,GAAGA,CAC/BC,YAA+C,EAC/CC,SAAiC,KACzB;EACR,IAAI,EAACD,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAEE,OAAO,GAAE;IAC1B;;EAEF,MAAMC,OAAO,GAAGH,YAAY,CAACE,OAAO;EACpC,MAAM;IAAEE,UAAU;IAAEC,WAAW;IAAEC;EAAW,CAAE,GAAGH,OAAO;EAExD;EACA,MAAMI,oBAAoB,GAAGC,IAAI,CAACC,IAAI,CAACN,OAAO,CAACO,WAAW,GAAG,IAAI,CAAC;EAElE,MAAMC,cAAc,GAClBV,SAAS,KAAK,SAAS,GACnBO,IAAI,CAACI,GAAG,CAACJ,IAAI,CAACK,GAAG,CAACT,UAAU,CAAC,GAAGG,oBAAoB,EAAEF,WAAW,GAAGC,WAAW,CAAC,GAChFE,IAAI,CAACM,GAAG,CAACN,IAAI,CAACK,GAAG,CAACT,UAAU,CAAC,GAAGG,oBAAoB,EAAE,CAAC,CAAC;EAE9D;EACA,MAAMQ,QAAQ,GAAGnB,QAAQ,CAACO,OAAO,CAAC,GAAGQ,cAAc,GAAG,CAAC,CAAC,GAAGA,cAAc;EAEzEb,YAAY,CAACK,OAAO,EAAEY,QAAQ,CAAC;AACjC,CAAC;AAED,OAAO,MAAMC,qBAAqB,GAAGA,CACnCC,SAAsB,EACtBC,yBAAuD,KAC5C;EACX,MAAM;IAAEZ,WAAW;IAAED;EAAW,CAAE,GAAGY,SAAS;EAE9C;EACA,MAAME,sBAAsB,GAAGD,yBAAyB,CAAChB,OAAO,IAAI,CAAC,GAAGgB,yBAAyB,CAAChB,OAAO,CAACI,WAAW;EACrH,OAAOa,sBAAsB,GAAGd,WAAW,GAAGC,WAAW,GAAGa,sBAAsB,GAAGd,WAAW,GAAGC,WAAW;AAChH,CAAC;AAED,OAAO,MAAMc,sBAAsB,GAAIH,SAAsB,IAAa;EACxE,OAAOpB,oBAAoB,CAACoB,SAAS,CAAC,GAAG,CAAC;AAC5C,CAAC;AAED,OAAO,MAAMI,oBAAoB,GAAIJ,SAAsB,IAAa;EACtE,OAAOT,IAAI,CAACC,IAAI,CAACZ,oBAAoB,CAACoB,SAAS,CAAC,CAAC,GAAGA,SAAS,CAACZ,WAAW,GAAGY,SAAS,CAACX,WAAW;AACnG,CAAC;AAED,OAAO,MAAMgB,cAAc,GAAG,SAAAA,CAACC,SAAsB,EAAEN,SAAsB,EAAyB;EAAA,IAAvBO,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;EAC1F,IAAI,CAACF,SAAS,IAAI,CAACN,SAAS,EAAE;IAC5B;;EAEF;EACA,MAAMW,MAAM,GAAG,CAAC;EAChB,IAAIC,iBAAiB,GAAGZ,SAAS,CAACb,UAAU;EAE5C;EACAyB,iBAAiB,GAAGrB,IAAI,CAACI,GAAG,CAACiB,iBAAiB,EAAEN,SAAS,CAACO,UAAU,GAAGF,MAAM,CAAC;EAC9E;EACAC,iBAAiB,GAAGrB,IAAI,CAACM,GAAG,CAC1Be,iBAAiB,EACjBN,SAAS,CAACO,UAAU,GAAGP,SAAS,CAACjB,WAAW,GAAGW,SAAS,CAACX,WAAW,GAAGsB,MAAM,CAC9E;EACD,IAAIJ,MAAM,EAAE;IACV1B,YAAY,CAACmB,SAAS,EAAEY,iBAAiB,CAAC;GAC3C,MAAM;IACLZ,SAAS,CAACb,UAAU,GAAGyB,iBAAiB;;AAE5C,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}