{"ast":null,"code":"import { getIn } from 'final-form';\n\n//      \n\n/**\n * Predicate to identify inputs that can have focus() called on them\n */\nvar isFocusableInput = function isFocusableInput(wtf) {\n  return !!(wtf && typeof wtf.focus === 'function');\n};\n\n//      \n/**\n * Gets all the inputs inside all forms on the page\n */\n\nvar getAllInputs = function getAllInputs() {\n  if (typeof document === 'undefined') {\n    return [];\n  }\n  return Array.prototype.slice.call(document.forms).reduce(function (accumulator, form) {\n    return accumulator.concat(Array.prototype.slice.call(form).filter(isFocusableInput));\n  }, []);\n};\n\n//      \n/**\n * Finds the input by looking if the name attribute path is existing in the errors object\n */\n\nvar findInput = function findInput(inputs, errors) {\n  return inputs.find(function (input) {\n    return input.name && getIn(errors, input.name);\n  });\n};\n\n//      \n\nvar noop = function noop() {};\nvar createDecorator = function createDecorator(getInputs, findInput$$1) {\n  return function (form) {\n    var focusOnFirstError = function focusOnFirstError(errors) {\n      if (!getInputs) {\n        getInputs = getAllInputs;\n      }\n      if (!findInput$$1) {\n        findInput$$1 = findInput;\n      }\n      var firstInput = findInput$$1(getInputs(), errors);\n      if (firstInput) {\n        firstInput.focus();\n      }\n    }; // Save original submit function\n\n    var originalSubmit = form.submit; // Subscribe to errors, and keep a local copy of them\n\n    var state = {};\n    var unsubscribe = form.subscribe(function (nextState) {\n      state = nextState;\n    }, {\n      errors: true,\n      submitErrors: true\n    }); // What to do after submit\n\n    var afterSubmit = function afterSubmit() {\n      var _state = state,\n        errors = _state.errors,\n        submitErrors = _state.submitErrors;\n      if (errors && Object.keys(errors).length) {\n        focusOnFirstError(errors);\n      } else if (submitErrors && Object.keys(submitErrors).length) {\n        focusOnFirstError(submitErrors);\n      }\n    }; // Rewrite submit function\n\n    form.submit = function () {\n      var result = originalSubmit.call(form);\n      if (result && typeof result.then === 'function') {\n        // async\n        result.then(afterSubmit, noop);\n      } else {\n        // sync\n        afterSubmit();\n      }\n      return result;\n    };\n    return function () {\n      unsubscribe();\n      form.submit = originalSubmit;\n    };\n  };\n};\n\n//      \n/**\n * Generates a function to get all the inputs in a form with the specified name\n */\n\nvar getFormInputs = function getFormInputs(name) {\n  return function () {\n    if (typeof document === 'undefined') {\n      return [];\n    } // $FlowFixMe\n\n    var form = document.forms[name];\n    return form && form.length ? Array.prototype.slice.call(form).filter(isFocusableInput) : []; // cast cheat to get from HTMLFormElement children to FocusableInput\n  };\n};\n\n//\n\nexport default createDecorator;\nexport { getFormInputs };","map":{"version":3,"names":["getIn","isFocusableInput","wtf","focus","getAllInputs","document","Array","prototype","slice","call","forms","reduce","accumulator","form","concat","filter","findInput","inputs","errors","find","input","name","noop","createDecorator","getInputs","findInput$$1","focusOnFirstError","firstInput","originalSubmit","submit","state","unsubscribe","subscribe","nextState","submitErrors","afterSubmit","_state","Object","keys","length","result","then","getFormInputs"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/final-form-focus/dist/final-form-focus.es.js"],"sourcesContent":["import { getIn } from 'final-form';\n\n//      \n\n/**\n * Predicate to identify inputs that can have focus() called on them\n */\nvar isFocusableInput = function isFocusableInput(wtf) {\n  return !!(wtf && typeof wtf.focus === 'function');\n};\n\n//      \n/**\n * Gets all the inputs inside all forms on the page\n */\n\nvar getAllInputs = function getAllInputs() {\n  if (typeof document === 'undefined') {\n    return [];\n  }\n\n  return Array.prototype.slice.call(document.forms).reduce(function (accumulator, form) {\n    return accumulator.concat(Array.prototype.slice.call(form).filter(isFocusableInput));\n  }, []);\n};\n\n//      \n/**\n * Finds the input by looking if the name attribute path is existing in the errors object\n */\n\nvar findInput = function findInput(inputs, errors) {\n  return inputs.find(function (input) {\n    return input.name && getIn(errors, input.name);\n  });\n};\n\n//      \n\nvar noop = function noop() {};\n\nvar createDecorator = function createDecorator(getInputs, findInput$$1) {\n  return function (form) {\n    var focusOnFirstError = function focusOnFirstError(errors) {\n      if (!getInputs) {\n        getInputs = getAllInputs;\n      }\n\n      if (!findInput$$1) {\n        findInput$$1 = findInput;\n      }\n\n      var firstInput = findInput$$1(getInputs(), errors);\n\n      if (firstInput) {\n        firstInput.focus();\n      }\n    }; // Save original submit function\n\n\n    var originalSubmit = form.submit; // Subscribe to errors, and keep a local copy of them\n\n    var state = {};\n    var unsubscribe = form.subscribe(function (nextState) {\n      state = nextState;\n    }, {\n      errors: true,\n      submitErrors: true\n    }); // What to do after submit\n\n    var afterSubmit = function afterSubmit() {\n      var _state = state,\n          errors = _state.errors,\n          submitErrors = _state.submitErrors;\n\n      if (errors && Object.keys(errors).length) {\n        focusOnFirstError(errors);\n      } else if (submitErrors && Object.keys(submitErrors).length) {\n        focusOnFirstError(submitErrors);\n      }\n    }; // Rewrite submit function\n\n\n    form.submit = function () {\n      var result = originalSubmit.call(form);\n\n      if (result && typeof result.then === 'function') {\n        // async\n        result.then(afterSubmit, noop);\n      } else {\n        // sync\n        afterSubmit();\n      }\n\n      return result;\n    };\n\n    return function () {\n      unsubscribe();\n      form.submit = originalSubmit;\n    };\n  };\n};\n\n//      \n/**\n * Generates a function to get all the inputs in a form with the specified name\n */\n\nvar getFormInputs = function getFormInputs(name) {\n  return function () {\n    if (typeof document === 'undefined') {\n      return [];\n    } // $FlowFixMe\n\n\n    var form = document.forms[name];\n    return form && form.length ? Array.prototype.slice.call(form).filter(isFocusableInput) : []; // cast cheat to get from HTMLFormElement children to FocusableInput\n  };\n};\n\n//\n\nexport default createDecorator;\nexport { getFormInputs };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}