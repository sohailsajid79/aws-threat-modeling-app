{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function getIsRtl(element) {\n  if (!element) {\n    return false;\n  }\n  return getComputedStyle(element).direction === 'rtl';\n}\n/**\n * The offsetLeft property is relative to the left of the offsetParent\n * regardless of the document direction. This function returns the\n * offsetLeft value or computes the Rtl equivalent of this value\n * from the right of the offsetParent.\n */\nexport function getOffsetInlineStart(element) {\n  var _a, _b;\n  const offsetParentWidth = (_b = (_a = element.offsetParent) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 0;\n  return getIsRtl(element) ? offsetParentWidth - element.offsetWidth - element.offsetLeft : element.offsetLeft;\n}\n/**\n * The scrollLeft value returned by the browser will be a negative number\n * if the direction is RTL. This function returns a positive value for direction\n * independent of scroll computations. Additionally, the scrollLeft value can be\n * a decimal value on systems using display scaling requiring the floor and ceiling calls.\n */\nexport function getScrollInlineStart(element) {\n  return getIsRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);\n}\n/**\n * The clientX value is computed from the top left corner of the document regardless\n * of the document diretion. This function returns the clientX value or computes the\n * Rtl equivalent relative to the top right corner of the document in order for\n * computations to yield the same result in both element directions.\n */\nexport function getLogicalClientX(event, IsRtl) {\n  return IsRtl ? document.documentElement.clientWidth - event.clientX : event.clientX;\n}\n/**\n * The getBoundingClientRect() function returns values relative to the top left\n * corner of the document regardless of document direction. The left/right position\n * will be transformed to insetInlineStart based on element direction in order to\n * support direction agnostic position computation.\n */\nexport function getLogicalBoundingClientRect(element) {\n  const boundingClientRect = element.getBoundingClientRect();\n  const blockSize = boundingClientRect.height;\n  const inlineSize = boundingClientRect.width;\n  const insetBlockStart = boundingClientRect.top;\n  const insetBlockEnd = boundingClientRect.bottom;\n  const insetInlineStart = getIsRtl(element) ? document.documentElement.clientWidth - boundingClientRect.right : boundingClientRect.left;\n  const insetInlineEnd = insetInlineStart + inlineSize;\n  return {\n    blockSize,\n    inlineSize,\n    insetBlockStart,\n    insetBlockEnd,\n    insetInlineStart,\n    insetInlineEnd\n  };\n}\n/**\n * The pageX position needs to be converted so it is relative to the right of\n * the document in order for computations to yield the same result in both\n * element directions.\n */\nexport function getLogicalPageX(event) {\n  return event.target instanceof HTMLElement && getIsRtl(event.target) ? document.documentElement.clientWidth - event.pageX : event.pageX;\n}","map":{"version":3,"names":["getIsRtl","element","getComputedStyle","direction","getOffsetInlineStart","_a","_b","offsetParentWidth","offsetParent","clientWidth","offsetWidth","offsetLeft","getScrollInlineStart","Math","floor","scrollLeft","ceil","getLogicalClientX","event","IsRtl","document","documentElement","clientX","getLogicalBoundingClientRect","boundingClientRect","getBoundingClientRect","blockSize","height","inlineSize","width","insetBlockStart","top","insetBlockEnd","bottom","insetInlineStart","right","left","insetInlineEnd","getLogicalPageX","target","HTMLElement","pageX"],"sources":["/Users/sohailsajid/Desktop/threat-modeling-app/node_modules/@cloudscape-design/component-toolkit/internal/direction/index.js"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport function getIsRtl(element) {\n    if (!element) {\n        return false;\n    }\n    return getComputedStyle(element).direction === 'rtl';\n}\n/**\n * The offsetLeft property is relative to the left of the offsetParent\n * regardless of the document direction. This function returns the\n * offsetLeft value or computes the Rtl equivalent of this value\n * from the right of the offsetParent.\n */\nexport function getOffsetInlineStart(element) {\n    var _a, _b;\n    const offsetParentWidth = (_b = (_a = element.offsetParent) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 0;\n    return getIsRtl(element) ? offsetParentWidth - element.offsetWidth - element.offsetLeft : element.offsetLeft;\n}\n/**\n * The scrollLeft value returned by the browser will be a negative number\n * if the direction is RTL. This function returns a positive value for direction\n * independent of scroll computations. Additionally, the scrollLeft value can be\n * a decimal value on systems using display scaling requiring the floor and ceiling calls.\n */\nexport function getScrollInlineStart(element) {\n    return getIsRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);\n}\n/**\n * The clientX value is computed from the top left corner of the document regardless\n * of the document diretion. This function returns the clientX value or computes the\n * Rtl equivalent relative to the top right corner of the document in order for\n * computations to yield the same result in both element directions.\n */\nexport function getLogicalClientX(event, IsRtl) {\n    return IsRtl ? document.documentElement.clientWidth - event.clientX : event.clientX;\n}\n/**\n * The getBoundingClientRect() function returns values relative to the top left\n * corner of the document regardless of document direction. The left/right position\n * will be transformed to insetInlineStart based on element direction in order to\n * support direction agnostic position computation.\n */\nexport function getLogicalBoundingClientRect(element) {\n    const boundingClientRect = element.getBoundingClientRect();\n    const blockSize = boundingClientRect.height;\n    const inlineSize = boundingClientRect.width;\n    const insetBlockStart = boundingClientRect.top;\n    const insetBlockEnd = boundingClientRect.bottom;\n    const insetInlineStart = getIsRtl(element)\n        ? document.documentElement.clientWidth - boundingClientRect.right\n        : boundingClientRect.left;\n    const insetInlineEnd = insetInlineStart + inlineSize;\n    return {\n        blockSize,\n        inlineSize,\n        insetBlockStart,\n        insetBlockEnd,\n        insetInlineStart,\n        insetInlineEnd,\n    };\n}\n/**\n * The pageX position needs to be converted so it is relative to the right of\n * the document in order for computations to yield the same result in both\n * element directions.\n */\nexport function getLogicalPageX(event) {\n    return event.target instanceof HTMLElement && getIsRtl(event.target)\n        ? document.documentElement.clientWidth - event.pageX\n        : event.pageX;\n}\n"],"mappings":"AAAA;AACA;AACA,OAAO,SAASA,QAAQA,CAACC,OAAO,EAAE;EAC9B,IAAI,CAACA,OAAO,EAAE;IACV,OAAO,KAAK;EAChB;EACA,OAAOC,gBAAgB,CAACD,OAAO,CAAC,CAACE,SAAS,KAAK,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACH,OAAO,EAAE;EAC1C,IAAII,EAAE,EAAEC,EAAE;EACV,MAAMC,iBAAiB,GAAG,CAACD,EAAE,GAAG,CAACD,EAAE,GAAGJ,OAAO,CAACO,YAAY,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACI,WAAW,MAAM,IAAI,IAAIH,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC;EACnJ,OAAON,QAAQ,CAACC,OAAO,CAAC,GAAGM,iBAAiB,GAAGN,OAAO,CAACS,WAAW,GAAGT,OAAO,CAACU,UAAU,GAAGV,OAAO,CAACU,UAAU;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,oBAAoBA,CAACX,OAAO,EAAE;EAC1C,OAAOD,QAAQ,CAACC,OAAO,CAAC,GAAGY,IAAI,CAACC,KAAK,CAACb,OAAO,CAACc,UAAU,CAAC,GAAG,CAAC,CAAC,GAAGF,IAAI,CAACG,IAAI,CAACf,OAAO,CAACc,UAAU,CAAC;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,iBAAiBA,CAACC,KAAK,EAAEC,KAAK,EAAE;EAC5C,OAAOA,KAAK,GAAGC,QAAQ,CAACC,eAAe,CAACZ,WAAW,GAAGS,KAAK,CAACI,OAAO,GAAGJ,KAAK,CAACI,OAAO;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,4BAA4BA,CAACtB,OAAO,EAAE;EAClD,MAAMuB,kBAAkB,GAAGvB,OAAO,CAACwB,qBAAqB,CAAC,CAAC;EAC1D,MAAMC,SAAS,GAAGF,kBAAkB,CAACG,MAAM;EAC3C,MAAMC,UAAU,GAAGJ,kBAAkB,CAACK,KAAK;EAC3C,MAAMC,eAAe,GAAGN,kBAAkB,CAACO,GAAG;EAC9C,MAAMC,aAAa,GAAGR,kBAAkB,CAACS,MAAM;EAC/C,MAAMC,gBAAgB,GAAGlC,QAAQ,CAACC,OAAO,CAAC,GACpCmB,QAAQ,CAACC,eAAe,CAACZ,WAAW,GAAGe,kBAAkB,CAACW,KAAK,GAC/DX,kBAAkB,CAACY,IAAI;EAC7B,MAAMC,cAAc,GAAGH,gBAAgB,GAAGN,UAAU;EACpD,OAAO;IACHF,SAAS;IACTE,UAAU;IACVE,eAAe;IACfE,aAAa;IACbE,gBAAgB;IAChBG;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,eAAeA,CAACpB,KAAK,EAAE;EACnC,OAAOA,KAAK,CAACqB,MAAM,YAAYC,WAAW,IAAIxC,QAAQ,CAACkB,KAAK,CAACqB,MAAM,CAAC,GAC9DnB,QAAQ,CAACC,eAAe,CAACZ,WAAW,GAAGS,KAAK,CAACuB,KAAK,GAClDvB,KAAK,CAACuB,KAAK;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}